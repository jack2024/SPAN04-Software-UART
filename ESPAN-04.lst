CCS PCH C Compiler, Version 4.104, 5967               16-¸.¤.-20 12:51

               Filename: D:\jobESP\ESPAN-04\Firmware\SPAN-04\ESPAN04_8 - Delay - SP - SMS\ESPAN-04.lst

               ROM used: 27648 bytes (56%)
                         Largest free fragment is 21500
               RAM used: 2161 (54%) at main() level
                         2181 (55%) worst case
               Stack:    6 worst case (4 in main + 2 for interrupts)

*
0000:  GOTO   63B6
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  F9D.1
004A:  GOTO   0054
004E:  BTFSC  F9E.1
0050:  GOTO   0542
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   0530
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVF   04,W
0098:  MOVFF  06,FE0
009C:  MOVFF  05,FD8
00A0:  RETFIE 0
....................  
.................... #include "D:\jobESP\ESPAN-04\Firmware\SPAN-04\ESPAN04_16\ESPAN-04.h" 
.................... #include<18F2525.h> 
.................... //////// Standard Header file for the PIC18F2525 device //////////////// 
.................... #device PIC18F2525 
.................... #list 
....................  
.................... //#device adc=8 
.................... #FUSES WDT 
.................... #FUSES WDT64                    //Watch Dog Timer uses 1:64 Postscale 
.................... #FUSES HS    //jj                   //High speed Osc (> 4mhz) 
.................... #FUSES PROTECT                //Code not protected from reading 
.................... //#FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES BROWNOUT                 //Reset when brownout detected 
.................... #FUSES BORV20                   //Brownout reset at 2.0V 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOCPD                    //No EE protection 
.................... //#FUSES STVREN                   //Stack full/underflow will cause reset 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... //#FUSES DEBUG                  //No Debug mode for ICD 
.................... //#FUSES ICS 
.................... //#FUSES LVP                      //Low Voltage Programming on B3(PIC16) or B5(PIC18) 
.................... //#FUSES NOWRT                    //Program memory not write protected 
.................... //#FUSES NOWRTD                   //Data EEPROM not write protected 
.................... #FUSES NOEBTR                   //Memory not protected from table reads 
.................... #FUSES NOCPB                    //No Boot Block code protection 
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads 
.................... #FUSES NOWRTC                   //configuration not registers write protected 
.................... #FUSES NOWRTB                   //Boot block not write protected 
.................... //#FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PBADEN                   //PORTB pins are configured as analog input channels on RESET 
.................... #FUSES LPT1OSC                  //Timer1 configured for low-power operation 
.................... #FUSES MCLR                     //Master Clear pin enabled 
....................  
.................... #define CLOCK_SP   20000000   //Clock Speed 20MHz 
....................  
.................... //#device icd = true 
....................  
.................... //23S17 Define 
.................... #define IO_MULTIPLE_DEVICES 
.................... #define IO_CS_PIN PIN_A5 
....................  
.................... #use delay(clock=20000000,RESTART_WDT) 
*
0772:  MOVLW  08
0774:  MOVWF  FEA
0776:  MOVLW  79
0778:  MOVWF  FE9
077A:  MOVF   FEF,W
077C:  BZ    07A0
077E:  MOVLW  06
0780:  MOVWF  01
0782:  MOVLW  BF
0784:  MOVWF  00
0786:  CLRWDT
0788:  DECFSZ 00,F
078A:  BRA    0786
078C:  DECFSZ 01,F
078E:  BRA    0782
0790:  MOVLW  7A
0792:  MOVWF  00
0794:  DECFSZ 00,F
0796:  BRA    0794
0798:  BRA    079A
079A:  CLRWDT
079C:  DECFSZ FEF,F
079E:  BRA    077E
07A0:  RETLW  00
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
....................  
.................... /* 
.................... #include <16F886.h> 
.................... #device adc=10 
....................  
.................... #FUSES WDT                      //Watch Dog Timer 
.................... #FUSES HS                       //High speed Osc (> 4mhz) 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... //#FUSES MCLR                     //Master Clear pin enabled 
.................... #FUSES PROTECT                  //Code protected from reads 
.................... //#FUSES CPD                      //Data EEPROM Code Protected 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... //#FUSES IESO                     //Internal External Switch Over mode enabled 
.................... //#FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... //#FUSES LVP                      //Low Voltage Programming on B3(PIC16) or B5(PIC18) 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... //#FUSES BORV21                   //Brownout reset at 2.1V 
.................... //#FUSES WRT                      //Program Memory Write Protected 
....................  
.................... #use delay(clock=20000000,RESTART_WDT) 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,restart_wdt) 
.................... */ 
....................  
....................  
.................... #include "D:\jobESP\ESPAN-04\Firmware\SPAN-04\ESPAN04_16\23S17.c" // 16 bit I/O Expander 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                        23S17.c                                      //// 
.................... ////                                                                   //// 
.................... ////   Library for a MicroChip MCP23S17 SPI Port Expansion Chip        //// 
.................... ////                                                                   //// 
.................... //// The MCP23S17 device provides 16-bit, general purpose parallel I/O //// 
.................... //// expansion for SPI applications. The 16-bit I/O port functionally  //// 
.................... //// consists of two 8-bit ports (PORTA and PORTB). There are two      //// 
.................... //// interrupt pins, INTA and INTB, that can be associated with their  //// 
.................... //// respective ports, or can be logically OR’ed together so that both //// 
.................... //// pins will activate if either port causes an interrupt. The        //// 
.................... //// hardware address pins are used to determine the device address.   ////                                                 //// 
.................... ////                                                                   //// 
.................... ////  A #use spi must be provided by the main program.                 //// 
.................... ////                                                                   //// 
.................... ////  -------------------------------------------------------------    //// 
.................... ////  PIN LAYOUT                                                       //// 
.................... ////  -------------------------------------------------------------    //// 
.................... ////                                                                    //// 
.................... ////        -------------------------------------------                //// 
.................... ////        | 1 : GPB0          | 28: GPA7            |                //// 
.................... ////        |                   |                     |                //// 
.................... ////        | 2 : GPB1          | 27: GPA6            |                //// 
.................... ////        |                   |                     |                //// 
.................... ////        | 3 : GPB2          | 26: GPA5            |                //// 
.................... ////        |                   |                     |                //// 
.................... ////        | 4 : GPB3          | 25: GPA4            |                //// 
.................... ////        |                   |                     |                //// 
.................... ////        | 5 : GPB4          | 24: GPA3            |                //// 
.................... ////        |                   |                     |                //// 
.................... ////        | 6 : GPB5          | 23: GPA2            |                //// 
.................... ////        |                   |                     |                //// 
.................... ////        | 7 : GPB6          | 22: GPA1            |                //// 
.................... ////        |                   |                     |                //// 
.................... ////        | 8 : GPB7          | 21: GPA0            |                //// 
.................... ////        |                   |                     |                //// 
.................... ////        | 9 : Vdd           | 20: INTA            |                //// 
.................... ////        |                   |                     |                //// 
.................... ////        | 10: Vss           | 19: INTB            |                //// 
.................... ////        |     __            |     _____           |                //// 
.................... ////        | 11: CS            | 18: RESET           |                //// 
.................... ////        |                   |                     |                //// 
.................... ////        | 12: SCK           | 17: A2              |                //// 
.................... ////        |                   |                     |                //// 
.................... ////        | 13: SI            | 16: A1              |                //// 
.................... ////        |                   |                     |                //// 
.................... ////        | 14: SO            | 15: A0              |                //// 
.................... ////        -------------------------------------------                //// 
.................... ////                                                                   //// 
.................... ////  -------------------------------------------------------------    //// 
.................... ////  FUNCTIONS                                                        //// 
.................... ////  -------------------------------------------------------------    //// 
.................... ////                                                                   //// 
.................... ////   void IO_INIT()                                                   ////                    
.................... ////     Initializes the 23S17 chips on the SPI bus                      ////                                                  
.................... ////                                                                   ////   
.................... ////  void IO_WRITE_REGISTER(int8 address, int8 reg, int8 data)        //// 
.................... ////     Writes the value to the specified register and device          ////                                                             
.................... ////                                                                   ////   
.................... ////  int8 IO_READ_REGISTER(int8 address, int8 reg);                    //// 
.................... ////     Reads the value of the specified register and device          ////                                                            
.................... ////                                                                   ////   
.................... ////  void IO_OUTPUT_A(int8 address, int8 data);                       //// 
.................... ////     Outputs the value to PORTA on the specified device. Doesn't   //// 
.................... ////     change the direction of the port.                             //// 
.................... ////                                                                   ////       
.................... ////  void IO_OUTPUT_B(int8 address, int8 data);                       //// 
.................... ////     Outputs the value to PORTB on the specified device. Doesn't   //// 
.................... ////     change the direction of the port.                             //// 
.................... ////                                                                   ////       
.................... ////  int8 IO_INPUT_A(int8 address)                                    //// 
.................... ////     Returns the value of PORTA on the specified device. Doesn't   //// 
.................... ////     change the direction of the port.                             //// 
.................... ////                                                                   ////       
.................... ////  int8 IO_INPUT_B(int8 address)                                    //// 
.................... ////     Returns the value of PORTB on the specified device. Doesn't   //// 
.................... ////     change the direction of the port.                             //// 
.................... ////                                                                   ////       
.................... ////  void IO_OUTPUT_BIT(int8 address, int8 pin, int1 state)           //// 
.................... ////     Outputs the value to specified pin and device. Doesn't change //// 
.................... ////      the direction of the pin.                                     //// 
.................... ////                                                                   ////       
.................... ////  void IO_OUTPUT_HIGH(int8 address, int8 pin)                      //// 
.................... ////     Sets the output high on the specified pin and device. Doesn't //// 
.................... ////     change the direction of the pin.                              //// 
.................... ////                                                                   ////       
.................... ////  void IO_OUTPUT_LOW(int8 address, int8 pin)                       //// 
.................... ////     Sets the output low on the specified pin and device. Doesn't  //// 
.................... ////     change the direction of the pin.                              //// 
.................... ////                                                                   ////    
.................... ////  void IO_OUTPUT_FLOAT(int8 address, int8 pin)                     //// 
.................... ////     Sets the pin to an input on the specified device.             //// 
.................... ////                                                                   //// 
.................... ////  void IO_OUTPUT_TOGGLE(int8 address, int8 pin)                    //// 
.................... ////     Toggles the output on the specified pin and device. Doesn't   //// 
.................... ////     change the direction of the pin.                              //// 
.................... ////                                                                   ////       
.................... ////  void IO_OUTPUT_DRIVE(int8 address, int8 pin)                     //// 
.................... ////     Sets the pin to an output on the specified device.            //// 
.................... ////                                                                   ////       
.................... ////  int1 IO_INPUT(int8 address, int8 pin)                            //// 
.................... ////     Gets the current value on the specified pin and device.       //// 
.................... ////                                                                   ////       
.................... ////  int1 IO_INPUT_STATE(int8 address, int8 pin)                      //// 
.................... ////     Gets the current value on the specified pin and device.       ////  
.................... ////     Doesn't change the direction of the pin.                      //// 
.................... ////                                                                   ////       
.................... ////  int8 IO_GET_TRIS_A(int8 address)                                 //// 
.................... ////     Gets the data direction register for PORTA on the specified   ////  
.................... ////      device.                                                       //// 
.................... ////                                                                   ////       
.................... ////  void IO_SET_TRIS_A(int8 address, int8 data)                      //// 
.................... ////     Sets the data direction register for PORTA on the specified   ////  
.................... ////      device.                                                       //// 
.................... ////                                                                   ////       
.................... ////  int8 IO_GET_TRIS_B(int8 address)                                 //// 
.................... ////     Gets the data direction register for PORTB on the specified   ////  
.................... ////      device.                                                       //// 
.................... ////                                                                   ////       
.................... ////  void IO_SET_TRIS_B(int8 address, int8 data)                      //// 
.................... ////     Sets the data direction register for PORTB on the specified   ////  
.................... ////      device.                                                       //// 
.................... ////                                                                   ////                                                                    //// 
.................... ////  NOTE: address is only valid if IO_MULTIPLE_DEVICES is defined    //// 
.................... ////        in your main program. Use the provided #defines as         //// 
.................... ////        parameters for the address, pin, and reg fields.           //// 
.................... ////                                                                    //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// VERSION HISTORY:                                                  //// 
.................... ////                                                                   //// 
.................... //// Author Date        Comments                                       //// 
.................... //// -----  -------     ----------------------------------             //// 
.................... //// TMH    Jul-29-2009 File Created                                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2009 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #ifndef MCP23S17 
.................... #define MCP23S17 
....................  
.................... /****************************************************************************** 
.................... **** DEFINES 
.................... ******************************************************************************/ 
....................  
.................... //This is the device address mask. Device supports up to 8 of the chips on the 
.................... //same bus. If multiple devices are to be used on the same bus, define  
.................... //IO_MULTIPLE_DEVICES in your program. This will add an address field to all  
.................... //functions. If IO_MULTIPLE_DEVICE is not defined, an address of 0 will be  
.................... //assumed (i.e. ground A2, A1, A0) 
.................... #define IO_DEVICE_ADDRESS_READ   0b01000001 
.................... #define IO_DEVICE_ADDRESS_WRITE  0b01000000 
....................  
.................... //User must define a CS pin in main. This pin can be connected to all similar 
.................... //devices on the bus. 
.................... //!#ifndef IO_CS_PIN 
.................... //!#error Must define a chip select pin. 
.................... //!#endif 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Address Defines 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Use these in the address field if using multiple 23S17 devices. If bit 3 
.................... //// in IOCON is cleared these no longer work and only device 0 can be operated 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifdef IO_MULTIPLE_DEVICES 
....................  
.................... #define IO_DEVICE_0   0b00000000 
.................... #define IO_DEVICE_1   0b00000010 
.................... #define IO_DEVICE_2   0b00000100 
.................... #define IO_DEVICE_3   0b00000110 
.................... #define IO_DEVICE_4   0b00001000 
.................... #define IO_DEVICE_5   0b00001010 
.................... #define IO_DEVICE_6   0b00001100 
.................... #define IO_DEVICE_7   0b00001110 
....................  
.................... #endif 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Device Register Defines 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Used in the reg field. If IOCON bit 7 is cleared these no longer are  
.................... //// correct, use values to right. Refer to data sheet for more information 
.................... //// on their use. 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #define IODIRA      0x00     //0x00   Data Direction Register for PORTA 
.................... #define IPOLA     0x01     //0x02   Input Polarity Register for PORTA 
.................... #define GPINTENA    0x02     //0x04     Interrupt-on-change enable Register for PORTA                         
.................... #define DEFVALA   0x03     //0x06   Default Value Register for PORTA 
.................... #define INTCONA   0x04     //0x08   Interrupt-on-change control Register for PORTA                           
.................... #define IOCON      0x05     //0x0A   Configuration register for device                       
.................... #define GPPUA      0x06     //0x0C   100kOhm pullup resistor register for PORTA (sets pin to input when set)                            
.................... #define INTFA      0x07     //0x0E   Interrupt flag Register for PORTA                              
.................... #define INTCAPA   0x08     //0x10   Interrupt captured value Register for PORTA                   
.................... #define GPIOA      0x09     //0x12   General purpose I/O Register for PORTA                             
.................... #define OLATA      0x0A     //0x14   Output latch Register for PORTA 
....................  
.................... #define IODIRB    0x10     //0x01   Data Direction Register for PORTB 
.................... #define IPOLB     0x11     //0x03   Input Polarity Register for PORTB 
.................... #define GPINTENB    0x12     //0x05     Interrupt-on-change enable Register for PORTB 
.................... #define DEFVALB   0x13     //0x07   Default Value Register for PORTB 
.................... #define INTCONB   0x14     //0x09   Interrupt-on-change control Register for PORTB 
.................... //#define IOCON      0x15     //0x0B   //IOCON has 2 different addresses, both write to same register                               
.................... #define GPPUB      0x16     //0x0D   100kOhm pullup resistor register for PORTB (sets pin to input when set) 
.................... #define INTFB      0x17     //0x0F   Interrupt flag Register for PORTB  
.................... #define INTCAPB   0x18     //0x11   Interrupt captured value Register for PORTB 
.................... #define GPIOB      0x19     //0x13   General purpose I/O Register for PORTB 
.................... #define OLATB      0x1A     //0x15   Output latch Register for PORTB 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Pin Defines 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Use in the Pin field. 
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #define IO_PIN_A0      0x80 
.................... #define IO_PIN_A1      0x81 
.................... #define IO_PIN_A2      0x82 
.................... #define IO_PIN_A3      0x83 
.................... #define IO_PIN_A4      0x84 
.................... #define IO_PIN_A5      0x85 
.................... #define IO_PIN_A6      0x86 
.................... #define IO_PIN_A7      0x87 
....................  
.................... #define IO_PIN_B0      0x00 
.................... #define IO_PIN_B1      0x01 
.................... #define IO_PIN_B2      0x02 
.................... #define IO_PIN_B3      0x03 
.................... #define IO_PIN_B4      0x04 
.................... #define IO_PIN_B5      0x05 
.................... #define IO_PIN_B6      0x06 
.................... #define IO_PIN_B7      0x07 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IOCON Bits 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// OR wanted options together when setting the IOCON register. 
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #define IO_IOCON_BANK      0x80   //Sets register addresses. Initialized to 1.                             
.................... #define IO_IOCON_MIRROR      0x40   //Internally connect interrupt PINs.  
.................... #define IO_IOCON_SEQOP      0x20   //Sets ~Sequential/Byte mode. Driver only uses byte mode. 
.................... #define IO_IOCON_DISSLW      0x10    //Enables slew rate for SDA output                              
.................... #define IO_IOCON_HAEN      0x08   //Enables hardware address pins. If 0 only one device can be used. 
.................... #define IO_IOCON_ODR       0x04   //Open drain/~active drive interrupt pin outputs 
.................... #define IO_IOCON_INTPOL      0x02   //Sets INT output as active high/~low 
....................  
.................... /****************************************************************************** 
.................... **** FUNCTION PROTOTYPES 
.................... ******************************************************************************/ 
....................  
.................... void IO_INIT();   //don't need multiple inits because all devices are assumed 0 before HAEN is set 
....................  
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... void IO_WRITE_REGISTER(int8 reg, int8 data); 
.................... int8 IO_READ_REGISTER(int8 reg); 
.................... void IO_OUTPUT_A(int8 data); 
.................... void IO_OUTPUT_B(int8 data); 
.................... int8 IO_INPUT_A(); 
.................... int8 IO_INPUT_B(); 
.................... void IO_OUTPUT_BIT(int8 pin, int1 state); 
.................... void IO_OUTPUT_HIGH(int8 pin); 
.................... void IO_OUTPUT_LOW(int8 pin); 
.................... void IO_OUTPUT_FLOAT(int8 pin); 
.................... void IO_OUTPUT_TOGGLE(int8 pin); 
.................... void IO_OUTPUT_DRIVE(int8 pin); 
.................... int1 IO_INPUT(int8 pin); 
.................... int1 IO_INPUT_STATE(int8 pin); 
.................... int8 IO_GET_TRIS_A(); 
.................... void IO_SET_TRIS_A(int8 data); 
.................... int8 IO_GET_TRIS_B(); 
.................... void IO_SET_TRIS_B(int8 data); 
.................... #else 
.................... void IO_WRITE_REGISTER(int8 address, int8 reg, int8 data); 
.................... int8 IO_READ_REGISTER(int8 address, int8 reg); 
.................... void IO_OUTPUT_A(int8 address, int8 data); 
.................... void IO_OUTPUT_B(int8 address, int8 data); 
.................... int8 IO_INPUT_A(int8 address); 
.................... int8 IO_INPUT_B(int8 address); 
.................... void IO_OUTPUT_BIT(int8 address, int8 pin, int1 state); 
.................... void IO_OUTPUT_HIGH(int8 address, int8 pin); 
.................... void IO_OUTPUT_LOW(int8 address, int8 pin); 
.................... void IO_OUTPUT_FLOAT(int8 address, int8 pin); 
.................... void IO_OUTPUT_TOGGLE(int8 address, int8 pin); 
.................... void IO_OUTPUT_DRIVE(int8 address, int8 pin); 
.................... int1 IO_INPUT(int8 address, int8 pin); 
.................... int1 IO_INPUT_STATE(int8 address, int8 pin); 
.................... int8 IO_GET_TRIS_A(int8 address); 
.................... void IO_SET_TRIS_A(int8 address, int8 data); 
.................... int8 IO_GET_TRIS_B(int8 address); 
.................... void IO_SET_TRIS_B(int8 address, int8 data); 
.................... #endif 
....................  
.................... /****************************************************************************** 
.................... **** FUNCTIONS 
.................... ******************************************************************************/ 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_INIT 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Must be called before anything else. Enables the MCP23S17 chip to have  
.................... //// the following settings: 
.................... ////      IO_IOCON_BANK    = 1    Sets addresses to align with the #defines 
.................... ////      IO_IOCON_MIRROR  = 0      INT pins are not internally connected 
.................... ////      IO_IOCON_SEQOP     = 1      Operating in Byte mode    
.................... ////      IO_IOCON_DISSLW  = 0      SDA output slew rate is enabled                              
.................... ////      IO_IOCON_HAEN     = x      A2, A1, A0 enabled only if IO_MULTIPLE_DEVICES is defined    
.................... ////      IO_IOCON_ODR      = 0      Interrupt will drive its level    
.................... ////      IO_IOCON_INTPOL  = 1      Interrupt is active-high 
.................... //// 
.................... //// If different settings are required, use an IO_WRITE_REGISTER() with IOCON 
.................... //// as the reg parameter. Note: if IO_IOCON_BANK is cleared then the #defines 
.................... //// for the register values are no longer valid. 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... void IO_INIT(){ 
....................  
....................    output_high(IO_CS_PIN); 
*
07D4:  BCF    F92.5
07D6:  BSF    F89.5
....................    output_drive(IO_CS_PIN); 
07D8:  BCF    F92.5
....................    #ifndef IO_MULTIPLE_DEVICES 
....................    IO_WRITE_REGISTER(0x0A, 0xA2);   //IOCON's address is 0xA until IOCON.Bank is set                          
....................    #else 
....................    IO_WRITE_REGISTER(IO_DEVICE_0, 0x0A, 0xAA); 
07DA:  MOVLB  8
07DC:  CLRF   x7A
07DE:  MOVLW  0A
07E0:  MOVWF  x7B
07E2:  MOVLW  AA
07E4:  MOVWF  x7C
07E6:  MOVLB  0
07E8:  RCALL  07A2
....................    IO_WRITE_REGISTER(IO_DEVICE_1, 0x0A, 0xAA);  //Edit by Jack 
07EA:  MOVLW  02
07EC:  MOVLB  8
07EE:  MOVWF  x7A
07F0:  MOVLW  0A
07F2:  MOVWF  x7B
07F4:  MOVLW  AA
07F6:  MOVWF  x7C
07F8:  MOVLB  0
07FA:  RCALL  07A2
....................    IO_WRITE_REGISTER(IO_DEVICE_2, 0x0A, 0xAA);  //Edit by Jack 
07FC:  MOVLW  04
07FE:  MOVLB  8
0800:  MOVWF  x7A
0802:  MOVLW  0A
0804:  MOVWF  x7B
0806:  MOVLW  AA
0808:  MOVWF  x7C
080A:  MOVLB  0
080C:  RCALL  07A2
....................    IO_WRITE_REGISTER(IO_DEVICE_3, 0x0A, 0xAA);  //Edit by Jack 
080E:  MOVLW  06
0810:  MOVLB  8
0812:  MOVWF  x7A
0814:  MOVLW  0A
0816:  MOVWF  x7B
0818:  MOVLW  AA
081A:  MOVWF  x7C
081C:  MOVLB  0
081E:  RCALL  07A2
....................    IO_WRITE_REGISTER(IO_DEVICE_4, 0x0A, 0xAA);  //Edit by Jack 
0820:  MOVLW  08
0822:  MOVLB  8
0824:  MOVWF  x7A
0826:  MOVLW  0A
0828:  MOVWF  x7B
082A:  MOVLW  AA
082C:  MOVWF  x7C
082E:  MOVLB  0
0830:  RCALL  07A2
....................    IO_WRITE_REGISTER(IO_DEVICE_5, 0x0A, 0xAA);  //Edit by Jack 
0832:  MOVLW  0A
0834:  MOVLB  8
0836:  MOVWF  x7A
0838:  MOVWF  x7B
083A:  MOVLW  AA
083C:  MOVWF  x7C
083E:  MOVLB  0
0840:  RCALL  07A2
....................    IO_WRITE_REGISTER(IO_DEVICE_6, 0x0A, 0xAA);  //Edit by Jack 
0842:  MOVLW  0C
0844:  MOVLB  8
0846:  MOVWF  x7A
0848:  MOVLW  0A
084A:  MOVWF  x7B
084C:  MOVLW  AA
084E:  MOVWF  x7C
0850:  MOVLB  0
0852:  RCALL  07A2
....................    IO_WRITE_REGISTER(IO_DEVICE_7, 0x0A, 0xAA);  //Edit by Jack 
0854:  MOVLW  0E
0856:  MOVLB  8
0858:  MOVWF  x7A
085A:  MOVLW  0A
085C:  MOVWF  x7B
085E:  MOVLW  AA
0860:  MOVWF  x7C
0862:  MOVLB  0
0864:  RCALL  07A2
....................    #endif 
.................... } 
0866:  GOTO   648A (RETURN)
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_WRITE_REGISTER 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Sets the value of the specified register. 
.................... //// 
.................... //// Parameters: 
.................... ////      reg - the register to be written. use provided defines. 
.................... ////      data - the data to be written. 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      void 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... void IO_WRITE_REGISTER(int8 reg, int8 data){ 
.................... #else 
.................... void IO_WRITE_REGISTER(int8 address, int8 reg, int8 data){ 
.................... #endif 
....................     
....................    output_low(IO_CS_PIN); 
*
07A2:  BCF    F92.5
07A4:  BCF    F89.5
....................     
....................    #ifndef IO_MULTIPLE_DEVICES 
....................    spi_write(IO_DEVICE_ADDRESS_WRITE); 
....................    #else 
....................    spi_write(IO_DEVICE_ADDRESS_WRITE | address); 
07A6:  MOVLB  8
07A8:  MOVF   x7A,W
07AA:  IORLW  40
07AC:  MOVWF  x7D
07AE:  MOVF   FC9,W
07B0:  MOVFF  87D,FC9
07B4:  RRCF   FC7,W
07B6:  BNC   07B4
....................    #endif 
....................     
....................    spi_write(reg); 
07B8:  MOVF   FC9,W
07BA:  MOVFF  87B,FC9
07BE:  RRCF   FC7,W
07C0:  BNC   07BE
....................    spi_write(data); 
07C2:  MOVF   FC9,W
07C4:  MOVFF  87C,FC9
07C8:  RRCF   FC7,W
07CA:  BNC   07C8
....................     
....................    output_high(IO_CS_PIN); 
07CC:  BCF    F92.5
07CE:  BSF    F89.5
....................  
.................... } 
07D0:  MOVLB  0
07D2:  RETLW  00
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_READ_REGISTER 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Gets the current value of the specified register. 
.................... //// 
.................... //// Parameters: 
.................... ////      reg - the register to be read. use provided defines. 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      int8 - the current value of the requested register 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... int8 IO_READ_REGISTER(int8 reg){ 
.................... #else 
.................... int8 IO_READ_REGISTER(int8 address, int8 reg){ 
.................... #endif 
....................    int8 retVal; 
....................  
....................    output_low(IO_CS_PIN); 
*
1468:  BCF    F92.5
146A:  BCF    F89.5
....................     
....................    #ifndef IO_MULTIPLE_DEVICES 
....................    spi_write(IO_DEVICE_ADDRESS_READ); 
....................    #else 
....................    spi_write(IO_DEVICE_ADDRESS_READ | address); 
146C:  MOVLB  8
146E:  MOVF   x7C,W
1470:  IORLW  41
1472:  MOVWF  x7F
1474:  MOVF   FC9,W
1476:  MOVFF  87F,FC9
147A:  RRCF   FC7,W
147C:  BNC   147A
....................    #endif 
....................     
....................    spi_write(reg); 
147E:  MOVF   FC9,W
1480:  MOVFF  87D,FC9
1484:  RRCF   FC7,W
1486:  BNC   1484
....................    retVal = spi_read(0); 
1488:  MOVF   FC9,W
148A:  CLRF   FC9
148C:  RRCF   FC7,W
148E:  BNC   148C
1490:  MOVFF  FC9,87E
....................     
....................    output_high(IO_CS_PIN); 
1494:  BCF    F92.5
1496:  BSF    F89.5
....................     
....................    return retVal; 
1498:  MOVFF  87E,01
....................  
.................... } 
149C:  MOVLB  0
149E:  RETLW  00
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_OUTPUT_A 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Sets the current output value of Port A. Does NOT change the PORT's  
.................... //// direction 
.................... //// 
.................... //// Parameters: 
.................... ////      data - the value to be written to Port A 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      void 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... void IO_OUTPUT_A(int8 data){ 
.................... #else 
.................... void IO_OUTPUT_A(int8 address, int8 data){ 
.................... #endif 
....................  
....................    #ifndef IO_MULTIPLE_DEVICES 
....................    IO_WRITE_REGISTER(OLATA, data); 
....................    #else 
....................    IO_WRITE_REGISTER(address, OLATA, data); 
*
1D22:  MOVFF  878,87A
1D26:  MOVLW  0A
1D28:  MOVLB  8
1D2A:  MOVWF  x7B
1D2C:  MOVFF  879,87C
1D30:  MOVLB  0
1D32:  CALL   07A2
....................    #endif 
....................  
.................... } 
1D36:  RETLW  00
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_OUTPUT_B 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Sets the current output value of Port B. Does NOT change the PORT's  
.................... //// direction 
.................... //// 
.................... //// Parameters: 
.................... ////      data - the value to be written to Port B 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      void 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... void IO_OUTPUT_B(int8 data){ 
.................... #else 
.................... void IO_OUTPUT_B(int8 address, int8 data){ 
.................... #endif 
....................  
....................    #ifndef IO_MULTIPLE_DEVICES 
....................    IO_WRITE_REGISTER(OLATB, data); 
....................    #else 
....................    IO_WRITE_REGISTER(address, OLATB, data); 
1D38:  MOVFF  878,87A
1D3C:  MOVLW  1A
1D3E:  MOVLB  8
1D40:  MOVWF  x7B
1D42:  MOVFF  879,87C
1D46:  MOVLB  0
1D48:  CALL   07A2
....................    #endif 
....................  
.................... } 
1D4C:  RETLW  00
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_INPUT_A 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Gets the current input value of Port A. Does NOT change the PORT's  
.................... //// direction 
.................... //// 
.................... //// Parameters: 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      int8 - PORTA's input value 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... int8 IO_INPUT_A(){ 
.................... #else 
.................... int8 IO_INPUT_A(int8 address){ 
.................... #endif 
....................  
....................    int8 retVal; 
....................     
....................    #ifndef IO_MULTIPLE_DEVICES 
....................    retVal = IO_READ_REGISTER(GPIOA); 
....................    #else 
....................    retVal = IO_READ_REGISTER(address, GPIOA); 
*
14A0:  MOVFF  87A,87C
14A4:  MOVLW  09
14A6:  MOVLB  8
14A8:  MOVWF  x7D
14AA:  MOVLB  0
14AC:  RCALL  1468
14AE:  MOVFF  01,87B
....................    #endif 
....................     
....................    return retVal; 
14B2:  MOVLB  8
14B4:  MOVFF  87B,01
....................  
.................... } 
14B8:  MOVLB  0
14BA:  GOTO   15C2 (RETURN)
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_INPUT_B 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Gets the current input value of Port B. Does NOT change the PORT's  
.................... //// direction 
.................... //// 
.................... //// Parameters: 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      int8 - PORTB's input value 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... int8 IO_INPUT_B(){ 
.................... #else 
.................... int8 IO_INPUT_B(int8 address){ 
.................... #endif 
....................  
....................    int8 retVal; 
....................     
....................    #ifndef IO_MULTIPLE_DEVICES 
....................    retVal = IO_READ_REGISTER(GPIOB); 
....................    #else 
....................    retVal = IO_READ_REGISTER(address, GPIOB); 
14BE:  MOVFF  87A,87C
14C2:  MOVLW  19
14C4:  MOVLB  8
14C6:  MOVWF  x7D
14C8:  MOVLB  0
14CA:  RCALL  1468
14CC:  MOVFF  01,87B
....................    #endif 
....................     
....................    return retVal; 
14D0:  MOVLB  8
14D2:  MOVFF  87B,01
....................  
.................... } 
14D6:  MOVLB  0
14D8:  GOTO   165E (RETURN)
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_OUTPUT_BIT 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Sets the specified PIN to the desired state. Does NOT change the PIN's  
.................... //// direction 
.................... //// 
.................... //// Parameters: 
.................... ////      pin - pin to be changed. use provided defines. 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      void 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... void IO_OUTPUT_BIT(int8 pin, int1 state){ 
.................... #else 
.................... void IO_OUTPUT_BIT(int8 address, int8 pin, int1 state){ 
.................... #endif 
....................     
....................    int8 tempReg; 
....................     
....................    if(bit_test(pin, 7)){ //PIN A 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_READ_REGISTER(OLATA); 
....................       #else 
....................       tempReg = IO_READ_REGISTER(address, OLATA); 
....................       #endif 
....................       if(state){    //set high                       
....................          bit_set(tempReg, pin &0x0F);      
....................       }else{        //set low                       
....................          bit_clear(tempReg, pin &0x0F); 
....................       } 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       IO_WRITE_REGISTER(OLATA, tempReg); 
....................       #else 
....................       IO_WRITE_REGISTER(address, OLATA, tempReg); 
....................       #endif 
....................    }else{    //PIN B    
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_READ_REGISTER(OLATB); 
....................       #else 
....................       tempReg = IO_READ_REGISTER(address, OLATB); 
....................       #endif 
....................       if(state){    //set high                       
....................          bit_set(tempReg, pin);       
....................       }else{        //set low                       
....................          bit_clear(tempReg, pin); 
....................       } 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       IO_WRITE_REGISTER(OLATB, tempReg); 
....................       #else 
....................       IO_WRITE_REGISTER(address, OLATB, tempReg); 
....................       #endif 
....................    } 
....................  
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_OUTPUT_HIGH 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Sets the specified PIN to output high. Does NOT change the PIN's direction 
.................... //// 
.................... //// Parameters: 
.................... ////      pin - pin to be set. use provided defines. 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      void 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... void IO_OUTPUT_HIGH(int8 pin){ 
.................... #else 
.................... void IO_OUTPUT_HIGH(int8 address, int8 pin){ 
.................... #endif 
....................  
....................    int8 tempReg; 
....................     
....................    if(bit_test(pin, 7)){ //PIN A 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_READ_REGISTER(OLATA); 
....................       #else 
....................       tempReg = IO_READ_REGISTER(address, OLATA); 
....................       #endif 
....................       bit_set(tempReg, pin &0x0F);  
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       IO_WRITE_REGISTER(OLATA, tempReg); 
....................       #else 
....................       IO_WRITE_REGISTER(address, OLATA, tempReg); 
....................       #endif 
....................    }else{    //PIN B    
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_READ_REGISTER(OLATB); 
....................       #else 
....................       tempReg = IO_READ_REGISTER(address, OLATB); 
....................       #endif 
....................       bit_set(tempReg, pin);  
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       IO_WRITE_REGISTER(OLATB, tempReg); 
....................       #else 
....................       IO_WRITE_REGISTER(address, OLATB, tempReg); 
....................       #endif 
....................    } 
....................  
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_OUTPUT_LOW 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Sets the specified PIN to output low. Does NOT change the PIN's direction 
.................... //// 
.................... //// Parameters: 
.................... ////      pin - pin to be cleared. use provided defines. 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      void 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... void IO_OUTPUT_LOW(int8 pin){ 
.................... #else 
.................... void IO_OUTPUT_LOW(int8 address, int8 pin){ 
.................... #endif 
....................  
....................    int8 tempReg; 
....................     
....................    if(bit_test(pin, 7)){ //PIN A 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_READ_REGISTER(OLATA); 
....................       #else 
....................       tempReg = IO_READ_REGISTER(address, OLATA); 
....................       #endif 
....................       bit_clear(tempReg, pin &0x0F); 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       IO_WRITE_REGISTER(OLATA, tempReg); 
....................       #else 
....................       IO_WRITE_REGISTER(address, OLATA, tempReg); 
....................       #endif 
....................    }else{    //PIN B    
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_READ_REGISTER(OLATB); 
....................       #else 
....................       tempReg = IO_READ_REGISTER(address, OLATB); 
....................       #endif 
....................       bit_clear(tempReg, pin); 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       IO_WRITE_REGISTER(OLATB, tempReg); 
....................       #else 
....................       IO_WRITE_REGISTER(address, OLATB, tempReg); 
....................       #endif 
....................    } 
....................  
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_OUTPUT_FLOAT 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Sets the specified PIN to an input. 
.................... //// 
.................... //// Parameters: 
.................... ////      pin - pin to be changed. use provided defines. 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      void 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... void IO_OUTPUT_FLOAT(int8 pin){ 
.................... #else 
.................... void IO_OUTPUT_FLOAT(int8 address, int8 pin){ 
.................... #endif 
....................  
....................    int8 tempReg; 
....................     
....................    if(bit_test(pin, 7)){ //PIN A 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_GET_TRIS_A(); 
....................       #else 
....................       tempReg = IO_GET_TRIS_A(address); 
....................       #endif 
....................       bit_set(tempReg, pin &0x0F);  
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       IO_SET_TRIS_A(tempReg); 
....................       #else 
....................       IO_SET_TRIS_A(address, tempReg); 
....................       #endif 
....................    }else{    //PIN B    
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_GET_TRIS_B(); 
....................       #else 
....................       tempReg = IO_GET_TRIS_B(address); 
....................       #endif 
....................       bit_set(tempReg, pin);       
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       IO_SET_TRIS_B(tempReg); 
....................       #else 
....................       IO_SET_TRIS_B(address, tempReg); 
....................       #endif 
....................    } 
....................  
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_OUTPUT_TOGGLE 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Toggles the specified PIN's output. 
.................... //// 
.................... //// Parameters: 
.................... ////      pin - pin to be toggled. use provided defines. 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      void 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... void IO_OUTPUT_TOGGLE(int8 pin){ 
.................... #else 
.................... void IO_OUTPUT_TOGGLE(int8 address, int8 pin){ 
.................... #endif 
....................  
....................    int8 tempReg; 
....................     
....................    if(bit_test(pin, 7)){ //PIN A 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_READ_REGISTER(OLATA); 
....................       #else 
....................       tempReg = IO_READ_REGISTER(address, OLATA); 
....................       #endif 
....................       tempReg ^= (1<< (pin&0x0F)); 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       IO_WRITE_REGISTER(OLATA, tempReg); 
....................       #else 
....................       IO_WRITE_REGISTER(address, OLATA, tempReg); 
....................       #endif 
....................    }else{    //PIN B    
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_READ_REGISTER(OLATB); 
....................       #else 
....................       tempReg = IO_READ_REGISTER(address, OLATB); 
....................       #endif 
....................       tempReg ^= (1<< (pin&0x0F)); 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       IO_WRITE_REGISTER(OLATB, tempReg); 
....................       #else 
....................       IO_WRITE_REGISTER(address, OLATB, tempReg); 
....................       #endif 
....................    } 
....................  
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_OUTPUT_DRIVE 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Sets the specified PIN to an output. 
.................... //// 
.................... //// Parameters: 
.................... ////      pin - pin to be changed. use provided defines. 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      void 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... void IO_OUTPUT_DRIVE(int8 pin){ 
.................... #else 
.................... void IO_OUTPUT_DRIVE(int8 address, int8 pin){ 
.................... #endif 
....................  
....................    int8 tempReg; 
....................     
....................    if(bit_test(pin, 7)){ //PIN A 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_GET_TRIS_A(); 
....................       #else 
....................       tempReg = IO_GET_TRIS_A(address); 
....................       #endif 
....................       bit_clear(tempReg, pin &0x0F); 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       IO_SET_TRIS_A(tempReg); 
....................       #else 
....................       IO_SET_TRIS_A(address, tempReg); 
....................       #endif 
....................    }else{    //PIN B    
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_GET_TRIS_B(); 
....................       #else 
....................       tempReg = IO_GET_TRIS_B(address); 
....................       #endif 
....................       bit_clear(tempReg, pin);       
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       IO_SET_TRIS_B(tempReg); 
....................       #else 
....................       IO_SET_TRIS_B(address, tempReg); 
....................       #endif 
....................    } 
....................  
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_INPUT 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Gets the specified PIN's current input. Changes the PIN's direction to an 
.................... //// input. 
.................... //// 
.................... //// Parameters: 
.................... ////      pin - pin to be read. use provided defines. 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      int1 - the state of the pin 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... int1 IO_INPUT(int8 pin){ 
.................... #else 
.................... int1 IO_INPUT(int8 address, int8 pin){ 
.................... #endif 
....................    int1 retVal; 
....................    int8 tempReg; 
....................     
....................    #ifndef IO_MULTIPLE_DEVICES 
....................    IO_OUTPUT_FLOAT(pin); 
....................    #else 
....................    IO_OUTPUT_FLOAT(address, pin); 
....................    #endif 
....................     
....................    if(bit_test(pin, 7)){ 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_READ_REGISTER(GPIOA); 
....................       #else 
....................       tempReg = IO_READ_REGISTER(address, GPIOA); 
....................       #endif 
....................    }else{ 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_READ_REGISTER(GPIOB); 
....................       #else 
....................       tempReg = IO_READ_REGISTER(address, GPIOB); 
....................       #endif 
....................    } 
....................    retVal = bit_test(tempReg, pin&0x0F); 
....................     
....................    return retVal; 
....................  
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_INPUT_STATE 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Gets the specified PIN's current input. Does NOT change the PIN's direction 
.................... //// 
.................... //// Parameters: 
.................... ////      pin - pin to be read. use provided defines. 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      int1 - the state of the pin 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... int1 IO_INPUT_STATE(int8 pin){ 
.................... #else 
.................... int1 IO_INPUT_STATE(int8 address, int8 pin){ 
.................... #endif 
....................    int1 retVal; 
....................    int8 tempReg; 
....................     
....................    if(bit_test(pin, 7)){ 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_READ_REGISTER(GPIOA); 
....................       #else 
....................       tempReg = IO_READ_REGISTER(address, GPIOA); 
....................       #endif 
....................    }else{ 
....................       #ifndef IO_MULTIPLE_DEVICES 
....................       tempReg = IO_READ_REGISTER(GPIOB); 
....................       #else 
....................       tempReg = IO_READ_REGISTER(address, GPIOB); 
....................       #endif 
....................    } 
....................    retVal = bit_test(tempReg, pin&0x0F); 
....................     
....................    return retVal; 
....................  
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_GET_TRIS_A 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Gets the device's port A data direction register. 
.................... //// 
.................... //// Parameters: 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      The device's IODIRB register value 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... int8 IO_GET_TRIS_A(){ 
.................... #else 
.................... int8 IO_GET_TRIS_A(int8 address){ 
.................... #endif 
....................  
....................    int8 retVal; 
....................     
....................    #ifndef IO_MULTIPLE_DEVICES 
....................    retVal = IO_READ_REGISTER(IODIRA); 
....................    #else 
....................    retVal = IO_READ_REGISTER(address, IODIRA); 
....................    #endif 
....................     
....................    return retVal; 
....................  
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_SET_TRIS_A 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Sets the device's port A data direction register to the specified value. 
.................... //// 
.................... //// Parameters: 
.................... ////      data - value to be written to the register 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      void 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... void IO_SET_TRIS_A(int8 data){ 
.................... #else 
.................... void IO_SET_TRIS_A(int8 address, int8 data){ 
.................... #endif 
....................     
....................    #ifndef IO_MULTIPLE_DEVICES 
....................    IO_WRITE_REGISTER(IODIRA, data); 
....................    #else 
....................    IO_WRITE_REGISTER(address, IODIRA, data); 
*
086A:  MOVFF  870,87A
086E:  MOVLB  8
0870:  CLRF   x7B
0872:  MOVFF  871,87C
0876:  MOVLB  0
0878:  RCALL  07A2
....................    #endif 
....................  
.................... } 
087A:  RETLW  00
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_GET_TRIS_B 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Gets the device's port B data direction register. 
.................... //// 
.................... //// Parameters: 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      The device's IODIRB register value 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... int8 IO_GET_TRIS_B(){ 
.................... #else 
.................... int8 IO_GET_TRIS_B(int8 address){ 
.................... #endif 
....................  
....................    int8 retVal; 
....................     
....................    #ifndef IO_MULTIPLE_DEVICES 
....................    retVal = IO_READ_REGISTER(IODIRB); 
....................    #else 
....................    retVal = IO_READ_REGISTER(address, IODIRB); 
....................    #endif 
....................     
....................    return retVal; 
....................  
.................... } 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// IO_SET_TRIS_B 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //// Sets the device's port B data direction register to the specified value. 
.................... //// 
.................... //// Parameters: 
.................... ////      data - value to be written to the register 
.................... ////     address - address of the device. use provided defines. 
.................... //// 
.................... //// Returns: 
.................... ////      void 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... #ifndef IO_MULTIPLE_DEVICES 
.................... void IO_SET_TRIS_B(int8 data){ 
.................... #else 
.................... void IO_SET_TRIS_B(int8 address, int8 data){ 
.................... #endif 
....................  
....................    #ifndef IO_MULTIPLE_DEVICES 
....................    IO_WRITE_REGISTER(IODIRB, data); 
....................    #else 
....................    IO_WRITE_REGISTER(address, IODIRB, data); 
087C:  MOVFF  870,87A
0880:  MOVLW  10
0882:  MOVLB  8
0884:  MOVWF  x7B
0886:  MOVFF  871,87C
088A:  MOVLB  0
088C:  RCALL  07A2
....................    #endif 
....................  
.................... } 
088E:  RETLW  00
....................  
.................... #endif 
....................  
....................  
.................... #define Pled        PIN_B5 
.................... #define I2C_SDA     PIN_C4 
.................... #define I2C_SCL     PIN_C3 
....................  
.................... #define Pack        PIN_C0 
.................... #define Preset      PIN_C1 
.................... #define Ptest       PIN_C2 
....................  
.................... #define Pbell       PIN_A3 
.................... #define Pbuzzer     PIN_A4 
....................  
.................... #define P485ctrl    PIN_B3       // ---jj 
.................... #define PTxD        PIN_C6 
.................... #define PRxD        PIN_C7 
....................  
.................... //#define PsyncR      PIN_B3 
.................... //#define PsyncS      PIN_B4 
....................  
.................... #define EXP_OUT_ENABLE  PIN_B0 
.................... #define EXP_OUT_CLOCK   PIN_B1 
.................... #define EXP_OUT_DO      PIN_B2 
....................  
.................... #define Red       0 
.................... #define Green     1 
.................... #define Ambian    2 
....................  
.................... //#define NUMBER_OF_595 8 
....................  
.................... #use rs232(baud=9600,parity=N,xmit=PTxD,rcv=PRxD,bits=8,restart_wdt) 
*
1F4C:  CLRWDT
1F4E:  BTFSS  F9E.4
1F50:  BRA    1F4C
1F52:  MOVWF  FAD
1F54:  RETLW  00
....................  
.................... //#USE SPI (  FORCE_HW, BITS=16, ENABLE=IO_CS_PIN, SAMPLE_RISE, stream=SPI_STREAM)  
.................... //#USE SPI (  FORCE_HW, BITS=16, ENABLE=IO_CS_PIN, SAMPLE_RISE, stream=SPI_STREAM2) 
....................  
.................... //#use spi(MASTER, MODE=0, SPI1, FORCE_HW) 
.................... //#use spi(MASTER, MSB_FIRST, BITS=8, MODE=0, BAUD=100000) 
.................... //#use spi(DI=PIN_B1, DO=PIN_B0, CLK=PIN_B2, ENABLE=PIN_B4, BITS=8) 
....................  
.................... void check_ack(void); 
.................... void check_test(void); 
.................... void check_reset(void); 
.................... int1 CheckAutoReset(unsigned char DatType); 
.................... void Read_Config(void); 
.................... void ForceAllAlarm(void); 
.................... void Read_input(void); 
....................  
.................... int8 StatusTime = 0;         //Hearth beat LED Timer 
.................... int1 HearthbeatInd = 0;      //Hearth beat Indicator 
.................... int8 FlashingRateTime = 25; 
.................... int1 FlashingFlag = 0; 
.................... int8 TimeBase1s = 100; 
.................... int8 AutoAckDelayTime = 0; 
....................  
.................... int8 Input1_8_Send; 
.................... int8 Input9_16_Send; 
.................... int8 Input17_24_Send; 
.................... int8 Input25_32_Send; 
.................... int8 Input33_40_Send; 
.................... int8 Input41_48_Send; 
.................... int8 Input49_56_Send; 
.................... int8 Input57_64_Send; 
....................  
.................... int8 Ack1_8_Send; 
.................... int8 Ack9_16_Send; 
.................... int8 Ack17_24_Send; 
.................... int8 Ack25_32_Send; 
.................... int8 Ack33_40_Send; 
.................... int8 Ack41_48_Send; 
.................... int8 Ack49_56_Send; 
.................... int8 Ack57_64_Send; 
....................  
.................... int1 AutoAckFlag = 0; 
.................... int1 AutoResetFlag = 0; 
.................... int1 AutoTestFlag = 0; 
....................  
.................... int8 SBUF = 0x00; 
....................  
.................... int1 Test_fault = 0; 
.................... int8 T_test = 0x00; 
....................  
.................... int1 Test = 0; 
.................... int1 Ack_F = 0; 
.................... int1 Reset_F = 0; 
....................  
.................... volatile int1 functointest_f = 0; 
....................  
.................... int1 SyncStatus = 0;   //"0" -> No Sync signal 
.................... int1 SyncFlag = 0;     //use for debounce sync signal 
.................... int8 Synctimer = 0x00; //use for debounce sync signal 
....................  
.................... int8 Output1_8; 
.................... int8 Output9_16; 
....................  
.................... int8 Output595[4]; 
....................  
.................... int8 tempdata; 
....................  
.................... int8 EEpDat; 
....................  
.................... ///////// Data from EEProm /////// 
.................... //int Device_Addr; 
....................  
.................... int8 InputType1_8; 
.................... int8 InputType9_16; 
.................... int8 InputType17_24; 
....................  
.................... int8 FaultType1_8; 
.................... int8 FaultType9_16; 
.................... int8 FaultType17_24; 
....................  
....................  
.................... int8 OutputType1_8; 
.................... int8 OutputType9_16; 
.................... int8 OutputType17_24; 
....................  
.................... int8 OutputBoth1_8; 
.................... int8 OutputBoth9_16; 
.................... int8 OutputBoth17_24; 
....................  
.................... int8 Alarm_Indicator1_8; 
.................... int8 Alarm_Indicator9_16; 
.................... int8 Alarm_Indicator17_24; 
....................  
.................... int8 Input1_8; 
.................... int8 Input9_16; 
....................  
.................... int8 Input9_10; 
.................... int8 Input11_18; 
.................... int8 Input19_20; 
....................  
.................... int8 Red1_7; 
.................... int8 Red8_8; 
.................... int8 Red9_15; 
.................... int8 Red16_16; 
....................  
.................... int8 Green1_7; 
.................... int8 Green8_8; 
.................... int8 Green9_15; 
.................... int8 Green16_16; 
....................  
.................... int8 Red1_8; 
.................... int8 Red9_16; 
....................  
.................... int8 Red9_10 ; 
.................... int8 Red11_18 ; 
.................... int8 Red19_20 ; 
....................  
.................... int8 Green1_8 ; 
.................... int8 Green9_16 ; 
....................  
.................... int8 Green9_10 ; 
.................... int8 Green11_18 ; 
.................... int8 Green19_20 ; 
....................  
.................... int8 OUTRed1_8; 
.................... int8 OUTRed9_16 ; 
....................  
.................... int8 OUTRed9_10 ; 
.................... int8 OUTRed11_18 ; 
.................... int8 OUTRed19_20 ; 
....................  
.................... int8 OUTGreen1_8 ; 
.................... int8 OUTGreen9_16 ; 
....................  
.................... int8 OUTGreen9_10 ; 
.................... int8 OUTGreen11_18 ; 
.................... int8 OUTGreen19_20 ; 
....................  
.................... int8 AutoAck; 
.................... int8 AutoAckTime; 
.................... int8 FlashingRate; 
.................... int8 NoOfPoint; 
.................... int8 MasterSlaveSync; 
....................  
.................... volatile int1 RefreshConfigData =0; 
....................  
.................... //////////////////////////////// 
.................... ///////// tempolary register ////////// 
.................... //int8 temp; 
.................... //int1 RxDreceive = 0; 
....................  
.................... ////////////////////////////////////// 
.................... unsigned char const addr_sq = 0x10,end_sq = 0x11,code_sq = 0x12,start_addr_hi_sq = 0x13,start_addr_lo_sq = 0x14;         //serial sequnce 
.................... unsigned char const ubyte_hi_sq = 0x15,ubyte_lo_sq = 0x16,crc_hi_sq = 0x17,byte_count_sq = 0x19,data_sq = 0x20;      //serial sequnce 
....................  
.................... int1 recieve_completed = 0; 
.................... unsigned char sequence;         //keep sequence use for RxD 
.................... unsigned char Address; 
.................... unsigned char RxD_DataLen = 0x00; 
.................... unsigned char TxD_Buff[255]; 
.................... unsigned char RxD_Buff[1024]; 
.................... unsigned char CRC_Lo; 
.................... unsigned char CRC_Hi; 
.................... int16 Send_check_Time = 500; //if no send reset buffer every 5 second 
....................  
.................... int16 Start_Address = 0x0000; 
.................... int16 No_PointCount = 0x0000; 
.................... unsigned char Data_ByteCount = 0x00; 
.................... unsigned char Data_Buff[255]; 
.................... //unsigned char DataTemp; 
.................... //unsigned char TxD_DataLen; 
....................  
.................... int8 MCP23s17_Ip_dat; 
....................  
.................... int8 MCP23s17_Op_dat; 
....................  
.................... unsigned char T_timeout;   //use for calculate RxD timeout 
.................... unsigned char index = 0x00;         //use for Loop 
....................  
.................... int8 outmcp23 = 0; 
....................  
.................... unsigned char sms_phonenumber[15]; 
....................  
.................... //unsigned char SMS_Massage[20][20]; 
....................  
.................... unsigned char SMS_Massage1[41]; 
.................... unsigned char SMS_Massage2[41]; 
.................... unsigned char SMS_Massage3[41]; 
.................... unsigned char SMS_Massage4[41]; 
.................... unsigned char SMS_Massage5[41]; 
.................... unsigned char SMS_Massage6[41]; 
.................... unsigned char SMS_Massage7[41]; 
.................... unsigned char SMS_Massage8[41]; 
....................  
.................... unsigned char const CRC_Table_Hi[] = { 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,  
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
.................... 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01,  
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40 
.................... } ;  
....................  
.................... unsigned  char const CRC_Table_Lo[] = { 
.................... 0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4, 
.................... 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 
.................... 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 
.................... 0x1D, 0x1C, 0xDC, 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3, 
.................... 0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7, 
.................... 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 
.................... 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 
.................... 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,  
.................... 0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2, 
.................... 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F,  
.................... 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 
.................... 0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,  
.................... 0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0, 0x50, 0x90, 0x91, 
.................... 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 
.................... 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 
.................... 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C, 
.................... 0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 
.................... 0x40 
.................... } ; 
....................  
.................... ///////////// Define Bit register //////////////////////////// 
....................  
.................... struct Bit64    // Input 
.................... { 
....................    int1 B1,B2,B3,B4,B5,B6,B7,B8; 
....................  
.................... }; 
....................  
....................  
.................... struct Bit64 Input,Output,InputType,FaultType,OutputType,OutputBoth; 
.................... struct Bit64 AlarmIndicator,Ack,In,In2; 
.................... struct Bit64 LED_Colour,AckSend,RED_Colour,GREEN_Colour; 
.................... struct Bit64 SendSMS; 
....................  
.................... int1 FaultAgo[30]; 
.................... int1 FaultNow[30]; 
.................... int16 ReleaseTime[30]; 
.................... int16 FaultDelayTime[30]; 
....................  
.................... int1 FaultNCNO[17]; 
.................... #define NO 1 
.................... #define NC 0 
....................  
.................... //////////////////////////////--Function--///////////////////////////////////////////////// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ///////////////////////////////MODBUS Routine////////////////////////////////// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void StoreReleaseFault() 
.................... { 
*
1572:  MOVLB  8
1574:  CLRF   x7A
....................    Signed int8 i=0; 
....................    for(i=1;i<=16;i++) 
1576:  MOVLW  01
1578:  MOVWF  x7A
157A:  BTFSC  x7A.7
157C:  BRA    1584
157E:  MOVF   x7A,W
1580:  SUBLW  10
1582:  BNC   15B2
....................    { 
....................       FaultAgo[i] = FaultNow[i]; 
1584:  CLRF   x7C
1586:  CLRF   x7C
1588:  MOVFF  87A,87B
158C:  MOVLW  07
158E:  MOVWF  x7D
1590:  MOVLW  ED
1592:  MOVWF  x7C
1594:  MOVLB  0
1596:  RCALL  14DC
1598:  MOVLB  8
159A:  CLRF   x7C
159C:  BTFSC  01.0
159E:  INCF   x7C,F
15A0:  MOVLW  07
15A2:  MOVWF  x7E
15A4:  MOVLW  E9
15A6:  MOVWF  x7D
15A8:  MOVLB  0
15AA:  RCALL  1530
....................    } 
15AC:  MOVLB  8
15AE:  INCF   x7A,F
15B0:  BRA    157A
.................... } 
15B2:  MOVLB  0
15B4:  GOTO   1BB4 (RETURN)
....................  
.................... void CRC(unsigned char *puchMsg , unsigned char usDataLen) 
.................... {  
....................    unsigned char uIndex ;                   /* fill index into CRC lookup table */ 
....................    unsigned char i ; 
....................  
....................    CRC_Hi = 0xFF ;                      /* high byte of CRC initialized */ 
*
1F56:  MOVLW  FF
1F58:  MOVLB  5
1F5A:  MOVWF  x77
....................    CRC_Lo = 0xFF ;                      /* low byte of CRC initialized */ 
1F5C:  MOVWF  x76
....................  
....................    for(i = 0;i < usDataLen;i++) 
1F5E:  MOVLB  8
1F60:  CLRF   x7E
1F62:  MOVF   x7C,W
1F64:  SUBWF  x7E,W
1F66:  BC    1FC2
....................    { 
....................       restart_wdt(); 
1F68:  CLRWDT
....................       uIndex = CRC_Hi ^ (unsigned char) puchMsg[i] ; 
1F6A:  CLRF   03
1F6C:  MOVF   x7E,W
1F6E:  ADDWF  x7A,W
1F70:  MOVWF  FE9
1F72:  MOVF   x7B,W
1F74:  ADDWFC 03,W
1F76:  MOVWF  FEA
1F78:  MOVF   FEF,W
1F7A:  MOVLB  5
1F7C:  XORWF  x77,W
1F7E:  MOVLB  8
1F80:  MOVWF  x7D
....................       CRC_Hi = CRC_Lo ^ CRC_Table_Hi[uIndex] ; 
1F82:  CLRF   03
1F84:  MOVF   x7D,W
1F86:  MOVFF  FF2,87F
1F8A:  BCF    FF2.7
1F8C:  MOVLB  0
1F8E:  CALL   00A2
1F92:  MOVLB  8
1F94:  BTFSC  x7F.7
1F96:  BSF    FF2.7
1F98:  MOVWF  01
1F9A:  MOVLB  5
1F9C:  MOVF   x76,W
1F9E:  XORWF  01,W
1FA0:  MOVWF  x77
....................       CRC_Lo = CRC_Table_Lo[uIndex] ; 
1FA2:  CLRF   03
1FA4:  MOVLB  8
1FA6:  MOVF   x7D,W
1FA8:  MOVFF  FF2,87F
1FAC:  BCF    FF2.7
1FAE:  MOVLB  0
1FB0:  CALL   01BC
1FB4:  MOVLB  8
1FB6:  BTFSC  x7F.7
1FB8:  BSF    FF2.7
1FBA:  MOVFF  FE8,576
....................    } 
1FBE:  INCF   x7E,F
1FC0:  BRA    1F62
.................... } 
1FC2:  MOVLB  0
1FC4:  RETLW  00
....................  
.................... /********************************6B595 Driver*********************************/ 
.................... void Driver595() 
.................... { 
*
62A4:  MOVLB  8
62A6:  CLRF   x70
....................    Signed int8 j=0; 
....................    int8 data_out ; 
....................  
....................    restart_wdt(); 
62A8:  CLRWDT
....................      
....................     data_out = (~Input19_20); 
62AA:  MOVFF  4A,871
62AE:  COMF   x71,F
....................     for(j=7;j>=0;j--) 
62B0:  MOVLW  07
62B2:  MOVWF  x70
62B4:  BTFSC  x70.7
62B6:  BRA    62E8
....................     { 
....................      output_bit(EXP_OUT_DO,bit_test(data_out,j)); 
62B8:  MOVFF  871,00
62BC:  MOVF   x70,W
62BE:  MOVWF  01
62C0:  BZ    62CA
62C2:  BCF    FD8.0
62C4:  RRCF   00,F
62C6:  DECFSZ 01,F
62C8:  BRA    62C2
62CA:  BTFSC  00.0
62CC:  BRA    62D2
62CE:  BCF    F8A.2
62D0:  BRA    62D4
62D2:  BSF    F8A.2
62D4:  BCF    F93.2
....................      output_high(EXP_OUT_CLOCK); 
62D6:  BCF    F93.1
62D8:  BSF    F8A.1
....................      delay_us(1); 
62DA:  CLRWDT
62DC:  BRA    62DE
62DE:  BRA    62E0
....................      output_low(EXP_OUT_CLOCK); 
62E0:  BCF    F93.1
62E2:  BCF    F8A.1
....................     }     
62E4:  DECF   x70,F
62E6:  BRA    62B4
....................     data_out = (~Input11_18); 
62E8:  MOVFF  49,871
62EC:  COMF   x71,F
....................     for(j=7;j>=0;j--) 
62EE:  MOVLW  07
62F0:  MOVWF  x70
62F2:  BTFSC  x70.7
62F4:  BRA    6326
....................     { 
....................      output_bit(EXP_OUT_DO,bit_test(data_out,j)); 
62F6:  MOVFF  871,00
62FA:  MOVF   x70,W
62FC:  MOVWF  01
62FE:  BZ    6308
6300:  BCF    FD8.0
6302:  RRCF   00,F
6304:  DECFSZ 01,F
6306:  BRA    6300
6308:  BTFSC  00.0
630A:  BRA    6310
630C:  BCF    F8A.2
630E:  BRA    6312
6310:  BSF    F8A.2
6312:  BCF    F93.2
....................      output_high(EXP_OUT_CLOCK); 
6314:  BCF    F93.1
6316:  BSF    F8A.1
....................      delay_us(1); 
6318:  CLRWDT
631A:  BRA    631C
631C:  BRA    631E
....................      output_low(EXP_OUT_CLOCK); 
631E:  BCF    F93.1
6320:  BCF    F8A.1
....................     } 
6322:  DECF   x70,F
6324:  BRA    62F2
....................      
....................     data_out = (~Input9_10); 
6326:  MOVFF  48,871
632A:  COMF   x71,F
....................     for(j=7;j>=0;j--) 
632C:  MOVLW  07
632E:  MOVWF  x70
6330:  BTFSC  x70.7
6332:  BRA    6364
....................     { 
....................      output_bit(EXP_OUT_DO,bit_test(data_out,j)); 
6334:  MOVFF  871,00
6338:  MOVF   x70,W
633A:  MOVWF  01
633C:  BZ    6346
633E:  BCF    FD8.0
6340:  RRCF   00,F
6342:  DECFSZ 01,F
6344:  BRA    633E
6346:  BTFSC  00.0
6348:  BRA    634E
634A:  BCF    F8A.2
634C:  BRA    6350
634E:  BSF    F8A.2
6350:  BCF    F93.2
....................      output_high(EXP_OUT_CLOCK); 
6352:  BCF    F93.1
6354:  BSF    F8A.1
....................      delay_us(1); 
6356:  CLRWDT
6358:  BRA    635A
635A:  BRA    635C
....................      output_low(EXP_OUT_CLOCK); 
635C:  BCF    F93.1
635E:  BCF    F8A.1
....................     }     
6360:  DECF   x70,F
6362:  BRA    6330
....................     data_out = (~Input1_8); 
6364:  MOVFF  46,871
6368:  COMF   x71,F
....................     for(j=7;j>=0;j--) 
636A:  MOVLW  07
636C:  MOVWF  x70
636E:  BTFSC  x70.7
6370:  BRA    63A2
....................     { 
....................      output_bit(EXP_OUT_DO,bit_test(data_out,j)); 
6372:  MOVFF  871,00
6376:  MOVF   x70,W
6378:  MOVWF  01
637A:  BZ    6384
637C:  BCF    FD8.0
637E:  RRCF   00,F
6380:  DECFSZ 01,F
6382:  BRA    637C
6384:  BTFSC  00.0
6386:  BRA    638C
6388:  BCF    F8A.2
638A:  BRA    638E
638C:  BSF    F8A.2
638E:  BCF    F93.2
....................      output_high(EXP_OUT_CLOCK); 
6390:  BCF    F93.1
6392:  BSF    F8A.1
....................      delay_us(1); 
6394:  CLRWDT
6396:  BRA    6398
6398:  BRA    639A
....................      output_low(EXP_OUT_CLOCK); 
639A:  BCF    F93.1
639C:  BCF    F8A.1
....................     } 
639E:  DECF   x70,F
63A0:  BRA    636E
....................   
....................    output_high(EXP_OUT_ENABLE); 
63A2:  BCF    F93.0
63A4:  BSF    F8A.0
....................    delay_us(1); 
63A6:  CLRWDT
63A8:  BRA    63AA
63AA:  BRA    63AC
....................    output_low(EXP_OUT_ENABLE); 
63AC:  BCF    F93.0
63AE:  BCF    F8A.0
.................... } 
63B0:  MOVLB  0
63B2:  GOTO   6ADA (RETURN)
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void Alarmtosend(void) 
.................... { 
....................    Input1_8_Send = 0x00; 
*
1FC6:  CLRF   1B
....................     
....................    Ack1_8_Send = 0x00; 
1FC8:  CLRF   23
....................    
....................    ///////////////////////////////////////////////////// 
....................    
....................    if((In.B1 == 0) && (Output.B1 ==0)) 
1FCA:  MOVLB  7
1FCC:  BTFSC  xE2.0
1FCE:  BRA    1FD8
1FD0:  BTFSC  xDB.0
1FD2:  BRA    1FD8
....................       AckSend.B1 = 1; 
1FD4:  BSF    xE5.0
....................    else 
1FD6:  BRA    1FDA
....................       AckSend.B1 = 0; 
1FD8:  BCF    xE5.0
....................    if((In.B2 == 0) && (Output.B2 ==0)) 
1FDA:  BTFSC  xE2.1
1FDC:  BRA    1FE6
1FDE:  BTFSC  xDB.1
1FE0:  BRA    1FE6
....................       AckSend.B2 = 1; 
1FE2:  BSF    xE5.1
....................    else 
1FE4:  BRA    1FE8
....................       AckSend.B2 = 0; 
1FE6:  BCF    xE5.1
....................    if((In.B3 == 0) && (Output.B3 ==0)) 
1FE8:  BTFSC  xE2.2
1FEA:  BRA    1FF4
1FEC:  BTFSC  xDB.2
1FEE:  BRA    1FF4
....................       AckSend.B3 = 1; 
1FF0:  BSF    xE5.2
....................    else 
1FF2:  BRA    1FF6
....................       AckSend.B3 = 0; 
1FF4:  BCF    xE5.2
....................    if((In.B4 == 0) && (Output.B4 ==0)) 
1FF6:  BTFSC  xE2.3
1FF8:  BRA    2002
1FFA:  BTFSC  xDB.3
1FFC:  BRA    2002
....................       AckSend.B4 = 1; 
1FFE:  BSF    xE5.3
....................    else 
2000:  BRA    2004
....................       AckSend.B4 = 0; 
2002:  BCF    xE5.3
....................    if((In.B5 == 0) && (Output.B5 ==0)) 
2004:  BTFSC  xE2.4
2006:  BRA    2010
2008:  BTFSC  xDB.4
200A:  BRA    2010
....................       AckSend.B5 = 1; 
200C:  BSF    xE5.4
....................    else 
200E:  BRA    2012
....................       AckSend.B5 = 0; 
2010:  BCF    xE5.4
....................    if((In.B6 == 0) && (Output.B6 ==0)) 
2012:  BTFSC  xE2.5
2014:  BRA    201E
2016:  BTFSC  xDB.5
2018:  BRA    201E
....................       AckSend.B6 = 1; 
201A:  BSF    xE5.5
....................    else 
201C:  BRA    2020
....................       AckSend.B6 = 0; 
201E:  BCF    xE5.5
....................    if((In.B7 == 0) && (Output.B7 ==0)) 
2020:  BTFSC  xE2.6
2022:  BRA    202C
2024:  BTFSC  xDB.6
2026:  BRA    202C
....................       AckSend.B7 = 1; 
2028:  BSF    xE5.6
....................    else 
202A:  BRA    202E
....................       AckSend.B7 = 0; 
202C:  BCF    xE5.6
....................    if((In.B8 == 0) && (Output.B8 ==0)) 
202E:  BTFSC  xE2.7
2030:  BRA    203A
2032:  BTFSC  xDB.7
2034:  BRA    203A
....................       AckSend.B8 = 1; 
2036:  BSF    xE5.7
....................    else 
2038:  BRA    203C
....................       AckSend.B8 = 0; 
203A:  BCF    xE5.7
....................  
....................     
....................    ///////////////////Ack///////////////////////////////// 
....................    Ack1_8_Send = Ack1_8_Send | AckSend.B8; 
203C:  MOVLW  00
203E:  BTFSC  xE5.7
2040:  MOVLW  01
2042:  IORWF  23,F
....................    Ack1_8_Send = (Ack1_8_Send << 1) | AckSend.B7; 
2044:  BCF    FD8.0
2046:  RLCF   23,W
2048:  MOVLB  8
204A:  MOVWF  x79
204C:  MOVLW  00
204E:  MOVLB  7
2050:  BTFSC  xE5.6
2052:  MOVLW  01
2054:  MOVLB  8
2056:  IORWF  x79,W
2058:  MOVWF  23
....................    Ack1_8_Send = (Ack1_8_Send << 1) | AckSend.B6; 
205A:  BCF    FD8.0
205C:  RLCF   23,W
205E:  MOVWF  x79
2060:  MOVLW  00
2062:  MOVLB  7
2064:  BTFSC  xE5.5
2066:  MOVLW  01
2068:  MOVLB  8
206A:  IORWF  x79,W
206C:  MOVWF  23
....................    Ack1_8_Send = (Ack1_8_Send << 1) | AckSend.B5; 
206E:  BCF    FD8.0
2070:  RLCF   23,W
2072:  MOVWF  x79
2074:  MOVLW  00
2076:  MOVLB  7
2078:  BTFSC  xE5.4
207A:  MOVLW  01
207C:  MOVLB  8
207E:  IORWF  x79,W
2080:  MOVWF  23
....................    Ack1_8_Send = (Ack1_8_Send << 1) | AckSend.B4; 
2082:  BCF    FD8.0
2084:  RLCF   23,W
2086:  MOVWF  x79
2088:  MOVLW  00
208A:  MOVLB  7
208C:  BTFSC  xE5.3
208E:  MOVLW  01
2090:  MOVLB  8
2092:  IORWF  x79,W
2094:  MOVWF  23
....................    Ack1_8_Send = (Ack1_8_Send << 1) | AckSend.B3; 
2096:  BCF    FD8.0
2098:  RLCF   23,W
209A:  MOVWF  x79
209C:  MOVLW  00
209E:  MOVLB  7
20A0:  BTFSC  xE5.2
20A2:  MOVLW  01
20A4:  MOVLB  8
20A6:  IORWF  x79,W
20A8:  MOVWF  23
....................    Ack1_8_Send = (Ack1_8_Send << 1) | AckSend.B2; 
20AA:  BCF    FD8.0
20AC:  RLCF   23,W
20AE:  MOVWF  x79
20B0:  MOVLW  00
20B2:  MOVLB  7
20B4:  BTFSC  xE5.1
20B6:  MOVLW  01
20B8:  MOVLB  8
20BA:  IORWF  x79,W
20BC:  MOVWF  23
....................    Ack1_8_Send = (Ack1_8_Send << 1) | AckSend.B1; 
20BE:  BCF    FD8.0
20C0:  RLCF   23,W
20C2:  MOVWF  x79
20C4:  MOVLW  00
20C6:  MOVLB  7
20C8:  BTFSC  xE5.0
20CA:  MOVLW  01
20CC:  MOVLB  8
20CE:  IORWF  x79,W
20D0:  MOVWF  23
....................     
....................    ///////////////////Fault///////////////////////////////// 
....................    Input1_8_Send = Input1_8_Send | In.B8; 
20D2:  MOVLW  00
20D4:  MOVLB  7
20D6:  BTFSC  xE2.7
20D8:  MOVLW  01
20DA:  IORWF  1B,F
....................    Input1_8_Send = (Input1_8_Send << 1) | In.B7; 
20DC:  BCF    FD8.0
20DE:  RLCF   1B,W
20E0:  MOVLB  8
20E2:  MOVWF  x79
20E4:  MOVLW  00
20E6:  MOVLB  7
20E8:  BTFSC  xE2.6
20EA:  MOVLW  01
20EC:  MOVLB  8
20EE:  IORWF  x79,W
20F0:  MOVWF  1B
....................    Input1_8_Send = (Input1_8_Send << 1) | In.B6; 
20F2:  BCF    FD8.0
20F4:  RLCF   1B,W
20F6:  MOVWF  x79
20F8:  MOVLW  00
20FA:  MOVLB  7
20FC:  BTFSC  xE2.5
20FE:  MOVLW  01
2100:  MOVLB  8
2102:  IORWF  x79,W
2104:  MOVWF  1B
....................    Input1_8_Send = (Input1_8_Send << 1) | In.B5; 
2106:  BCF    FD8.0
2108:  RLCF   1B,W
210A:  MOVWF  x79
210C:  MOVLW  00
210E:  MOVLB  7
2110:  BTFSC  xE2.4
2112:  MOVLW  01
2114:  MOVLB  8
2116:  IORWF  x79,W
2118:  MOVWF  1B
....................    Input1_8_Send = (Input1_8_Send << 1) | In.B4; 
211A:  BCF    FD8.0
211C:  RLCF   1B,W
211E:  MOVWF  x79
2120:  MOVLW  00
2122:  MOVLB  7
2124:  BTFSC  xE2.3
2126:  MOVLW  01
2128:  MOVLB  8
212A:  IORWF  x79,W
212C:  MOVWF  1B
....................    Input1_8_Send = (Input1_8_Send << 1) | In.B3; 
212E:  BCF    FD8.0
2130:  RLCF   1B,W
2132:  MOVWF  x79
2134:  MOVLW  00
2136:  MOVLB  7
2138:  BTFSC  xE2.2
213A:  MOVLW  01
213C:  MOVLB  8
213E:  IORWF  x79,W
2140:  MOVWF  1B
....................    Input1_8_Send = (Input1_8_Send << 1) | In.B2; 
2142:  BCF    FD8.0
2144:  RLCF   1B,W
2146:  MOVWF  x79
2148:  MOVLW  00
214A:  MOVLB  7
214C:  BTFSC  xE2.1
214E:  MOVLW  01
2150:  MOVLB  8
2152:  IORWF  x79,W
2154:  MOVWF  1B
....................    Input1_8_Send = (Input1_8_Send << 1) | In.B1; 
2156:  BCF    FD8.0
2158:  RLCF   1B,W
215A:  MOVWF  x79
215C:  MOVLW  00
215E:  MOVLB  7
2160:  BTFSC  xE2.0
2162:  MOVLW  01
2164:  MOVLB  8
2166:  IORWF  x79,W
2168:  MOVWF  1B
....................       
.................... } 
216A:  MOVLB  0
216C:  GOTO   2B1A (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void checkCommand(void) 
.................... { 
....................    restart_wdt(); 
*
02D6:  CLRWDT
....................  
....................    if(sequence == end_sq )     //check Address 
02D8:  MOVF   6C,W
02DA:  SUBWF  74,W
02DC:  BNZ   0304
....................    { 
....................      RxD_DataLen = 0x00 ; 
02DE:  CLRF   76
....................      RxD_Buff[RxD_DataLen] = SBUF ;      //Byte 1   Address 
02E0:  MOVLW  76
02E2:  ADDWF  76,W
02E4:  MOVWF  FE9
02E6:  MOVLW  01
02E8:  MOVWF  FEA
02EA:  BTFSC  FD8.0
02EC:  INCF   FEA,F
02EE:  MOVFF  2B,FEF
....................      restart_wdt(); 
02F2:  CLRWDT
....................      RxD_DataLen ++ ; 
02F4:  INCF   76,F
....................      sequence = addr_sq; 
02F6:  MOVLW  10
02F8:  MOVWF  74
....................      T_timeout = 0x14; //200ms 
02FA:  MOVLW  14
02FC:  MOVLB  6
02FE:  MOVWF  x80
....................    } 
....................    else if(sequence == addr_sq) 
0300:  BRA    052A
0302:  MOVLB  0
0304:  MOVF   74,W
0306:  SUBLW  10
0308:  BNZ   03C2
....................    { 
....................       RxD_Buff[RxD_DataLen] = SBUF ;      //Byte 2   Function Code 
030A:  MOVLW  76
030C:  ADDWF  76,W
030E:  MOVWF  FE9
0310:  MOVLW  01
0312:  MOVWF  FEA
0314:  BTFSC  FD8.0
0316:  INCF   FEA,F
0318:  MOVFF  2B,FEF
....................       restart_wdt(); 
031C:  CLRWDT
....................       RxD_DataLen ++ ; 
031E:  INCF   76,F
....................  
....................        if(RxD_Buff[RxD_DataLen - 1] < 0x17)   //Function Code Must be less than 0x20 
0320:  MOVLW  01
0322:  SUBWF  76,W
0324:  ADDLW  76
0326:  MOVWF  FE9
0328:  MOVLW  01
032A:  MOVWF  FEA
032C:  BTFSC  FD8.0
032E:  INCF   FEA,F
0330:  MOVF   FEF,W
0332:  SUBLW  16
0334:  BNC   0344
....................        { 
....................            sequence = code_sq; 
0336:  MOVFF  6D,74
....................            T_timeout = 0x14; //200ms 
033A:  MOVLW  14
033C:  MOVLB  6
033E:  MOVWF  x80
....................        } 
....................        else if(RxD_Buff[RxD_DataLen - 1] == 0x20)   /////Read Setting////// 
0340:  BRA    03BE
0342:  MOVLB  0
0344:  MOVLW  01
0346:  SUBWF  76,W
0348:  ADDLW  76
034A:  MOVWF  FE9
034C:  MOVLW  01
034E:  MOVWF  FEA
0350:  BTFSC  FD8.0
0352:  INCF   FEA,F
0354:  MOVF   FEF,W
0356:  SUBLW  20
0358:  BNZ   0368
....................        { 
....................           sequence = ubyte_lo_sq; 
035A:  MOVFF  70,74
....................           T_timeout = 0x14; //200ms 
035E:  MOVLW  14
0360:  MOVLB  6
0362:  MOVWF  x80
....................        } 
....................        else if(RxD_Buff[RxD_DataLen - 1] == 0x21)   /////Write setting///// 
0364:  BRA    03BE
0366:  MOVLB  0
0368:  MOVLW  01
036A:  SUBWF  76,W
036C:  ADDLW  76
036E:  MOVWF  FE9
0370:  MOVLW  01
0372:  MOVWF  FEA
0374:  BTFSC  FD8.0
0376:  INCF   FEA,F
0378:  MOVF   FEF,W
037A:  SUBLW  21
037C:  BNZ   038C
....................        { 
....................           sequence = byte_count_sq ; 
037E:  MOVFF  72,74
....................           T_timeout = 0x14; //200ms 
0382:  MOVLW  14
0384:  MOVLB  6
0386:  MOVWF  x80
....................        } 
....................        else if(RxD_Buff[RxD_DataLen - 1] == 0x22)   /////Write setting///// 
0388:  BRA    03BE
038A:  MOVLB  0
038C:  MOVLW  01
038E:  SUBWF  76,W
0390:  ADDLW  76
0392:  MOVWF  FE9
0394:  MOVLW  01
0396:  MOVWF  FEA
0398:  BTFSC  FD8.0
039A:  INCF   FEA,F
039C:  MOVF   FEF,W
039E:  SUBLW  22
03A0:  BNZ   03B0
....................        { 
....................           sequence = byte_count_sq ; 
03A2:  MOVFF  72,74
....................           T_timeout = 0x14; //200ms 
03A6:  MOVLW  14
03A8:  MOVLB  6
03AA:  MOVWF  x80
....................        } 
....................        else                           // Invalid Code 
03AC:  BRA    03BE
03AE:  MOVLB  0
....................        { 
....................           RxD_DataLen = 0x00; 
03B0:  CLRF   76
....................           sequence = end_sq; 
03B2:  MOVFF  6C,74
....................           T_timeout = 0x00;  
03B6:  MOVLB  6
03B8:  CLRF   x80
....................           output_bit(P485ctrl,0); 
03BA:  BCF    F8A.3
03BC:  BCF    F93.3
....................        } 
....................    } 
....................    else if(sequence == byte_count_sq) 
03BE:  BRA    052A
03C0:  MOVLB  0
03C2:  MOVF   72,W
03C4:  SUBWF  74,W
03C6:  BNZ   0400
....................    { 
....................       RxD_Buff[RxD_DataLen] = SBUF ;      //Byte 3   Data Byte Count 
03C8:  MOVLW  76
03CA:  ADDWF  76,W
03CC:  MOVWF  FE9
03CE:  MOVLW  01
03D0:  MOVWF  FEA
03D2:  BTFSC  FD8.0
03D4:  INCF   FEA,F
03D6:  MOVFF  2B,FEF
....................       restart_wdt(); 
03DA:  CLRWDT
....................       RxD_DataLen ++ ; 
03DC:  INCF   76,F
....................       index = RxD_Buff[RxD_DataLen - 1] ;    //Data Byte Count 
03DE:  MOVLW  01
03E0:  SUBWF  76,W
03E2:  ADDLW  76
03E4:  MOVWF  FE9
03E6:  MOVLW  01
03E8:  MOVWF  FEA
03EA:  BTFSC  FD8.0
03EC:  INCF   FEA,F
03EE:  MOVFF  FEF,681
03F2:  MOVLB  6
....................       T_timeout = 0x14; //200ms 
03F4:  MOVLW  14
03F6:  MOVWF  x80
....................       sequence = data_sq ; 
03F8:  MOVFF  73,74
....................    } 
....................    else if(sequence == data_sq) 
03FC:  BRA    052A
03FE:  MOVLB  0
0400:  MOVF   73,W
0402:  SUBWF  74,W
0404:  BNZ   0430
....................    { 
....................       RxD_Buff[RxD_DataLen] = SBUF ;      // 
0406:  MOVLW  76
0408:  ADDWF  76,W
040A:  MOVWF  FE9
040C:  MOVLW  01
040E:  MOVWF  FEA
0410:  BTFSC  FD8.0
0412:  INCF   FEA,F
0414:  MOVFF  2B,FEF
....................       restart_wdt(); 
0418:  CLRWDT
....................       RxD_DataLen ++ ; 
041A:  INCF   76,F
....................       index -- ;                     //Data Byte Count 
041C:  MOVLB  6
041E:  DECF   x81,F
....................       if(index == 0x00) 
0420:  MOVF   x81,F
0422:  BNZ   0428
....................       { 
....................          sequence = ubyte_lo_sq ;      //next CRC 
0424:  MOVFF  70,74
....................       } 
....................       T_timeout = 0x14; //200ms 
0428:  MOVLW  14
042A:  MOVWF  x80
....................    } 
....................    else if(sequence == code_sq) 
042C:  BRA    052A
042E:  MOVLB  0
0430:  MOVF   6D,W
0432:  SUBWF  74,W
0434:  BNZ   045A
....................    { 
....................       RxD_Buff[RxD_DataLen] = SBUF ;      //Byte 3   Start address High Byte 
0436:  MOVLW  76
0438:  ADDWF  76,W
043A:  MOVWF  FE9
043C:  MOVLW  01
043E:  MOVWF  FEA
0440:  BTFSC  FD8.0
0442:  INCF   FEA,F
0444:  MOVFF  2B,FEF
....................       restart_wdt(); 
0448:  CLRWDT
....................       RxD_DataLen ++ ; 
044A:  INCF   76,F
....................       sequence = start_addr_hi_sq; 
044C:  MOVFF  6E,74
....................       T_timeout = 0x14; //200ms 
0450:  MOVLW  14
0452:  MOVLB  6
0454:  MOVWF  x80
....................  
....................    } 
....................    else if(sequence == start_addr_hi_sq) 
0456:  BRA    052A
0458:  MOVLB  0
045A:  MOVF   6E,W
045C:  SUBWF  74,W
045E:  BNZ   0484
....................    { 
....................       RxD_Buff[RxD_DataLen] = SBUF ;         //Byte 4   Start address Low Byte 
0460:  MOVLW  76
0462:  ADDWF  76,W
0464:  MOVWF  FE9
0466:  MOVLW  01
0468:  MOVWF  FEA
046A:  BTFSC  FD8.0
046C:  INCF   FEA,F
046E:  MOVFF  2B,FEF
....................       restart_wdt(); 
0472:  CLRWDT
....................       RxD_DataLen ++ ; 
0474:  INCF   76,F
....................       sequence = start_addr_lo_sq; 
0476:  MOVFF  6F,74
....................       T_timeout = 0x14; //200ms 
047A:  MOVLW  14
047C:  MOVLB  6
047E:  MOVWF  x80
....................    } 
....................    else if(sequence == start_addr_lo_sq) 
0480:  BRA    052A
0482:  MOVLB  0
0484:  MOVF   6F,W
0486:  SUBWF  74,W
0488:  BNZ   04AE
....................    { 
....................       RxD_Buff[RxD_DataLen] = SBUF ;         //Byte 5   No. of point/force data High Byte 
048A:  MOVLW  76
048C:  ADDWF  76,W
048E:  MOVWF  FE9
0490:  MOVLW  01
0492:  MOVWF  FEA
0494:  BTFSC  FD8.0
0496:  INCF   FEA,F
0498:  MOVFF  2B,FEF
....................       restart_wdt(); 
049C:  CLRWDT
....................       RxD_DataLen ++ ; 
049E:  INCF   76,F
....................       sequence = ubyte_hi_sq; 
04A0:  MOVLW  15
04A2:  MOVWF  74
....................       T_timeout = 0x14; //200ms 
04A4:  MOVLW  14
04A6:  MOVLB  6
04A8:  MOVWF  x80
....................    } 
....................    else if(sequence == ubyte_hi_sq) 
04AA:  BRA    052A
04AC:  MOVLB  0
04AE:  MOVF   74,W
04B0:  SUBLW  15
04B2:  BNZ   04D8
....................    { 
....................       RxD_Buff[RxD_DataLen] = SBUF ;         //Byte 6   No. of point/force data Low Byte 
04B4:  MOVLW  76
04B6:  ADDWF  76,W
04B8:  MOVWF  FE9
04BA:  MOVLW  01
04BC:  MOVWF  FEA
04BE:  BTFSC  FD8.0
04C0:  INCF   FEA,F
04C2:  MOVFF  2B,FEF
....................       restart_wdt(); 
04C6:  CLRWDT
....................       RxD_DataLen ++ ; 
04C8:  INCF   76,F
....................       sequence = ubyte_lo_sq; 
04CA:  MOVFF  70,74
....................       T_timeout = 0x14; //200ms 
04CE:  MOVLW  14
04D0:  MOVLB  6
04D2:  MOVWF  x80
....................    } 
....................    else if(sequence == ubyte_lo_sq) 
04D4:  BRA    052A
04D6:  MOVLB  0
04D8:  MOVF   70,W
04DA:  SUBWF  74,W
04DC:  BNZ   0502
....................    { 
....................       RxD_Buff[RxD_DataLen] = SBUF ;         //Byte 7   CRC High Byte 
04DE:  MOVLW  76
04E0:  ADDWF  76,W
04E2:  MOVWF  FE9
04E4:  MOVLW  01
04E6:  MOVWF  FEA
04E8:  BTFSC  FD8.0
04EA:  INCF   FEA,F
04EC:  MOVFF  2B,FEF
....................       restart_wdt(); 
04F0:  CLRWDT
....................       RxD_DataLen ++ ; 
04F2:  INCF   76,F
....................       sequence = crc_hi_sq; 
04F4:  MOVFF  71,74
....................       T_timeout = 0x14; //200ms 
04F8:  MOVLW  14
04FA:  MOVLB  6
04FC:  MOVWF  x80
....................    } 
....................    else if(sequence == crc_hi_sq) 
04FE:  BRA    052A
0500:  MOVLB  0
0502:  MOVF   71,W
0504:  SUBWF  74,W
0506:  BNZ   052A
....................    { 
....................       RxD_Buff[RxD_DataLen] = SBUF ;         //Byte 8   CRC Low Byte 
0508:  MOVLW  76
050A:  ADDWF  76,W
050C:  MOVWF  FE9
050E:  MOVLW  01
0510:  MOVWF  FEA
0512:  BTFSC  FD8.0
0514:  INCF   FEA,F
0516:  MOVFF  2B,FEF
....................       restart_wdt(); 
051A:  CLRWDT
....................       sequence = end_sq; 
051C:  MOVFF  6C,74
....................       T_timeout = 0x00; 
0520:  MOVLB  6
0522:  CLRF   x80
....................       //T_timeout = 0x14; //200ms 
....................       recieve_completed = 1 ;            //Recieve completed then translate 
0524:  BSF    2D.5
....................       output_bit(P485ctrl,0); 
0526:  BCF    F8A.3
0528:  BCF    F93.3
052A:  MOVLB  0
....................    } 
.................... } 
052C:  GOTO   053C (RETURN)
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... ///////////////////// MODBUS FUNCTION ////////////////////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void Modbus_Function(void) 
.................... { 
....................    restart_wdt(); 
*
23C8:  CLRWDT
....................    CRC(RxD_Buff , RxD_DataLen - 1); 
23CA:  MOVLW  01
23CC:  SUBWF  76,W
23CE:  MOVLB  8
23D0:  MOVWF  x79
23D2:  MOVLW  01
23D4:  MOVWF  x7B
23D6:  MOVLW  76
23D8:  MOVWF  x7A
23DA:  MOVFF  879,87C
23DE:  MOVLB  0
23E0:  RCALL  1F56
....................  
....................    if(CRC_Hi == RxD_Buff[RxD_DataLen - 1] && CRC_Lo == RxD_Buff[RxD_DataLen]) 
23E2:  MOVLW  01
23E4:  SUBWF  76,W
23E6:  ADDLW  76
23E8:  MOVWF  FE9
23EA:  MOVLW  01
23EC:  MOVWF  FEA
23EE:  BTFSC  FD8.0
23F0:  INCF   FEA,F
23F2:  MOVF   FEF,W
23F4:  MOVLB  5
23F6:  SUBWF  x77,W
23F8:  BTFSS  FD8.2
23FA:  GOTO   445C
23FE:  MOVLW  76
2400:  ADDWF  76,W
2402:  MOVWF  FE9
2404:  MOVLW  01
2406:  MOVWF  FEA
2408:  BTFSC  FD8.0
240A:  INCF   FEA,F
240C:  MOVF   FEF,W
240E:  SUBWF  x76,W
2410:  BTFSS  FD8.2
2412:  GOTO   445C
....................    { 
....................     
....................           
....................       if((RxD_Buff[0] == 0xAA)&&(RxD_Buff[1] == 0x20)) //Read Setting//0xAA Is Any Address  
2416:  MOVLB  1
2418:  MOVF   x76,W
241A:  SUBLW  AA
241C:  BTFSS  FD8.2
241E:  BRA    26DA
2420:  MOVF   x77,W
2422:  SUBLW  20
2424:  BTFSS  FD8.2
2426:  BRA    26DA
....................       { 
....................          TxD_Buff[0] = Address ;         //Address 
2428:  MOVFF  75,77
....................          TxD_Buff[1] = 0x20 ;            //function code 
242C:  MOVLW  20
242E:  MOVWF  78
....................          TxD_Buff[2] = 0x1C ;           //28 Byte  //Data Byte count 
2430:  MOVLW  1C
2432:  MOVWF  79
....................          TxD_Buff[3] = InputType1_8 ;    //1 
2434:  MOVFF  37,7A
....................          TxD_Buff[4] = InputType9_16 ;  //2 
2438:  MOVFF  38,7B
....................          TxD_Buff[5] = InputType17_24 ;//3 
243C:  MOVFF  39,7C
....................           
....................          TxD_Buff[6] = FaultType1_8 ;  //4 
2440:  MOVFF  3A,7D
....................          TxD_Buff[7] = FaultType9_16 ; //5 
2444:  MOVFF  3B,7E
....................          TxD_Buff[8] = FaultType17_24 ;   //6 
2448:  MOVFF  3C,7F
....................          
....................          TxD_Buff[9] = OutputType1_8 ; //7 
244C:  MOVFF  3D,80
....................          TxD_Buff[10] = OutputType9_16 ;  //8 
2450:  MOVFF  3E,81
....................          TxD_Buff[11] = OutputType17_24 ; //9 
2454:  MOVFF  3F,82
....................          
....................          TxD_Buff[12] = OutputBoth1_8 ;   //10 
2458:  MOVFF  40,83
....................          TxD_Buff[13] = OutputBoth9_16 ;  //11 
245C:  MOVFF  41,84
....................          TxD_Buff[14] = OutputBoth17_24 ; //12 
2460:  MOVFF  42,85
....................          
....................          TxD_Buff[15] = Alarm_Indicator1_8 ; //13 
2464:  MOVFF  43,86
....................          TxD_Buff[16] = Alarm_Indicator9_16 ;   //14 
2468:  MOVFF  44,87
....................          TxD_Buff[17] = Alarm_Indicator17_24 ;  //15 
246C:  MOVFF  45,88
....................          
....................           TxD_Buff[18] = read_eeprom(0x10);//Red1_8;    //16 
2470:  MOVFF  FF2,879
2474:  BCF    FF2.7
2476:  CLRF   FAA
2478:  MOVLW  10
247A:  MOVWF  FA9
247C:  BCF    FA6.6
247E:  BCF    FA6.7
2480:  BSF    FA6.0
2482:  MOVF   FA8,W
2484:  MOVLB  8
2486:  BTFSC  x79.7
2488:  BSF    FF2.7
248A:  MOVLB  0
248C:  MOVWF  x89
....................           TxD_Buff[19] = read_eeprom(0x11);//Red9_10;      //17 
248E:  MOVFF  FF2,879
2492:  BCF    FF2.7
2494:  CLRF   FAA
2496:  MOVLW  11
2498:  MOVWF  FA9
249A:  BCF    FA6.6
249C:  BCF    FA6.7
249E:  BSF    FA6.0
24A0:  MOVF   FA8,W
24A2:  MOVLB  8
24A4:  BTFSC  x79.7
24A6:  BSF    FF2.7
24A8:  MOVLB  0
24AA:  MOVWF  x8A
....................           TxD_Buff[20] = read_eeprom(0x12);//Red11_18;     //18 
24AC:  MOVFF  FF2,879
24B0:  BCF    FF2.7
24B2:  CLRF   FAA
24B4:  MOVLW  12
24B6:  MOVWF  FA9
24B8:  BCF    FA6.6
24BA:  BCF    FA6.7
24BC:  BSF    FA6.0
24BE:  MOVF   FA8,W
24C0:  MOVLB  8
24C2:  BTFSC  x79.7
24C4:  BSF    FF2.7
24C6:  MOVLB  0
24C8:  MOVWF  x8B
....................           TxD_Buff[21] = read_eeprom(0x13);//Red19_20;     //19 
24CA:  MOVFF  FF2,879
24CE:  BCF    FF2.7
24D0:  CLRF   FAA
24D2:  MOVLW  13
24D4:  MOVWF  FA9
24D6:  BCF    FA6.6
24D8:  BCF    FA6.7
24DA:  BSF    FA6.0
24DC:  MOVF   FA8,W
24DE:  MOVLB  8
24E0:  BTFSC  x79.7
24E2:  BSF    FF2.7
24E4:  MOVLB  0
24E6:  MOVWF  x8C
....................            
....................           TxD_Buff[22] = read_eeprom(0x14);//Green1_8;     //20 
24E8:  MOVFF  FF2,879
24EC:  BCF    FF2.7
24EE:  CLRF   FAA
24F0:  MOVLW  14
24F2:  MOVWF  FA9
24F4:  BCF    FA6.6
24F6:  BCF    FA6.7
24F8:  BSF    FA6.0
24FA:  MOVF   FA8,W
24FC:  MOVLB  8
24FE:  BTFSC  x79.7
2500:  BSF    FF2.7
2502:  MOVLB  0
2504:  MOVWF  x8D
....................           TxD_Buff[23] = read_eeprom(0x15);//Green9_10;    //21 
2506:  MOVFF  FF2,879
250A:  BCF    FF2.7
250C:  CLRF   FAA
250E:  MOVLW  15
2510:  MOVWF  FA9
2512:  BCF    FA6.6
2514:  BCF    FA6.7
2516:  BSF    FA6.0
2518:  MOVF   FA8,W
251A:  MOVLB  8
251C:  BTFSC  x79.7
251E:  BSF    FF2.7
2520:  MOVLB  0
2522:  MOVWF  x8E
....................           TxD_Buff[24] = read_eeprom(0x16);//Green11_18;      //22 
2524:  MOVFF  FF2,879
2528:  BCF    FF2.7
252A:  CLRF   FAA
252C:  MOVLW  16
252E:  MOVWF  FA9
2530:  BCF    FA6.6
2532:  BCF    FA6.7
2534:  BSF    FA6.0
2536:  MOVF   FA8,W
2538:  MOVLB  8
253A:  BTFSC  x79.7
253C:  BSF    FF2.7
253E:  MOVLB  0
2540:  MOVWF  x8F
....................           TxD_Buff[25] = read_eeprom(0x17);//Green19_20;      //23 
2542:  MOVFF  FF2,879
2546:  BCF    FF2.7
2548:  CLRF   FAA
254A:  MOVLW  17
254C:  MOVWF  FA9
254E:  BCF    FA6.6
2550:  BCF    FA6.7
2552:  BSF    FA6.0
2554:  MOVF   FA8,W
2556:  MOVLB  8
2558:  BTFSC  x79.7
255A:  BSF    FF2.7
255C:  MOVLB  0
255E:  MOVWF  x90
....................         
....................          TxD_Buff[26] = AutoAck ;            //24 
2560:  MOVFF  67,91
....................          TxD_Buff[27] = AutoAckTime ;        //25 
2564:  MOVFF  68,92
....................          TxD_Buff[28] = FlashingRate ;       //26 
2568:  MOVFF  69,93
....................          TxD_Buff[29] = NoOfPoint ;          //27 
256C:  MOVFF  6A,94
....................          TxD_Buff[30] = FaultDelayTime ;    //28 
2570:  MOVLW  2D
2572:  MOVWF  x95
....................          TxD_Buff[31] = Address ;            //29 
2574:  MOVFF  75,96
....................  
....................          TxD_Buff[32] = FaultDelayTime[1] ; 
2578:  MOVFF  82F,97
....................          TxD_Buff[33] = FaultDelayTime[2] ; 
257C:  MOVFF  831,98
....................          TxD_Buff[34] = FaultDelayTime[3] ; 
2580:  MOVFF  833,99
....................          TxD_Buff[35] = FaultDelayTime[4] ; 
2584:  MOVFF  835,9A
....................          TxD_Buff[36] = FaultDelayTime[5] ; 
2588:  MOVFF  837,9B
....................          TxD_Buff[37] = FaultDelayTime[6] ; 
258C:  MOVFF  839,9C
....................          TxD_Buff[38] = FaultDelayTime[7] ; 
2590:  MOVFF  83B,9D
....................          TxD_Buff[39] = FaultDelayTime[8] ; 
2594:  MOVFF  83D,9E
....................          TxD_Buff[40] = FaultDelayTime[9] ; 
2598:  MOVFF  83F,9F
....................          TxD_Buff[41] = FaultDelayTime[10] ; 
259C:  MOVFF  841,A0
....................          TxD_Buff[42] = FaultDelayTime[11] ; 
25A0:  MOVFF  843,A1
....................          TxD_Buff[43] = FaultDelayTime[12] ; 
25A4:  MOVFF  845,A2
....................          TxD_Buff[44] = FaultDelayTime[13] ; 
25A8:  MOVFF  847,A3
....................          TxD_Buff[45] = FaultDelayTime[14] ; 
25AC:  MOVFF  849,A4
....................          TxD_Buff[46] = FaultDelayTime[15] ; 
25B0:  MOVFF  84B,A5
....................          TxD_Buff[47] = FaultDelayTime[16] ; 
25B4:  MOVFF  84D,A6
....................          TxD_Buff[48] = FaultDelayTime[17] ; 
25B8:  MOVFF  84F,A7
....................          TxD_Buff[49] = FaultDelayTime[18] ; 
25BC:  MOVFF  851,A8
....................          TxD_Buff[50] = FaultDelayTime[19] ; 
25C0:  MOVFF  853,A9
....................          TxD_Buff[51] = FaultDelayTime[20] ; 
25C4:  MOVFF  855,AA
....................           
....................          CRC(TxD_Buff,52)   ; //Cal CRC 49 byte 
25C8:  MOVLB  8
25CA:  CLRF   x7B
25CC:  MOVLW  77
25CE:  MOVWF  x7A
25D0:  MOVLW  34
25D2:  MOVWF  x7C
25D4:  MOVLB  0
25D6:  RCALL  1F56
....................  
....................          TxD_Buff[52] = CRC_Hi ; 
25D8:  MOVFF  577,AB
....................          TxD_Buff[53] = CRC_Lo ; 
25DC:  MOVFF  576,AC
....................  
....................          output_bit(P485ctrl,1); 
25E0:  BSF    F8A.3
25E2:  BCF    F93.3
....................          delay_ms(10); 
25E4:  MOVLW  0A
25E6:  MOVLB  8
25E8:  MOVWF  x79
25EA:  MOVLB  0
25EC:  CALL   0772
....................  
....................          putc(Txd_Buff[0]); 
25F0:  MOVF   77,W
25F2:  RCALL  1F4C
....................          putc(Txd_Buff[1]); 
25F4:  MOVF   78,W
25F6:  RCALL  1F4C
....................          putc(Txd_Buff[2]); 
25F8:  MOVF   79,W
25FA:  RCALL  1F4C
....................          putc(Txd_Buff[3]); 
25FC:  MOVF   7A,W
25FE:  RCALL  1F4C
....................          putc(Txd_Buff[4]); 
2600:  MOVF   7B,W
2602:  RCALL  1F4C
....................          putc(Txd_Buff[5]); 
2604:  MOVF   7C,W
2606:  RCALL  1F4C
....................          putc(Txd_Buff[6]); 
2608:  MOVF   7D,W
260A:  RCALL  1F4C
....................          putc(Txd_Buff[7]); 
260C:  MOVF   7E,W
260E:  RCALL  1F4C
....................          putc(Txd_Buff[8]); 
2610:  MOVF   7F,W
2612:  RCALL  1F4C
....................          putc(Txd_Buff[9]); 
2614:  MOVF   x80,W
2616:  RCALL  1F4C
....................          putc(Txd_Buff[10]); 
2618:  MOVF   x81,W
261A:  RCALL  1F4C
....................          putc(Txd_Buff[11]); 
261C:  MOVF   x82,W
261E:  RCALL  1F4C
....................          putc(Txd_Buff[12]); 
2620:  MOVF   x83,W
2622:  RCALL  1F4C
....................          putc(Txd_Buff[13]); 
2624:  MOVF   x84,W
2626:  RCALL  1F4C
....................          putc(Txd_Buff[14]); 
2628:  MOVF   x85,W
262A:  RCALL  1F4C
....................          putc(Txd_Buff[15]); 
262C:  MOVF   x86,W
262E:  RCALL  1F4C
....................          putc(Txd_Buff[16]); 
2630:  MOVF   x87,W
2632:  RCALL  1F4C
....................          putc(Txd_Buff[17]); 
2634:  MOVF   x88,W
2636:  RCALL  1F4C
....................          putc(Txd_Buff[18]); 
2638:  MOVF   x89,W
263A:  RCALL  1F4C
....................          putc(Txd_Buff[19]); 
263C:  MOVF   x8A,W
263E:  RCALL  1F4C
....................          putc(Txd_Buff[20]); 
2640:  MOVF   x8B,W
2642:  RCALL  1F4C
....................          putc(Txd_Buff[21]); 
2644:  MOVF   x8C,W
2646:  RCALL  1F4C
....................          putc(Txd_Buff[22]); 
2648:  MOVF   x8D,W
264A:  RCALL  1F4C
....................          putc(Txd_Buff[23]); 
264C:  MOVF   x8E,W
264E:  RCALL  1F4C
....................          putc(Txd_Buff[24]); 
2650:  MOVF   x8F,W
2652:  RCALL  1F4C
....................          putc(Txd_Buff[25]); 
2654:  MOVF   x90,W
2656:  RCALL  1F4C
....................          putc(Txd_Buff[26]); 
2658:  MOVF   x91,W
265A:  RCALL  1F4C
....................          putc(Txd_Buff[27]); 
265C:  MOVF   x92,W
265E:  RCALL  1F4C
....................          putc(Txd_Buff[28]); 
2660:  MOVF   x93,W
2662:  RCALL  1F4C
....................          putc(Txd_Buff[29]); 
2664:  MOVF   x94,W
2666:  RCALL  1F4C
....................          putc(Txd_Buff[30]); 
2668:  MOVF   x95,W
266A:  RCALL  1F4C
....................          putc(Txd_Buff[31]); 
266C:  MOVF   x96,W
266E:  RCALL  1F4C
....................           
....................          putc(Txd_Buff[32]); 
2670:  MOVF   x97,W
2672:  RCALL  1F4C
....................          putc(Txd_Buff[33]); 
2674:  MOVF   x98,W
2676:  RCALL  1F4C
....................          putc(Txd_Buff[34]); 
2678:  MOVF   x99,W
267A:  RCALL  1F4C
....................          putc(Txd_Buff[35]); 
267C:  MOVF   x9A,W
267E:  RCALL  1F4C
....................          putc(Txd_Buff[36]); 
2680:  MOVF   x9B,W
2682:  RCALL  1F4C
....................          putc(Txd_Buff[37]); 
2684:  MOVF   x9C,W
2686:  RCALL  1F4C
....................          putc(Txd_Buff[38]); 
2688:  MOVF   x9D,W
268A:  RCALL  1F4C
....................          putc(Txd_Buff[39]); 
268C:  MOVF   x9E,W
268E:  RCALL  1F4C
....................          putc(Txd_Buff[40]); 
2690:  MOVF   x9F,W
2692:  RCALL  1F4C
....................          putc(Txd_Buff[41]); 
2694:  MOVF   xA0,W
2696:  RCALL  1F4C
....................           
....................          putc(Txd_Buff[42]); 
2698:  MOVF   xA1,W
269A:  RCALL  1F4C
....................          putc(Txd_Buff[43]); 
269C:  MOVF   xA2,W
269E:  RCALL  1F4C
....................          putc(Txd_Buff[44]); 
26A0:  MOVF   xA3,W
26A2:  RCALL  1F4C
....................          putc(Txd_Buff[45]); 
26A4:  MOVF   xA4,W
26A6:  RCALL  1F4C
....................          putc(Txd_Buff[46]); 
26A8:  MOVF   xA5,W
26AA:  RCALL  1F4C
....................          putc(Txd_Buff[47]); 
26AC:  MOVF   xA6,W
26AE:  RCALL  1F4C
....................          putc(Txd_Buff[48]); 
26B0:  MOVF   xA7,W
26B2:  RCALL  1F4C
....................          putc(Txd_Buff[49]); 
26B4:  MOVF   xA8,W
26B6:  RCALL  1F4C
....................          putc(Txd_Buff[50]); 
26B8:  MOVF   xA9,W
26BA:  RCALL  1F4C
....................          putc(Txd_Buff[51]); 
26BC:  MOVF   xAA,W
26BE:  RCALL  1F4C
....................           
....................          putc(Txd_Buff[52]); 
26C0:  MOVF   xAB,W
26C2:  RCALL  1F4C
....................          putc(Txd_Buff[53]); 
26C4:  MOVF   xAC,W
26C6:  RCALL  1F4C
....................         
....................          delay_ms(3); 
26C8:  MOVLW  03
26CA:  MOVLB  8
26CC:  MOVWF  x79
26CE:  MOVLB  0
26D0:  CALL   0772
....................          output_bit(P485ctrl,0); 
26D4:  BCF    F8A.3
26D6:  BCF    F93.3
26D8:  MOVLB  1
....................            
....................       } 
....................     
....................  
....................    /////////////////////////////////////////////////////////////// 
....................       if(RxD_Buff[0] == Address) 
26DA:  MOVF   75,W
26DC:  SUBWF  x76,W
26DE:  BTFSS  FD8.2
26E0:  GOTO   4452
....................       { 
....................        
....................       if(RxD_Buff[1] == 0x01)///////////// READ COIL ///////////////////// 
26E4:  DECFSZ x77,W
26E6:  BRA    2B0C
....................       { 
....................             //Do Read Coil 
....................             Start_Address = RxD_Buff[2] ; 
26E8:  MOVLB  5
26EA:  CLRF   x7B
26EC:  MOVFF  178,57A
....................             Start_Address = (Start_Address << 8) | RxD_Buff[3] ;   //Start Address 16 bit 
26F0:  MOVFF  57A,87A
26F4:  MOVLB  8
26F6:  CLRF   x79
26F8:  MOVF   x79,W
26FA:  MOVLB  1
26FC:  IORWF  x79,W
26FE:  MOVLB  5
2700:  MOVWF  x7A
2702:  MOVFF  87A,57B
2706:  MOVLB  5
....................             No_PointCount = RxD_Buff[4] ; 
2708:  CLRF   x7D
270A:  MOVFF  17A,57C
....................             No_PointCount = (No_PointCount << 8) | RxD_Buff[5] ;   //No. of Point 16 bit 
270E:  MOVFF  57C,87A
2712:  MOVLB  8
2714:  CLRF   x79
2716:  MOVF   x79,W
2718:  MOVLB  1
271A:  IORWF  x7B,W
271C:  MOVLB  5
271E:  MOVWF  x7C
2720:  MOVFF  87A,57D
2724:  MOVLB  5
....................  
....................             if(Start_Address < 0x10 && (Start_Address + No_PointCount) < 0x11)  //Valid point 0-15 
2726:  MOVF   x7B,F
2728:  BTFSS  FD8.2
272A:  BRA    2A9C
272C:  MOVF   x7A,W
272E:  SUBLW  0F
2730:  BTFSS  FD8.0
2732:  BRA    2A9C
2734:  MOVF   x7C,W
2736:  ADDWF  x7A,W
2738:  MOVLB  8
273A:  MOVWF  x79
273C:  MOVLB  5
273E:  MOVF   x7D,W
2740:  ADDWFC x7B,W
2742:  MOVLB  8
2744:  MOVWF  x7A
2746:  MOVF   x7A,F
2748:  BTFSC  FD8.2
274A:  BRA    2750
274C:  MOVLB  5
274E:  BRA    2A9C
2750:  MOVF   x79,W
2752:  SUBLW  10
2754:  BTFSC  FD8.0
2756:  BRA    275C
2758:  MOVLB  5
275A:  BRA    2A9C
....................             { 
....................                if(No_PointCount < 9) Data_ByteCount = 0x01 ; 
275C:  MOVLB  5
275E:  MOVF   x7D,F
2760:  BNZ   276E
2762:  MOVF   x7C,W
2764:  SUBLW  08
2766:  BNC   276E
2768:  MOVLW  01
276A:  MOVWF  x7E
....................                else if(No_PointCount < 17) Data_ByteCount = 0x02 ; 
276C:  BRA    2792
276E:  MOVF   x7D,F
2770:  BNZ   277E
2772:  MOVF   x7C,W
2774:  SUBLW  10
2776:  BNC   277E
2778:  MOVLW  02
277A:  MOVWF  x7E
....................                else if(No_PointCount < 25) Data_ByteCount = 0x03 ; 
277C:  BRA    2792
277E:  MOVF   x7D,F
2780:  BNZ   278E
2782:  MOVF   x7C,W
2784:  SUBLW  18
2786:  BNC   278E
2788:  MOVLW  03
278A:  MOVWF  x7E
....................                else   Data_ByteCount = 0x01 ; //----Jack 
278C:  BRA    2792
278E:  MOVLW  01
2790:  MOVWF  x7E
....................  
....................                if(Data_ByteCount == 0x01) 
2792:  DECFSZ x7E,W
2794:  BRA    28D8
....................                { 
....................  
....................                   if(Start_Address < 0x09) 
2796:  MOVF   x7B,F
2798:  BNZ   27B4
279A:  MOVF   x7A,W
279C:  SUBLW  08
279E:  BNC   27B4
....................                   { 
....................                      //Data_Buff[0] = ~output[0] >> Start_Address ; 
....................                      //DataTemp = ~output[1] << (0x08 - Start_Address) ; 
....................                      //Data_Buff[0] = (~output[0] >> Start_Address) | DataTemp;   //Low Byte 
....................                       Data_Buff[0] = Input1_8 >> Start_Address ; 
27A0:  MOVFF  46,57F
27A4:  MOVF   x7A,W
27A6:  MOVWF  01
27A8:  BZ    27B2
27AA:  BCF    FD8.0
27AC:  RRCF   x7F,F
27AE:  DECFSZ 01,F
27B0:  BRA    27AA
....................                       //DataTemp = Input9_16 << (0x08 - Start_Address) ;//JJ 
....................                       //Data_Buff[0] = (Input1_8 >> Start_Address) | DataTemp;   //Low Byte//JJ 
....................                   } 
....................                   else if(Start_Address > 0x08 && Start_Address < 0x10) 
27B2:  BRA    27E8
27B4:  MOVF   x7B,F
27B6:  BNZ   27BE
27B8:  MOVF   x7A,W
27BA:  SUBLW  08
27BC:  BC    27E8
27BE:  MOVF   x7B,F
27C0:  BNZ   27E8
27C2:  MOVF   x7A,W
27C4:  SUBLW  0F
27C6:  BNC   27E8
....................                   { 
....................                      //Data_Buff[0] = ~output[1] >> (Start_Address - 0x08) ; 
....................                      Data_Buff[0] = Input9_16 >> (Start_Address - 0x08) ; 
27C8:  MOVLW  08
27CA:  SUBWF  x7A,W
27CC:  MOVWF  00
27CE:  MOVLW  00
27D0:  SUBWFB x7B,W
27D2:  MOVWF  03
27D4:  MOVFF  00,01
27D8:  MOVFF  47,57F
27DC:  MOVF   01,F
27DE:  BZ    27E8
27E0:  BCF    FD8.0
27E2:  RRCF   x7F,F
27E4:  DECFSZ 01,F
27E6:  BRA    27E0
....................                   } 
....................  
....................  
....................                   if(No_PointCount == 0x08) 
27E8:  MOVF   x7C,W
27EA:  SUBLW  08
27EC:  BNZ   27F4
27EE:  MOVF   x7D,F
27F0:  BNZ   27F4
....................                   { 
....................                      Data_Buff[0] = Data_Buff[0] & 0xFF ; //8 Point High Byte 
....................                   } 
....................                   else if(No_PointCount == 0x07) 
27F2:  BRA    285E
27F4:  MOVF   x7C,W
27F6:  SUBLW  07
27F8:  BNZ   2802
27FA:  MOVF   x7D,F
27FC:  BNZ   2802
....................                   { 
....................                      Data_Buff[0] =    Data_Buff[0] & 0x7F ; //7 Point High Byte 
27FE:  BCF    x7F.7
....................                   } 
....................                   else if(No_PointCount == 0x06) 
2800:  BRA    285E
2802:  MOVF   x7C,W
2804:  SUBLW  06
2806:  BNZ   2812
2808:  MOVF   x7D,F
280A:  BNZ   2812
....................                   { 
....................                      Data_Buff[0] =    Data_Buff[0] & 0x3F ; //6 Point High Byte 
280C:  MOVLW  3F
280E:  ANDWF  x7F,F
....................                   } 
....................                   else if(No_PointCount == 0x05) 
2810:  BRA    285E
2812:  MOVF   x7C,W
2814:  SUBLW  05
2816:  BNZ   2822
2818:  MOVF   x7D,F
281A:  BNZ   2822
....................                   { 
....................                      Data_Buff[0] =    Data_Buff[0] & 0x1F ; //5 Point High Byte 
281C:  MOVLW  1F
281E:  ANDWF  x7F,F
....................                   } 
....................                   else if(No_PointCount == 0x04) 
2820:  BRA    285E
2822:  MOVF   x7C,W
2824:  SUBLW  04
2826:  BNZ   2832
2828:  MOVF   x7D,F
282A:  BNZ   2832
....................                   { 
....................                      Data_Buff[0] =    Data_Buff[0] & 0x0F ; //4 Point High Byte 
282C:  MOVLW  0F
282E:  ANDWF  x7F,F
....................                   } 
....................                   else if(No_PointCount == 0x03) 
2830:  BRA    285E
2832:  MOVF   x7C,W
2834:  SUBLW  03
2836:  BNZ   2842
2838:  MOVF   x7D,F
283A:  BNZ   2842
....................                   { 
....................                      Data_Buff[0] =    Data_Buff[0] & 0x07 ; //3 Point High Byte 
283C:  MOVLW  07
283E:  ANDWF  x7F,F
....................                   } 
....................                   else if(No_PointCount == 0x02) 
2840:  BRA    285E
2842:  MOVF   x7C,W
2844:  SUBLW  02
2846:  BNZ   2852
2848:  MOVF   x7D,F
284A:  BNZ   2852
....................                   { 
....................                      Data_Buff[0] =    Data_Buff[0] & 0x03 ; //2 Point High Byte 
284C:  MOVLW  03
284E:  ANDWF  x7F,F
....................                   } 
....................                   else if(No_PointCount == 0x01) 
2850:  BRA    285E
2852:  DECFSZ x7C,W
2854:  BRA    285E
2856:  MOVF   x7D,F
2858:  BNZ   285E
....................                   { 
....................                      Data_Buff[0] =    Data_Buff[0] & 0x01 ; //1 Point High Byte 
285A:  MOVLW  01
285C:  ANDWF  x7F,F
....................                   } 
....................  
....................                   TxD_Buff[0] = Address ;         //Address 
285E:  MOVFF  75,77
....................                   TxD_Buff[1] = 0x01 ;         //Function Code 
2862:  MOVLW  01
2864:  MOVWF  78
....................                   TxD_Buff[2] = Data_ByteCount ;   //Byte Count 
2866:  MOVFF  57E,79
....................                   TxD_Buff[3] = Data_Buff[0] ;   //Data 
286A:  MOVFF  57F,7A
....................  
....................                   CRC(TxD_Buff,4)   ;            //Cal CRC 5 Byte 
286E:  MOVLB  8
2870:  CLRF   x7B
2872:  MOVLW  77
2874:  MOVWF  x7A
2876:  MOVLW  04
2878:  MOVWF  x7C
287A:  MOVLB  0
287C:  CALL   1F56
....................  
....................                   TxD_Buff[4] = CRC_Hi ; 
2880:  MOVFF  577,7B
....................                   TxD_Buff[5] = CRC_Lo ; 
2884:  MOVFF  576,7C
....................  
....................  
....................                   output_bit(P485ctrl,1); 
2888:  BSF    F8A.3
288A:  BCF    F93.3
....................                   restart_wdt(); 
288C:  CLRWDT
....................                   delay_ms(4); 
288E:  MOVLW  04
2890:  MOVLB  8
2892:  MOVWF  x79
2894:  MOVLB  0
2896:  CALL   0772
....................                   restart_wdt(); 
289A:  CLRWDT
....................  
....................                   putc(TxD_Buff[0]) ;               //Address 
289C:  MOVF   77,W
289E:  CALL   1F4C
....................                   putc(TxD_Buff[1]) ;               //Function Code 
28A2:  MOVF   78,W
28A4:  CALL   1F4C
....................                   putc(TxD_Buff[2]) ;               //Byte Count 
28A8:  MOVF   79,W
28AA:  CALL   1F4C
....................                   putc(TxD_Buff[3]) ; 
28AE:  MOVF   7A,W
28B0:  CALL   1F4C
....................                   putc(TxD_Buff[4]) ; 
28B4:  MOVF   7B,W
28B6:  CALL   1F4C
....................                   putc(TxD_Buff[5]) ; 
28BA:  MOVF   7C,W
28BC:  CALL   1F4C
....................  
....................                 
....................                   restart_wdt(); 
28C0:  CLRWDT
....................                   delay_ms(3); 
28C2:  MOVLW  03
28C4:  MOVLB  8
28C6:  MOVWF  x79
28C8:  MOVLB  0
28CA:  CALL   0772
....................                   restart_wdt(); 
28CE:  CLRWDT
....................                   output_bit(P485ctrl,0); 
28D0:  BCF    F8A.3
28D2:  BCF    F93.3
....................                
....................                } 
....................                else if(Data_ByteCount == 0x02) 
28D4:  BRA    2A98
28D6:  MOVLB  5
28D8:  MOVF   x7E,W
28DA:  SUBLW  02
28DC:  BTFSS  FD8.2
28DE:  BRA    2A9A
....................                { 
....................  
....................                   Data_Buff[0] = Input1_8 >> Start_Address ; 
28E0:  MOVFF  46,57F
28E4:  MOVF   x7A,W
28E6:  MOVWF  01
28E8:  BZ    28F2
28EA:  BCF    FD8.0
28EC:  RRCF   x7F,F
28EE:  DECFSZ 01,F
28F0:  BRA    28EA
....................                   Data_Buff[1] = Input9_16 ;// >> Start_Address ; 
28F2:  MOVFF  47,580
....................  
....................  
....................                   if((No_PointCount - 0x07) == 0x08) 
28F6:  MOVLW  07
28F8:  SUBWF  x7C,W
28FA:  MOVLB  8
28FC:  MOVWF  x79
28FE:  MOVLW  00
2900:  MOVLB  5
2902:  SUBWFB x7D,W
2904:  MOVLB  8
2906:  MOVWF  x7A
2908:  MOVF   x79,W
290A:  SUBLW  08
290C:  BNZ   2914
290E:  MOVF   x7A,F
2910:  BNZ   2914
....................                   { 
....................                      Data_Buff[1] = Data_Buff[1] & 0xFF ; //16 Point High Byte 
....................                   } 
....................                   else if((No_PointCount - 0x07) == 0x07) 
2912:  BRA    2A1A
2914:  MOVLW  07
2916:  MOVLB  5
2918:  SUBWF  x7C,W
291A:  MOVLB  8
291C:  MOVWF  x79
291E:  MOVLW  00
2920:  MOVLB  5
2922:  SUBWFB x7D,W
2924:  MOVLB  8
2926:  MOVWF  x7A
2928:  MOVF   x79,W
292A:  SUBLW  07
292C:  BNZ   2938
292E:  MOVF   x7A,F
2930:  BNZ   2938
....................                   { 
....................                      Data_Buff[1] =    Data_Buff[1] & 0x7F ; //15 Point High Byte 
2932:  MOVLB  5
2934:  BCF    x80.7
....................                   } 
....................                   else if((No_PointCount - 0x07) == 0x06) 
2936:  BRA    2A18
2938:  MOVLW  07
293A:  MOVLB  5
293C:  SUBWF  x7C,W
293E:  MOVLB  8
2940:  MOVWF  x79
2942:  MOVLW  00
2944:  MOVLB  5
2946:  SUBWFB x7D,W
2948:  MOVLB  8
294A:  MOVWF  x7A
294C:  MOVF   x79,W
294E:  SUBLW  06
2950:  BNZ   295E
2952:  MOVF   x7A,F
2954:  BNZ   295E
....................                   { 
....................                      Data_Buff[1] =    Data_Buff[1] & 0x3F ; //14 Point High Byte 
2956:  MOVLW  3F
2958:  MOVLB  5
295A:  ANDWF  x80,F
....................                   } 
....................                   else if((No_PointCount - 0x07) == 0x05) 
295C:  BRA    2A18
295E:  MOVLW  07
2960:  MOVLB  5
2962:  SUBWF  x7C,W
2964:  MOVLB  8
2966:  MOVWF  x79
2968:  MOVLW  00
296A:  MOVLB  5
296C:  SUBWFB x7D,W
296E:  MOVLB  8
2970:  MOVWF  x7A
2972:  MOVF   x79,W
2974:  SUBLW  05
2976:  BNZ   2984
2978:  MOVF   x7A,F
297A:  BNZ   2984
....................                   { 
....................                      Data_Buff[1] =    Data_Buff[1] & 0x1F ; //13 Point High Byte 
297C:  MOVLW  1F
297E:  MOVLB  5
2980:  ANDWF  x80,F
....................                   } 
....................                   else if((No_PointCount - 0x07) == 0x04) 
2982:  BRA    2A18
2984:  MOVLW  07
2986:  MOVLB  5
2988:  SUBWF  x7C,W
298A:  MOVLB  8
298C:  MOVWF  x79
298E:  MOVLW  00
2990:  MOVLB  5
2992:  SUBWFB x7D,W
2994:  MOVLB  8
2996:  MOVWF  x7A
2998:  MOVF   x79,W
299A:  SUBLW  04
299C:  BNZ   29AA
299E:  MOVF   x7A,F
29A0:  BNZ   29AA
....................                   { 
....................                      Data_Buff[1] =    Data_Buff[1] & 0x0F ; //12 Point High Byte 
29A2:  MOVLW  0F
29A4:  MOVLB  5
29A6:  ANDWF  x80,F
....................                   } 
....................                   else if((No_PointCount - 0x07) == 0x03) 
29A8:  BRA    2A18
29AA:  MOVLW  07
29AC:  MOVLB  5
29AE:  SUBWF  x7C,W
29B0:  MOVLB  8
29B2:  MOVWF  x79
29B4:  MOVLW  00
29B6:  MOVLB  5
29B8:  SUBWFB x7D,W
29BA:  MOVLB  8
29BC:  MOVWF  x7A
29BE:  MOVF   x79,W
29C0:  SUBLW  03
29C2:  BNZ   29D0
29C4:  MOVF   x7A,F
29C6:  BNZ   29D0
....................                   { 
....................                      Data_Buff[1] =    Data_Buff[1] & 0x07 ; //11 Point High Byte 
29C8:  MOVLW  07
29CA:  MOVLB  5
29CC:  ANDWF  x80,F
....................                   } 
....................                   else if((No_PointCount - 0x07) == 0x02) 
29CE:  BRA    2A18
29D0:  MOVLW  07
29D2:  MOVLB  5
29D4:  SUBWF  x7C,W
29D6:  MOVLB  8
29D8:  MOVWF  x79
29DA:  MOVLW  00
29DC:  MOVLB  5
29DE:  SUBWFB x7D,W
29E0:  MOVLB  8
29E2:  MOVWF  x7A
29E4:  MOVF   x79,W
29E6:  SUBLW  02
29E8:  BNZ   29F6
29EA:  MOVF   x7A,F
29EC:  BNZ   29F6
....................                   { 
....................                      Data_Buff[1] =    Data_Buff[1] & 0x03 ; //10 Point High Byte 
29EE:  MOVLW  03
29F0:  MOVLB  5
29F2:  ANDWF  x80,F
....................                   } 
....................                   else if((No_PointCount - 0x07) == 0x01) 
29F4:  BRA    2A18
29F6:  MOVLW  07
29F8:  MOVLB  5
29FA:  SUBWF  x7C,W
29FC:  MOVLB  8
29FE:  MOVWF  x79
2A00:  MOVLW  00
2A02:  MOVLB  5
2A04:  SUBWFB x7D,W
2A06:  MOVLB  8
2A08:  MOVWF  x7A
2A0A:  DECFSZ x79,W
2A0C:  BRA    2A1A
2A0E:  MOVF   x7A,F
2A10:  BNZ   2A1A
....................                   { 
....................                      Data_Buff[1] =    Data_Buff[1] & 0x01 ; //9 Point High Byte 
2A12:  MOVLW  01
2A14:  MOVLB  5
2A16:  ANDWF  x80,F
2A18:  MOVLB  8
....................                   } 
....................  
....................                   TxD_Buff[0] = Address ;         //Address 
2A1A:  MOVFF  75,77
....................                   TxD_Buff[1] = 0x01 ;         //Function Code 
2A1E:  MOVLW  01
2A20:  MOVWF  78
....................                   TxD_Buff[2] = Data_ByteCount ;   //Byte Count 
2A22:  MOVFF  57E,79
....................                   TxD_Buff[3] = Data_Buff[0] ;      //first byte Data 
2A26:  MOVFF  57F,7A
....................                   TxD_Buff[4] = Data_Buff[1] ;      //second byte Data 
2A2A:  MOVFF  580,7B
....................  
....................                   CRC(TxD_Buff,5)   ;            //Cal CRC 5 Byte 
2A2E:  CLRF   x7B
2A30:  MOVLW  77
2A32:  MOVWF  x7A
2A34:  MOVLW  05
2A36:  MOVWF  x7C
2A38:  MOVLB  0
2A3A:  CALL   1F56
....................  
....................                   TxD_Buff[5] = CRC_Hi ; 
2A3E:  MOVFF  577,7C
....................                   TxD_Buff[6] = CRC_Lo ; 
2A42:  MOVFF  576,7D
....................  
....................  
....................                   output_bit(P485ctrl,1); 
2A46:  BSF    F8A.3
2A48:  BCF    F93.3
....................                   restart_wdt(); 
2A4A:  CLRWDT
....................                   delay_ms(4); 
2A4C:  MOVLW  04
2A4E:  MOVLB  8
2A50:  MOVWF  x79
2A52:  MOVLB  0
2A54:  CALL   0772
....................                   restart_wdt(); 
2A58:  CLRWDT
....................  
....................                   putc(TxD_Buff[0]) ;               //Address 
2A5A:  MOVF   77,W
2A5C:  CALL   1F4C
....................                   putc(TxD_Buff[1]) ;               //Function Code 
2A60:  MOVF   78,W
2A62:  CALL   1F4C
....................                   putc(TxD_Buff[2]) ;               //Byte Count 
2A66:  MOVF   79,W
2A68:  CALL   1F4C
....................                   putc(TxD_Buff[3]) ; 
2A6C:  MOVF   7A,W
2A6E:  CALL   1F4C
....................                   putc(TxD_Buff[4]) ; 
2A72:  MOVF   7B,W
2A74:  CALL   1F4C
....................                   putc(TxD_Buff[5]) ; 
2A78:  MOVF   7C,W
2A7A:  CALL   1F4C
....................                   putc(TxD_Buff[6]) ; 
2A7E:  MOVF   7D,W
2A80:  CALL   1F4C
....................  
....................  
....................                   restart_wdt(); 
2A84:  CLRWDT
....................                   delay_ms(3); 
2A86:  MOVLW  03
2A88:  MOVLB  8
2A8A:  MOVWF  x79
2A8C:  MOVLB  0
2A8E:  CALL   0772
....................                   restart_wdt(); 
2A92:  CLRWDT
....................                   output_bit(P485ctrl,0); 
2A94:  BCF    F8A.3
2A96:  BCF    F93.3
2A98:  MOVLB  5
....................                
....................                } 
....................             } 
....................             else 
2A9A:  BRA    2B0A
....................             { 
....................                //invalid parameter 
....................                TxD_Buff[0] = Address ;         //Address 
2A9C:  MOVFF  75,77
....................                TxD_Buff[1] = 0x81 ;         //Function Code 
2AA0:  MOVLW  81
2AA2:  MOVWF  78
....................                TxD_Buff[2] = 0x02 ;         //illegal data address 
2AA4:  MOVLW  02
2AA6:  MOVWF  79
....................  
....................                CRC(TxD_Buff,3)   ;            //Cal CRC 3 Byte 
2AA8:  MOVLB  8
2AAA:  CLRF   x7B
2AAC:  MOVLW  77
2AAE:  MOVWF  x7A
2AB0:  MOVLW  03
2AB2:  MOVWF  x7C
2AB4:  MOVLB  0
2AB6:  CALL   1F56
....................  
....................                TxD_Buff[3] = CRC_Hi ; 
2ABA:  MOVFF  577,7A
....................                TxD_Buff[4] = CRC_Lo ; 
2ABE:  MOVFF  576,7B
....................  
....................                output_bit(P485ctrl,1); 
2AC2:  BSF    F8A.3
2AC4:  BCF    F93.3
....................                restart_wdt(); 
2AC6:  CLRWDT
....................                delay_ms(4); 
2AC8:  MOVLW  04
2ACA:  MOVLB  8
2ACC:  MOVWF  x79
2ACE:  MOVLB  0
2AD0:  CALL   0772
....................                restart_wdt(); 
2AD4:  CLRWDT
....................  
....................                putc(TxD_Buff[0]) ;               //Address 
2AD6:  MOVF   77,W
2AD8:  CALL   1F4C
....................                putc(TxD_Buff[1]) ;               //Function Code 
2ADC:  MOVF   78,W
2ADE:  CALL   1F4C
....................                putc(TxD_Buff[2]) ;               //Byte Count 
2AE2:  MOVF   79,W
2AE4:  CALL   1F4C
....................                putc(TxD_Buff[3]) ; 
2AE8:  MOVF   7A,W
2AEA:  CALL   1F4C
....................                putc(TxD_Buff[4]) ; 
2AEE:  MOVF   7B,W
2AF0:  CALL   1F4C
....................  
....................  
....................                restart_wdt(); 
2AF4:  CLRWDT
....................                delay_ms(3); 
2AF6:  MOVLW  03
2AF8:  MOVLB  8
2AFA:  MOVWF  x79
2AFC:  MOVLB  0
2AFE:  CALL   0772
....................                restart_wdt(); 
2B02:  CLRWDT
....................                output_bit(P485ctrl,0); 
2B04:  BCF    F8A.3
2B06:  BCF    F93.3
2B08:  MOVLB  5
2B0A:  MOVLB  1
....................                 
....................             } 
....................          } 
.................... ////\*/ 
....................  
....................  
....................                  /*-------------jack----*/ 
....................   
....................       if(RxD_Buff[1] == 0x07)///////////// READ COIL (esp code)//////////// 
2B0C:  MOVF   x77,W
2B0E:  SUBLW  07
2B10:  BTFSS  FD8.2
2B12:  BRA    2C76
....................       { 
....................          alarmtosend(); 
2B14:  MOVLB  0
2B16:  GOTO   1FC6
....................           
....................          disable_interrupts(INT_TIMER2); 
2B1A:  BCF    F9D.1
....................          //----------------------------------jj----------------------------// 
....................           
....................             Data_Buff[0] = Input1_8_Send ; //>> Start_Address ; 
2B1C:  MOVFF  1B,57F
....................             Data_Buff[1] = Input9_16_Send ;// >> Start_Address ; 
2B20:  MOVFF  1C,580
....................             Data_Buff[2] = Input17_24_Send ;// >> Start_Address ; 
2B24:  MOVFF  1D,581
....................             Data_Buff[3] = Input25_32_Send ; 
2B28:  MOVFF  1E,582
....................             Data_Buff[4] = Input33_40_Send ; 
2B2C:  MOVFF  1F,583
....................             Data_Buff[5] = Input41_48_Send ; 
2B30:  MOVFF  20,584
....................             Data_Buff[6] = Input49_56_Send ; 
2B34:  MOVFF  21,585
....................             Data_Buff[7] = Input57_64_Send ; 
2B38:  MOVFF  22,586
....................             
....................             Data_Buff[8] = Ack1_8_Send ; 
2B3C:  MOVFF  23,587
....................             Data_Buff[9] = Ack9_16_Send ; 
2B40:  MOVFF  24,588
....................             Data_Buff[10] = Ack17_24_Send ; 
2B44:  MOVFF  25,589
....................             Data_Buff[11] = Ack25_32_Send ; 
2B48:  MOVFF  26,58A
....................             Data_Buff[12] = Ack33_40_Send ; 
2B4C:  MOVFF  27,58B
....................             Data_Buff[13] = Ack41_48_Send ; 
2B50:  MOVFF  28,58C
....................             Data_Buff[14] = Ack49_56_Send ; 
2B54:  MOVFF  29,58D
....................             Data_Buff[15] = Ack57_64_Send ; 
2B58:  MOVFF  2A,58E
....................     
....................              
....................              
....................             TxD_Buff[0] = Address ;         //Address 
2B5C:  MOVFF  75,77
....................             TxD_Buff[1] = 0x07 ;         //Function Code 
2B60:  MOVLW  07
2B62:  MOVWF  78
....................             TxD_Buff[2] = Data_ByteCount=0x10;   //Byte Count 
2B64:  MOVLW  10
2B66:  MOVLB  5
2B68:  MOVWF  x7E
2B6A:  MOVFF  57E,79
....................             TxD_Buff[3] = Data_Buff[0] ;      //first byte Data 
2B6E:  MOVFF  57F,7A
....................             TxD_Buff[4] = Data_Buff[1] ;      //second byte Data 
2B72:  MOVFF  580,7B
....................             TxD_Buff[5] = Data_Buff[2] ;   
2B76:  MOVFF  581,7C
....................             TxD_Buff[6] = Data_Buff[3] ; 
2B7A:  MOVFF  582,7D
....................             TxD_Buff[7] = Data_Buff[4] ; 
2B7E:  MOVFF  583,7E
....................             TxD_Buff[8] = Data_Buff[5] ; 
2B82:  MOVFF  584,7F
....................             TxD_Buff[9] = Data_Buff[6] ; 
2B86:  MOVFF  585,80
....................             TxD_Buff[10] = Data_Buff[7] ; 
2B8A:  MOVFF  586,81
....................                
....................            TxD_Buff[11] = Data_Buff[8] ; //Ack1-8 
2B8E:  MOVFF  587,82
....................            TxD_Buff[12] = Data_Buff[9] ; 
2B92:  MOVFF  588,83
....................            TxD_Buff[13] = Data_Buff[10] ; 
2B96:  MOVFF  589,84
....................            TxD_Buff[14] = Data_Buff[11] ; 
2B9A:  MOVFF  58A,85
....................            TxD_Buff[15] = Data_Buff[12] ; 
2B9E:  MOVFF  58B,86
....................            TxD_Buff[16] = Data_Buff[13] ; 
2BA2:  MOVFF  58C,87
....................            TxD_Buff[17] = Data_Buff[14] ; 
2BA6:  MOVFF  58D,88
....................            TxD_Buff[18] = Data_Buff[15] ; //Ack57-64 
2BAA:  MOVFF  58E,89
....................  
....................            CRC(TxD_Buff,19);            //Cal CRC 5 Byte 
2BAE:  MOVLB  8
2BB0:  CLRF   x7B
2BB2:  MOVLW  77
2BB4:  MOVWF  x7A
2BB6:  MOVLW  13
2BB8:  MOVWF  x7C
2BBA:  MOVLB  0
2BBC:  CALL   1F56
....................  
....................           TxD_Buff[19] = CRC_Hi ; 
2BC0:  MOVFF  577,8A
....................           TxD_Buff[20] = CRC_Lo ; 
2BC4:  MOVFF  576,8B
....................  
....................          
....................          output_bit(P485ctrl,1); 
2BC8:  BSF    F8A.3
2BCA:  BCF    F93.3
....................          restart_wdt(); 
2BCC:  CLRWDT
....................          delay_ms(4); 
2BCE:  MOVLW  04
2BD0:  MOVLB  8
2BD2:  MOVWF  x79
2BD4:  MOVLB  0
2BD6:  CALL   0772
....................          restart_wdt(); 
2BDA:  CLRWDT
....................           
....................           
....................           
....................          putc(TxD_Buff[0]) ;               //Address 
2BDC:  MOVF   77,W
2BDE:  CALL   1F4C
....................          putc(TxD_Buff[1]) ;               //Function Code 
2BE2:  MOVF   78,W
2BE4:  CALL   1F4C
....................          putc(TxD_Buff[2]) ;               //Byte Count 
2BE8:  MOVF   79,W
2BEA:  CALL   1F4C
....................          putc(TxD_Buff[3]) ; 
2BEE:  MOVF   7A,W
2BF0:  CALL   1F4C
....................          putc(TxD_Buff[4]) ; 
2BF4:  MOVF   7B,W
2BF6:  CALL   1F4C
....................          putc(TxD_Buff[5]) ; 
2BFA:  MOVF   7C,W
2BFC:  CALL   1F4C
....................          putc(TxD_Buff[6]) ; 
2C00:  MOVF   7D,W
2C02:  CALL   1F4C
....................          putc(TxD_Buff[7]) ; 
2C06:  MOVF   7E,W
2C08:  CALL   1F4C
....................          putc(TxD_Buff[8]) ; 
2C0C:  MOVF   7F,W
2C0E:  CALL   1F4C
....................          putc(TxD_Buff[9]) ; 
2C12:  MOVF   x80,W
2C14:  CALL   1F4C
....................          putc(TxD_Buff[10]) ; 
2C18:  MOVF   x81,W
2C1A:  CALL   1F4C
....................          putc(TxD_Buff[11]) ; 
2C1E:  MOVF   x82,W
2C20:  CALL   1F4C
....................          putc(TxD_Buff[12]) ; 
2C24:  MOVF   x83,W
2C26:  CALL   1F4C
....................          putc(TxD_Buff[13]) ; 
2C2A:  MOVF   x84,W
2C2C:  CALL   1F4C
....................          putc(TxD_Buff[14]) ; 
2C30:  MOVF   x85,W
2C32:  CALL   1F4C
....................          putc(TxD_Buff[15]) ; 
2C36:  MOVF   x86,W
2C38:  CALL   1F4C
....................          putc(TxD_Buff[16]) ; 
2C3C:  MOVF   x87,W
2C3E:  CALL   1F4C
....................          putc(TxD_Buff[17]) ; 
2C42:  MOVF   x88,W
2C44:  CALL   1F4C
....................          putc(TxD_Buff[18]) ; 
2C48:  MOVF   x89,W
2C4A:  CALL   1F4C
....................          putc(TxD_Buff[19]) ; 
2C4E:  MOVF   x8A,W
2C50:  CALL   1F4C
....................          putc(TxD_Buff[20]) ; 
2C54:  MOVF   x8B,W
2C56:  CALL   1F4C
....................  
....................          restart_wdt(); 
2C5A:  CLRWDT
....................          delay_ms(3); 
2C5C:  MOVLW  03
2C5E:  MOVLB  8
2C60:  MOVWF  x79
2C62:  MOVLB  0
2C64:  CALL   0772
....................          restart_wdt(); 
2C68:  CLRWDT
....................          output_bit(P485ctrl,0); 
2C6A:  BCF    F8A.3
2C6C:  BCF    F93.3
....................             
....................          ///////////////////////////////////////// 
....................           
....................         enable_interrupts(INT_TIMER2);  
2C6E:  BSF    F9D.1
....................       
....................        } 
....................       ///////////////////////////////////////////////////////////////// 
....................  
....................        else if(RxD_Buff[1] == 0x05)///////////// FORCE COIL ///////////////////// 
2C70:  GOTO   43C0
2C74:  MOVLB  1
2C76:  MOVF   x77,W
2C78:  SUBLW  05
2C7A:  BTFSS  FD8.2
2C7C:  BRA    3168
....................          { 
....................             //Do Force Coil 
....................             Start_Address = RxD_Buff[2] ; 
2C7E:  MOVLB  5
2C80:  CLRF   x7B
2C82:  MOVFF  178,57A
....................             Start_Address = (Start_Address << 8) | RxD_Buff[3] ;   //Coil Address 16 bit 
2C86:  MOVFF  57A,87A
2C8A:  MOVLB  8
2C8C:  CLRF   x79
2C8E:  MOVF   x79,W
2C90:  MOVLB  1
2C92:  IORWF  x79,W
2C94:  MOVLB  5
2C96:  MOVWF  x7A
2C98:  MOVFF  87A,57B
2C9C:  MOVLB  5
....................             No_PointCount = RxD_Buff[4] ; 
2C9E:  CLRF   x7D
2CA0:  MOVFF  17A,57C
....................             No_PointCount = (No_PointCount << 8) | RxD_Buff[5] ;   //Force Data 16 bit FF00 = ON, 00FF = OFF 
2CA4:  MOVFF  57C,87A
2CA8:  MOVLB  8
2CAA:  CLRF   x79
2CAC:  MOVF   x79,W
2CAE:  MOVLB  1
2CB0:  IORWF  x7B,W
2CB2:  MOVLB  5
2CB4:  MOVWF  x7C
2CB6:  MOVFF  87A,57D
2CBA:  MOVLB  5
....................  
....................             if(Start_Address == 0x00)   ////// Acknowlegde ////// 
2CBC:  MOVF   x7A,F
2CBE:  BNZ   2D5C
2CC0:  MOVF   x7B,F
2CC2:  BNZ   2D5C
....................             { 
....................                if(No_PointCount == 0xFF00)   //ON 
2CC4:  MOVF   x7C,F
2CC6:  BNZ   2D5A
2CC8:  INCFSZ x7D,W
2CCA:  BRA    2D5A
....................                { 
....................                   //Modbus_ACK = 1 ; 
....................                   AutoAckFlag = 1; 
2CCC:  BSF    17.2
....................  
....................                   TxD_Buff[0] = Address ;         //Address 
2CCE:  MOVFF  75,77
....................                   TxD_Buff[1] = 0x05 ;         //Function Code 
2CD2:  MOVLW  05
2CD4:  MOVWF  78
....................                   TxD_Buff[2] = RxD_Buff[2] ;      //Coil Address Hi 
2CD6:  MOVFF  178,79
....................                   TxD_Buff[3] = RxD_Buff[3] ;      //Coil Address Lo 
2CDA:  MOVFF  179,7A
....................                   TxD_Buff[4] = RxD_Buff[4] ;      //Force Data Hi 
2CDE:  MOVFF  17A,7B
....................                   TxD_Buff[5] = RxD_Buff[5] ;      //Force Data Lo 
2CE2:  MOVFF  17B,7C
....................  
....................                   CRC(TxD_Buff,6)   ;            //Cal CRC 6 Byte 
2CE6:  MOVLB  8
2CE8:  CLRF   x7B
2CEA:  MOVLW  77
2CEC:  MOVWF  x7A
2CEE:  MOVLW  06
2CF0:  MOVWF  x7C
2CF2:  MOVLB  0
2CF4:  CALL   1F56
....................  
....................                   TxD_Buff[6] = CRC_Hi ; 
2CF8:  MOVFF  577,7D
....................                   TxD_Buff[7] = CRC_Lo ; 
2CFC:  MOVFF  576,7E
....................  
....................                   output_bit(P485ctrl,1); 
2D00:  BSF    F8A.3
2D02:  BCF    F93.3
....................                   restart_wdt(); 
2D04:  CLRWDT
....................                   delay_ms(4); 
2D06:  MOVLW  04
2D08:  MOVLB  8
2D0A:  MOVWF  x79
2D0C:  MOVLB  0
2D0E:  CALL   0772
....................                   restart_wdt(); 
2D12:  CLRWDT
....................  
....................                   putc(TxD_Buff[0]) ;               //Address 
2D14:  MOVF   77,W
2D16:  CALL   1F4C
....................                   putc(TxD_Buff[1]) ;               //Function Code 
2D1A:  MOVF   78,W
2D1C:  CALL   1F4C
....................                   putc(TxD_Buff[2]) ;               //Byte Count 
2D20:  MOVF   79,W
2D22:  CALL   1F4C
....................                   putc(TxD_Buff[3]) ; 
2D26:  MOVF   7A,W
2D28:  CALL   1F4C
....................                   putc(TxD_Buff[4]) ; 
2D2C:  MOVF   7B,W
2D2E:  CALL   1F4C
....................                   putc(TxD_Buff[5]) ; 
2D32:  MOVF   7C,W
2D34:  CALL   1F4C
....................                   putc(TxD_Buff[6]) ; 
2D38:  MOVF   7D,W
2D3A:  CALL   1F4C
....................                   putc(TxD_Buff[7]) ; 
2D3E:  MOVF   7E,W
2D40:  CALL   1F4C
....................  
....................  
....................                   restart_wdt(); 
2D44:  CLRWDT
....................                   delay_ms(3); 
2D46:  MOVLW  03
2D48:  MOVLB  8
2D4A:  MOVWF  x79
2D4C:  MOVLB  0
2D4E:  CALL   0772
....................                   restart_wdt(); 
2D52:  CLRWDT
....................                   output_bit(P485ctrl,0); 
2D54:  BCF    F8A.3
2D56:  BCF    F93.3
2D58:  MOVLB  5
....................                
....................                } 
....................             } 
....................             else if(Start_Address == 0x01)   ///// Reset ////// 
2D5A:  BRA    3162
2D5C:  DECFSZ x7A,W
2D5E:  BRA    2DFC
2D60:  MOVF   x7B,F
2D62:  BNZ   2DFC
....................             { 
....................                if(No_PointCount == 0xFF00)   //ON 
2D64:  MOVF   x7C,F
2D66:  BNZ   2DFA
2D68:  INCFSZ x7D,W
2D6A:  BRA    2DFA
....................                { 
....................                   //Modbus_RET = 1 ; 
....................                   AutoResetFlag = 1; 
2D6C:  BSF    17.3
....................                    
....................                   TxD_Buff[0] = Address ;         //Address 
2D6E:  MOVFF  75,77
....................                   TxD_Buff[1] = 0x05 ;         //Function Code 
2D72:  MOVLW  05
2D74:  MOVWF  78
....................                   TxD_Buff[2] = RxD_Buff[2] ;      //Coil Address Hi 
2D76:  MOVFF  178,79
....................                   TxD_Buff[3] = RxD_Buff[3] ;      //Coil Address Lo 
2D7A:  MOVFF  179,7A
....................                   TxD_Buff[4] = RxD_Buff[4] ;      //Force Data Hi 
2D7E:  MOVFF  17A,7B
....................                   TxD_Buff[5] = RxD_Buff[5] ;      //Force Data Lo 
2D82:  MOVFF  17B,7C
....................  
....................                   CRC(TxD_Buff,6)   ;            //Cal CRC 6 Byte 
2D86:  MOVLB  8
2D88:  CLRF   x7B
2D8A:  MOVLW  77
2D8C:  MOVWF  x7A
2D8E:  MOVLW  06
2D90:  MOVWF  x7C
2D92:  MOVLB  0
2D94:  CALL   1F56
....................  
....................                   TxD_Buff[6] = CRC_Hi ; 
2D98:  MOVFF  577,7D
....................                   TxD_Buff[7] = CRC_Lo ; 
2D9C:  MOVFF  576,7E
....................  
....................  
....................               output_bit(P485ctrl,1); 
2DA0:  BSF    F8A.3
2DA2:  BCF    F93.3
....................                   restart_wdt(); 
2DA4:  CLRWDT
....................                   delay_ms(4); 
2DA6:  MOVLW  04
2DA8:  MOVLB  8
2DAA:  MOVWF  x79
2DAC:  MOVLB  0
2DAE:  CALL   0772
....................                   restart_wdt(); 
2DB2:  CLRWDT
....................  
....................                   putc(TxD_Buff[0]) ;               //Address 
2DB4:  MOVF   77,W
2DB6:  CALL   1F4C
....................                   putc(TxD_Buff[1]) ;               //Function Code 
2DBA:  MOVF   78,W
2DBC:  CALL   1F4C
....................                   putc(TxD_Buff[2]) ;               //Byte Count 
2DC0:  MOVF   79,W
2DC2:  CALL   1F4C
....................                   putc(TxD_Buff[3]) ; 
2DC6:  MOVF   7A,W
2DC8:  CALL   1F4C
....................                   putc(TxD_Buff[4]) ; 
2DCC:  MOVF   7B,W
2DCE:  CALL   1F4C
....................                   putc(TxD_Buff[5]) ; 
2DD2:  MOVF   7C,W
2DD4:  CALL   1F4C
....................                   putc(TxD_Buff[6]) ; 
2DD8:  MOVF   7D,W
2DDA:  CALL   1F4C
....................                   putc(TxD_Buff[7]) ; 
2DDE:  MOVF   7E,W
2DE0:  CALL   1F4C
....................                   //putc(TxD_Buff[8]) ; 
....................                   //putc(TxD_Buff[9]) ; 
....................  
....................                   restart_wdt(); 
2DE4:  CLRWDT
....................                   delay_ms(3); 
2DE6:  MOVLW  03
2DE8:  MOVLB  8
2DEA:  MOVWF  x79
2DEC:  MOVLB  0
2DEE:  CALL   0772
....................                   restart_wdt(); 
2DF2:  CLRWDT
....................                   output_bit(P485ctrl,0); 
2DF4:  BCF    F8A.3
2DF6:  BCF    F93.3
2DF8:  MOVLB  5
....................                
....................                } 
....................             } 
....................             else if(Start_Address == 0x02)   ///// Test ////// 
2DFA:  BRA    3162
2DFC:  MOVF   x7A,W
2DFE:  SUBLW  02
2E00:  BTFSS  FD8.2
2E02:  BRA    2F4C
2E04:  MOVF   x7B,F
2E06:  BTFSS  FD8.2
2E08:  BRA    2F4C
....................             { 
....................                if(No_PointCount == 0xFF00)   //ON 
2E0A:  MOVF   x7C,F
2E0C:  BNZ   2EA2
2E0E:  INCFSZ x7D,W
2E10:  BRA    2EA2
....................                { 
....................                   //Modbus_Lamp_Test = 1 ; 
....................                   AutoTestFlag = 1; 
2E12:  BSF    17.4
....................  
....................                   TxD_Buff[0] = Address ;         //Address 
2E14:  MOVFF  75,77
....................                   TxD_Buff[1] = 0x05 ;         //Function Code 
2E18:  MOVLW  05
2E1A:  MOVWF  78
....................                   TxD_Buff[2] = RxD_Buff[2] ;      //Coil Address Hi 
2E1C:  MOVFF  178,79
....................                   TxD_Buff[3] = RxD_Buff[3] ;      //Coil Address Lo 
2E20:  MOVFF  179,7A
....................                   TxD_Buff[4] = RxD_Buff[4] ;      //Force Data Hi 
2E24:  MOVFF  17A,7B
....................                   TxD_Buff[5] = RxD_Buff[5] ;      //Force Data Lo 
2E28:  MOVFF  17B,7C
....................  
....................                   CRC(TxD_Buff,6)   ;            //Cal CRC 6 Byte 
2E2C:  MOVLB  8
2E2E:  CLRF   x7B
2E30:  MOVLW  77
2E32:  MOVWF  x7A
2E34:  MOVLW  06
2E36:  MOVWF  x7C
2E38:  MOVLB  0
2E3A:  CALL   1F56
....................  
....................                   TxD_Buff[6] = CRC_Hi ; 
2E3E:  MOVFF  577,7D
....................                   TxD_Buff[7] = CRC_Lo ; 
2E42:  MOVFF  576,7E
....................  
....................                   output_bit(P485ctrl,1); 
2E46:  BSF    F8A.3
2E48:  BCF    F93.3
....................                   restart_wdt(); 
2E4A:  CLRWDT
....................                   delay_ms(4); 
2E4C:  MOVLW  04
2E4E:  MOVLB  8
2E50:  MOVWF  x79
2E52:  MOVLB  0
2E54:  CALL   0772
....................                   restart_wdt(); 
2E58:  CLRWDT
....................  
....................                   putc(TxD_Buff[0]) ;               //Address 
2E5A:  MOVF   77,W
2E5C:  CALL   1F4C
....................                   putc(TxD_Buff[1]) ;               //Function Code 
2E60:  MOVF   78,W
2E62:  CALL   1F4C
....................                   putc(TxD_Buff[2]) ;               //Byte Count 
2E66:  MOVF   79,W
2E68:  CALL   1F4C
....................                   putc(TxD_Buff[3]) ; 
2E6C:  MOVF   7A,W
2E6E:  CALL   1F4C
....................                   putc(TxD_Buff[4]) ; 
2E72:  MOVF   7B,W
2E74:  CALL   1F4C
....................                   putc(TxD_Buff[5]) ; 
2E78:  MOVF   7C,W
2E7A:  CALL   1F4C
....................                   putc(TxD_Buff[6]) ; 
2E7E:  MOVF   7D,W
2E80:  CALL   1F4C
....................                   putc(TxD_Buff[7]) ; 
2E84:  MOVF   7E,W
2E86:  CALL   1F4C
....................  
....................                   restart_wdt(); 
2E8A:  CLRWDT
....................                   delay_ms(3); 
2E8C:  MOVLW  03
2E8E:  MOVLB  8
2E90:  MOVWF  x79
2E92:  MOVLB  0
2E94:  CALL   0772
....................                   restart_wdt(); 
2E98:  CLRWDT
....................                   output_bit(P485ctrl,0); 
2E9A:  BCF    F8A.3
2E9C:  BCF    F93.3
....................               
....................                } 
....................                else if(No_PointCount == 0x00)   //OFF 
2E9E:  BRA    2F48
2EA0:  MOVLB  5
2EA2:  MOVF   x7C,F
2EA4:  BNZ   2F4A
2EA6:  MOVF   x7D,F
2EA8:  BNZ   2F4A
....................                { 
....................                   //Modbus_Lamp_Test = 0 ; 
....................                   AutoTestFlag = 0; 
2EAA:  BCF    17.4
....................                   Read_input(); 
2EAC:  MOVLB  0
2EAE:  CALL   15B8
....................                   AutoAckFlag = 1; 
2EB2:  BSF    17.2
....................                   check_ack(); 
2EB4:  CALL   2170
....................                   AutoResetFlag = 1; 
2EB8:  BSF    17.3
....................                   check_reset(); 
2EBA:  CALL   2254
....................  
....................                   TxD_Buff[0] = Address ;         //Address 
2EBE:  MOVFF  75,77
....................                   TxD_Buff[1] = 0x05 ;         //Function Code 
2EC2:  MOVLW  05
2EC4:  MOVWF  78
....................                   TxD_Buff[2] = RxD_Buff[2] ;      //Coil Address Hi 
2EC6:  MOVFF  178,79
....................                   TxD_Buff[3] = RxD_Buff[3] ;      //Coil Address Lo 
2ECA:  MOVFF  179,7A
....................                   TxD_Buff[4] = RxD_Buff[4] ;      //Force Data Hi 
2ECE:  MOVFF  17A,7B
....................                   TxD_Buff[5] = RxD_Buff[5] ;      //Force Data Lo 
2ED2:  MOVFF  17B,7C
....................  
....................                   CRC(TxD_Buff,6)   ;            //Cal CRC 6 Byte 
2ED6:  MOVLB  8
2ED8:  CLRF   x7B
2EDA:  MOVLW  77
2EDC:  MOVWF  x7A
2EDE:  MOVLW  06
2EE0:  MOVWF  x7C
2EE2:  MOVLB  0
2EE4:  CALL   1F56
....................  
....................                   TxD_Buff[6] = CRC_Hi ; 
2EE8:  MOVFF  577,7D
....................                   TxD_Buff[7] = CRC_Lo ; 
2EEC:  MOVFF  576,7E
....................  
....................                   output_bit(P485ctrl,1); 
2EF0:  BSF    F8A.3
2EF2:  BCF    F93.3
....................                   restart_wdt(); 
2EF4:  CLRWDT
....................                   delay_ms(4); 
2EF6:  MOVLW  04
2EF8:  MOVLB  8
2EFA:  MOVWF  x79
2EFC:  MOVLB  0
2EFE:  CALL   0772
....................                   restart_wdt(); 
2F02:  CLRWDT
....................  
....................                   putc(TxD_Buff[0]) ;               //Address 
2F04:  MOVF   77,W
2F06:  CALL   1F4C
....................                   putc(TxD_Buff[1]) ;               //Function Code 
2F0A:  MOVF   78,W
2F0C:  CALL   1F4C
....................                   putc(TxD_Buff[2]) ;               //Byte Count 
2F10:  MOVF   79,W
2F12:  CALL   1F4C
....................                   putc(TxD_Buff[3]) ; 
2F16:  MOVF   7A,W
2F18:  CALL   1F4C
....................                   putc(TxD_Buff[4]) ; 
2F1C:  MOVF   7B,W
2F1E:  CALL   1F4C
....................                   putc(TxD_Buff[5]) ; 
2F22:  MOVF   7C,W
2F24:  CALL   1F4C
....................                   putc(TxD_Buff[6]) ; 
2F28:  MOVF   7D,W
2F2A:  CALL   1F4C
....................                   putc(TxD_Buff[7]) ; 
2F2E:  MOVF   7E,W
2F30:  CALL   1F4C
....................                   //putc(TxD_Buff[8]) ; 
....................                   //putc(TxD_Buff[9]) ; 
....................  
....................                   restart_wdt(); 
2F34:  CLRWDT
....................                   delay_ms(3); 
2F36:  MOVLW  03
2F38:  MOVLB  8
2F3A:  MOVWF  x79
2F3C:  MOVLB  0
2F3E:  CALL   0772
....................                   restart_wdt(); 
2F42:  CLRWDT
....................                   output_bit(P485ctrl,0); 
2F44:  BCF    F8A.3
2F46:  BCF    F93.3
2F48:  MOVLB  5
....................                    
....................                } 
....................             } 
....................             else if(Start_Address == 0x03)   ///// Function Test ////// 
2F4A:  BRA    3162
2F4C:  MOVF   x7A,W
2F4E:  SUBLW  03
2F50:  BTFSS  FD8.2
2F52:  BRA    309C
2F54:  MOVF   x7B,F
2F56:  BTFSS  FD8.2
2F58:  BRA    309C
....................             { 
....................                if(No_PointCount == 0xFF00)   //ON 
2F5A:  MOVF   x7C,F
2F5C:  BNZ   2FF2
2F5E:  INCFSZ x7D,W
2F60:  BRA    2FF2
....................                { 
....................                   //Modbus_Lamp_Test = 1 ; 
....................                   test_fault = 1 ; 
2F62:  BSF    17.5
....................  
....................                   TxD_Buff[0] = Address ;         //Address 
2F64:  MOVFF  75,77
....................                   TxD_Buff[1] = 0x05 ;         //Function Code 
2F68:  MOVLW  05
2F6A:  MOVWF  78
....................                   TxD_Buff[2] = RxD_Buff[2] ;      //Coil Address Hi 
2F6C:  MOVFF  178,79
....................                   TxD_Buff[3] = RxD_Buff[3] ;      //Coil Address Lo 
2F70:  MOVFF  179,7A
....................                   TxD_Buff[4] = RxD_Buff[4] ;      //Force Data Hi 
2F74:  MOVFF  17A,7B
....................                   TxD_Buff[5] = RxD_Buff[5] ;      //Force Data Lo 
2F78:  MOVFF  17B,7C
....................  
....................                   CRC(TxD_Buff,6)   ;            //Cal CRC 6 Byte 
2F7C:  MOVLB  8
2F7E:  CLRF   x7B
2F80:  MOVLW  77
2F82:  MOVWF  x7A
2F84:  MOVLW  06
2F86:  MOVWF  x7C
2F88:  MOVLB  0
2F8A:  CALL   1F56
....................  
....................                   TxD_Buff[6] = CRC_Hi ; 
2F8E:  MOVFF  577,7D
....................                   TxD_Buff[7] = CRC_Lo ; 
2F92:  MOVFF  576,7E
....................  
....................                  output_bit(P485ctrl,1); 
2F96:  BSF    F8A.3
2F98:  BCF    F93.3
....................                   restart_wdt(); 
2F9A:  CLRWDT
....................                   delay_ms(4); 
2F9C:  MOVLW  04
2F9E:  MOVLB  8
2FA0:  MOVWF  x79
2FA2:  MOVLB  0
2FA4:  CALL   0772
....................                   restart_wdt(); 
2FA8:  CLRWDT
....................  
....................                   putc(TxD_Buff[0]) ;               //Address 
2FAA:  MOVF   77,W
2FAC:  CALL   1F4C
....................                   putc(TxD_Buff[1]) ;               //Function Code 
2FB0:  MOVF   78,W
2FB2:  CALL   1F4C
....................                   putc(TxD_Buff[2]) ;               //Byte Count 
2FB6:  MOVF   79,W
2FB8:  CALL   1F4C
....................                   putc(TxD_Buff[3]) ; 
2FBC:  MOVF   7A,W
2FBE:  CALL   1F4C
....................                   putc(TxD_Buff[4]) ; 
2FC2:  MOVF   7B,W
2FC4:  CALL   1F4C
....................                   putc(TxD_Buff[5]) ; 
2FC8:  MOVF   7C,W
2FCA:  CALL   1F4C
....................                   putc(TxD_Buff[6]) ; 
2FCE:  MOVF   7D,W
2FD0:  CALL   1F4C
....................                   putc(TxD_Buff[7]) ; 
2FD4:  MOVF   7E,W
2FD6:  CALL   1F4C
....................                   //putc(TxD_Buff[8]) ; 
....................                   //putc(TxD_Buff[9]) ; 
....................  
....................                   restart_wdt(); 
2FDA:  CLRWDT
....................                   delay_ms(10); 
2FDC:  MOVLW  0A
2FDE:  MOVLB  8
2FE0:  MOVWF  x79
2FE2:  MOVLB  0
2FE4:  CALL   0772
....................                   restart_wdt(); 
2FE8:  CLRWDT
....................                   output_bit(P485ctrl,0); 
2FEA:  BCF    F8A.3
2FEC:  BCF    F93.3
....................                } 
....................                else if(No_PointCount == 0x00)   //OFF 
2FEE:  BRA    3098
2FF0:  MOVLB  5
2FF2:  MOVF   x7C,F
2FF4:  BNZ   309A
2FF6:  MOVF   x7D,F
2FF8:  BNZ   309A
....................                { 
....................                   //Modbus_Lamp_Test = 0 ; 
....................                   test_fault = 0; 
2FFA:  BCF    17.5
....................                   Read_input(); 
2FFC:  MOVLB  0
2FFE:  CALL   15B8
....................                   AutoAckFlag = 1; 
3002:  BSF    17.2
....................                   check_ack(); 
3004:  CALL   2170
....................                   AutoResetFlag = 1; 
3008:  BSF    17.3
....................                   check_reset(); 
300A:  CALL   2254
....................  
....................                   TxD_Buff[0] = Address ;         //Address 
300E:  MOVFF  75,77
....................                   TxD_Buff[1] = 0x05 ;         //Function Code 
3012:  MOVLW  05
3014:  MOVWF  78
....................                   TxD_Buff[2] = RxD_Buff[2] ;      //Coil Address Hi 
3016:  MOVFF  178,79
....................                   TxD_Buff[3] = RxD_Buff[3] ;      //Coil Address Lo 
301A:  MOVFF  179,7A
....................                   TxD_Buff[4] = RxD_Buff[4] ;      //Force Data Hi 
301E:  MOVFF  17A,7B
....................                   TxD_Buff[5] = RxD_Buff[5] ;      //Force Data Lo 
3022:  MOVFF  17B,7C
....................  
....................                   CRC(TxD_Buff,6)   ;            //Cal CRC 6 Byte 
3026:  MOVLB  8
3028:  CLRF   x7B
302A:  MOVLW  77
302C:  MOVWF  x7A
302E:  MOVLW  06
3030:  MOVWF  x7C
3032:  MOVLB  0
3034:  CALL   1F56
....................  
....................                   TxD_Buff[6] = CRC_Hi ; 
3038:  MOVFF  577,7D
....................                   TxD_Buff[7] = CRC_Lo ; 
303C:  MOVFF  576,7E
....................  
....................                   output_bit(P485ctrl,1); 
3040:  BSF    F8A.3
3042:  BCF    F93.3
....................                   restart_wdt(); 
3044:  CLRWDT
....................                   delay_ms(4); 
3046:  MOVLW  04
3048:  MOVLB  8
304A:  MOVWF  x79
304C:  MOVLB  0
304E:  CALL   0772
....................                   restart_wdt(); 
3052:  CLRWDT
....................  
....................                   putc(TxD_Buff[0]) ;               //Address 
3054:  MOVF   77,W
3056:  CALL   1F4C
....................                   putc(TxD_Buff[1]) ;               //Function Code 
305A:  MOVF   78,W
305C:  CALL   1F4C
....................                   putc(TxD_Buff[2]) ;               //Byte Count 
3060:  MOVF   79,W
3062:  CALL   1F4C
....................                   putc(TxD_Buff[3]) ; 
3066:  MOVF   7A,W
3068:  CALL   1F4C
....................                   putc(TxD_Buff[4]) ; 
306C:  MOVF   7B,W
306E:  CALL   1F4C
....................                   putc(TxD_Buff[5]) ; 
3072:  MOVF   7C,W
3074:  CALL   1F4C
....................                   putc(TxD_Buff[6]) ; 
3078:  MOVF   7D,W
307A:  CALL   1F4C
....................                   putc(TxD_Buff[7]) ; 
307E:  MOVF   7E,W
3080:  CALL   1F4C
....................                   //putc(TxD_Buff[8]) ; 
....................                   //putc(TxD_Buff[9]) ; 
....................  
....................                   restart_wdt(); 
3084:  CLRWDT
....................                   delay_ms(3); 
3086:  MOVLW  03
3088:  MOVLB  8
308A:  MOVWF  x79
308C:  MOVLB  0
308E:  CALL   0772
....................                   restart_wdt(); 
3092:  CLRWDT
....................                   output_bit(P485ctrl,0); 
3094:  BCF    F8A.3
3096:  BCF    F93.3
3098:  MOVLB  5
....................                    
....................                } 
....................             } 
....................             else if(Start_Address == 0x64)   ///// Change Modbus Addr ////// 
309A:  BRA    3162
309C:  MOVF   x7A,W
309E:  SUBLW  64
30A0:  BNZ   3162
30A2:  MOVF   x7B,F
30A4:  BNZ   3162
....................             { 
....................                Address = No_PointCount; 
30A6:  MOVFF  57C,75
....................                write_eeprom(0x1D,Address);   //Communication Address 
30AA:  CLRF   FAA
30AC:  MOVLW  1D
30AE:  MOVWF  FA9
30B0:  MOVFF  75,FA8
30B4:  BCF    FA6.6
30B6:  BCF    FA6.7
30B8:  BSF    FA6.2
30BA:  MOVF   FF2,W
30BC:  MOVWF  00
30BE:  BCF    FF2.7
30C0:  MOVLB  F
30C2:  MOVLW  55
30C4:  MOVWF  FA7
30C6:  MOVLW  AA
30C8:  MOVWF  FA7
30CA:  BSF    FA6.1
30CC:  BTFSC  FA6.1
30CE:  BRA    30CC
30D0:  BCF    FA6.2
30D2:  MOVF   00,W
30D4:  IORWF  FF2,F
....................                 
....................                TxD_Buff[0] = Address ;         //Address 
30D6:  MOVFF  75,77
....................                TxD_Buff[1] = 0x05 ;         //Function Code 
30DA:  MOVLW  05
30DC:  MOVWF  78
....................                TxD_Buff[2] = RxD_Buff[2] ;      //Coil Address Hi 
30DE:  MOVFF  178,79
....................                TxD_Buff[3] = RxD_Buff[3] ;      //Coil Address Lo 
30E2:  MOVFF  179,7A
....................                TxD_Buff[4] = RxD_Buff[4] ;      //Force Data Hi 
30E6:  MOVFF  17A,7B
....................                TxD_Buff[5] = RxD_Buff[5] ;      //Force Data Lo 
30EA:  MOVFF  17B,7C
....................  
....................                CRC(TxD_Buff,6)   ;            //Cal CRC 6 Byte 
30EE:  MOVLB  8
30F0:  CLRF   x7B
30F2:  MOVLW  77
30F4:  MOVWF  x7A
30F6:  MOVLW  06
30F8:  MOVWF  x7C
30FA:  MOVLB  0
30FC:  CALL   1F56
....................  
....................                TxD_Buff[6] = CRC_Hi ; 
3100:  MOVFF  577,7D
....................                TxD_Buff[7] = CRC_Lo ; 
3104:  MOVFF  576,7E
....................  
....................                output_bit(P485ctrl,1); 
3108:  BSF    F8A.3
310A:  BCF    F93.3
....................                restart_wdt(); 
310C:  CLRWDT
....................                delay_ms(4); 
310E:  MOVLW  04
3110:  MOVLB  8
3112:  MOVWF  x79
3114:  MOVLB  0
3116:  CALL   0772
....................                restart_wdt(); 
311A:  CLRWDT
....................  
....................                putc(TxD_Buff[0]) ;               //Address 
311C:  MOVF   77,W
311E:  CALL   1F4C
....................                putc(TxD_Buff[1]) ;               //Function Code 
3122:  MOVF   78,W
3124:  CALL   1F4C
....................                putc(TxD_Buff[2]) ;               //Byte Count 
3128:  MOVF   79,W
312A:  CALL   1F4C
....................                putc(TxD_Buff[3]) ; 
312E:  MOVF   7A,W
3130:  CALL   1F4C
....................                putc(TxD_Buff[4]) ; 
3134:  MOVF   7B,W
3136:  CALL   1F4C
....................                putc(TxD_Buff[5]) ; 
313A:  MOVF   7C,W
313C:  CALL   1F4C
....................                putc(TxD_Buff[6]) ; 
3140:  MOVF   7D,W
3142:  CALL   1F4C
....................                putc(TxD_Buff[7]) ; 
3146:  MOVF   7E,W
3148:  CALL   1F4C
....................                //putc(TxD_Buff[8]) ; 
....................                //putc(TxD_Buff[9]) ; 
....................  
....................                restart_wdt(); 
314C:  CLRWDT
....................                delay_ms(3); 
314E:  MOVLW  03
3150:  MOVLB  8
3152:  MOVWF  x79
3154:  MOVLB  0
3156:  CALL   0772
....................                restart_wdt(); 
315A:  CLRWDT
....................                output_bit(P485ctrl,0); 
315C:  BCF    F8A.3
315E:  BCF    F93.3
3160:  MOVLB  5
....................  
....................  
....................                //save_addr(); 
....................             } 
....................          } 
....................          //--------------------------------------------------// 
....................  
....................          else if(RxD_Buff[1] == 0x21)///////////// WRITE SETTING ///////////////////// 
3162:  GOTO   43C0
3166:  MOVLB  1
3168:  MOVF   x77,W
316A:  SUBLW  21
316C:  BTFSS  FD8.2
316E:  GOTO   3AD4
....................          { 
....................  
....................             write_eeprom(0x00,0x0F); 
3172:  CLRF   FAA
3174:  CLRF   FA9
3176:  MOVLW  0F
3178:  MOVWF  FA8
317A:  BCF    FA6.6
317C:  BCF    FA6.7
317E:  BSF    FA6.2
3180:  MOVF   FF2,W
3182:  MOVWF  00
3184:  BCF    FF2.7
3186:  MOVLB  F
3188:  MOVLW  55
318A:  MOVWF  FA7
318C:  MOVLW  AA
318E:  MOVWF  FA7
3190:  BSF    FA6.1
3192:  BTFSC  FA6.1
3194:  BRA    3192
3196:  BCF    FA6.2
3198:  MOVF   00,W
319A:  IORWF  FF2,F
....................  
....................             write_eeprom(0x01,RxD_Buff[3]);   //Input Type 
319C:  CLRF   FAA
319E:  MOVLW  01
31A0:  MOVWF  FA9
31A2:  MOVFF  179,FA8
31A6:  BCF    FA6.6
31A8:  BCF    FA6.7
31AA:  BSF    FA6.2
31AC:  MOVFF  FF2,00
31B0:  BCF    FF2.7
31B2:  MOVLW  55
31B4:  MOVWF  FA7
31B6:  MOVLW  AA
31B8:  MOVWF  FA7
31BA:  BSF    FA6.1
31BC:  BTFSC  FA6.1
31BE:  BRA    31BC
31C0:  BCF    FA6.2
31C2:  MOVF   00,W
31C4:  IORWF  FF2,F
....................             write_eeprom(0x02,RxD_Buff[4]); 
31C6:  CLRF   FAA
31C8:  MOVLW  02
31CA:  MOVWF  FA9
31CC:  MOVFF  17A,FA8
31D0:  BCF    FA6.6
31D2:  BCF    FA6.7
31D4:  BSF    FA6.2
31D6:  MOVFF  FF2,00
31DA:  BCF    FF2.7
31DC:  MOVLW  55
31DE:  MOVWF  FA7
31E0:  MOVLW  AA
31E2:  MOVWF  FA7
31E4:  BSF    FA6.1
31E6:  BTFSC  FA6.1
31E8:  BRA    31E6
31EA:  BCF    FA6.2
31EC:  MOVF   00,W
31EE:  IORWF  FF2,F
....................             write_eeprom(0x03,RxD_Buff[5]); 
31F0:  CLRF   FAA
31F2:  MOVLW  03
31F4:  MOVWF  FA9
31F6:  MOVFF  17B,FA8
31FA:  BCF    FA6.6
31FC:  BCF    FA6.7
31FE:  BSF    FA6.2
3200:  MOVFF  FF2,00
3204:  BCF    FF2.7
3206:  MOVLW  55
3208:  MOVWF  FA7
320A:  MOVLW  AA
320C:  MOVWF  FA7
320E:  BSF    FA6.1
3210:  BTFSC  FA6.1
3212:  BRA    3210
3214:  BCF    FA6.2
3216:  MOVF   00,W
3218:  IORWF  FF2,F
....................  
....................             write_eeprom(0x04,RxD_Buff[6]);   //Fault Type 
321A:  CLRF   FAA
321C:  MOVLW  04
321E:  MOVWF  FA9
3220:  MOVFF  17C,FA8
3224:  BCF    FA6.6
3226:  BCF    FA6.7
3228:  BSF    FA6.2
322A:  MOVFF  FF2,00
322E:  BCF    FF2.7
3230:  MOVLW  55
3232:  MOVWF  FA7
3234:  MOVLW  AA
3236:  MOVWF  FA7
3238:  BSF    FA6.1
323A:  BTFSC  FA6.1
323C:  BRA    323A
323E:  BCF    FA6.2
3240:  MOVF   00,W
3242:  IORWF  FF2,F
....................             write_eeprom(0x05,RxD_Buff[7]); 
3244:  CLRF   FAA
3246:  MOVLW  05
3248:  MOVWF  FA9
324A:  MOVFF  17D,FA8
324E:  BCF    FA6.6
3250:  BCF    FA6.7
3252:  BSF    FA6.2
3254:  MOVFF  FF2,00
3258:  BCF    FF2.7
325A:  MOVLW  55
325C:  MOVWF  FA7
325E:  MOVLW  AA
3260:  MOVWF  FA7
3262:  BSF    FA6.1
3264:  BTFSC  FA6.1
3266:  BRA    3264
3268:  BCF    FA6.2
326A:  MOVF   00,W
326C:  IORWF  FF2,F
....................             write_eeprom(0x06,RxD_Buff[8]); 
326E:  CLRF   FAA
3270:  MOVLW  06
3272:  MOVWF  FA9
3274:  MOVFF  17E,FA8
3278:  BCF    FA6.6
327A:  BCF    FA6.7
327C:  BSF    FA6.2
327E:  MOVFF  FF2,00
3282:  BCF    FF2.7
3284:  MOVLW  55
3286:  MOVWF  FA7
3288:  MOVLW  AA
328A:  MOVWF  FA7
328C:  BSF    FA6.1
328E:  BTFSC  FA6.1
3290:  BRA    328E
3292:  BCF    FA6.2
3294:  MOVF   00,W
3296:  IORWF  FF2,F
....................  
....................             write_eeprom(0x07,RxD_Buff[9]);   //Output Type 
3298:  CLRF   FAA
329A:  MOVLW  07
329C:  MOVWF  FA9
329E:  MOVFF  17F,FA8
32A2:  BCF    FA6.6
32A4:  BCF    FA6.7
32A6:  BSF    FA6.2
32A8:  MOVFF  FF2,00
32AC:  BCF    FF2.7
32AE:  MOVLW  55
32B0:  MOVWF  FA7
32B2:  MOVLW  AA
32B4:  MOVWF  FA7
32B6:  BSF    FA6.1
32B8:  BTFSC  FA6.1
32BA:  BRA    32B8
32BC:  BCF    FA6.2
32BE:  MOVF   00,W
32C0:  IORWF  FF2,F
....................             write_eeprom(0x08,RxD_Buff[10]); 
32C2:  CLRF   FAA
32C4:  MOVLW  08
32C6:  MOVWF  FA9
32C8:  MOVFF  180,FA8
32CC:  BCF    FA6.6
32CE:  BCF    FA6.7
32D0:  BSF    FA6.2
32D2:  MOVFF  FF2,00
32D6:  BCF    FF2.7
32D8:  MOVLW  55
32DA:  MOVWF  FA7
32DC:  MOVLW  AA
32DE:  MOVWF  FA7
32E0:  BSF    FA6.1
32E2:  BTFSC  FA6.1
32E4:  BRA    32E2
32E6:  BCF    FA6.2
32E8:  MOVF   00,W
32EA:  IORWF  FF2,F
....................             write_eeprom(0x09,RxD_Buff[11]); 
32EC:  CLRF   FAA
32EE:  MOVLW  09
32F0:  MOVWF  FA9
32F2:  MOVFF  181,FA8
32F6:  BCF    FA6.6
32F8:  BCF    FA6.7
32FA:  BSF    FA6.2
32FC:  MOVFF  FF2,00
3300:  BCF    FF2.7
3302:  MOVLW  55
3304:  MOVWF  FA7
3306:  MOVLW  AA
3308:  MOVWF  FA7
330A:  BSF    FA6.1
330C:  BTFSC  FA6.1
330E:  BRA    330C
3310:  BCF    FA6.2
3312:  MOVF   00,W
3314:  IORWF  FF2,F
....................  
....................             write_eeprom(0x0A,RxD_Buff[12]);   //Output Both 
3316:  CLRF   FAA
3318:  MOVLW  0A
331A:  MOVWF  FA9
331C:  MOVFF  182,FA8
3320:  BCF    FA6.6
3322:  BCF    FA6.7
3324:  BSF    FA6.2
3326:  MOVFF  FF2,00
332A:  BCF    FF2.7
332C:  MOVLW  55
332E:  MOVWF  FA7
3330:  MOVLW  AA
3332:  MOVWF  FA7
3334:  BSF    FA6.1
3336:  BTFSC  FA6.1
3338:  BRA    3336
333A:  BCF    FA6.2
333C:  MOVF   00,W
333E:  IORWF  FF2,F
....................             write_eeprom(0x0B,RxD_Buff[13]); 
3340:  CLRF   FAA
3342:  MOVLW  0B
3344:  MOVWF  FA9
3346:  MOVFF  183,FA8
334A:  BCF    FA6.6
334C:  BCF    FA6.7
334E:  BSF    FA6.2
3350:  MOVFF  FF2,00
3354:  BCF    FF2.7
3356:  MOVLW  55
3358:  MOVWF  FA7
335A:  MOVLW  AA
335C:  MOVWF  FA7
335E:  BSF    FA6.1
3360:  BTFSC  FA6.1
3362:  BRA    3360
3364:  BCF    FA6.2
3366:  MOVF   00,W
3368:  IORWF  FF2,F
....................             write_eeprom(0x0C,RxD_Buff[14]); 
336A:  CLRF   FAA
336C:  MOVLW  0C
336E:  MOVWF  FA9
3370:  MOVFF  184,FA8
3374:  BCF    FA6.6
3376:  BCF    FA6.7
3378:  BSF    FA6.2
337A:  MOVFF  FF2,00
337E:  BCF    FF2.7
3380:  MOVLW  55
3382:  MOVWF  FA7
3384:  MOVLW  AA
3386:  MOVWF  FA7
3388:  BSF    FA6.1
338A:  BTFSC  FA6.1
338C:  BRA    338A
338E:  BCF    FA6.2
3390:  MOVF   00,W
3392:  IORWF  FF2,F
....................  
....................             write_eeprom(0x0D,RxD_Buff[15]);   //Alarm / Indicator 
3394:  CLRF   FAA
3396:  MOVLW  0D
3398:  MOVWF  FA9
339A:  MOVFF  185,FA8
339E:  BCF    FA6.6
33A0:  BCF    FA6.7
33A2:  BSF    FA6.2
33A4:  MOVFF  FF2,00
33A8:  BCF    FF2.7
33AA:  MOVLW  55
33AC:  MOVWF  FA7
33AE:  MOVLW  AA
33B0:  MOVWF  FA7
33B2:  BSF    FA6.1
33B4:  BTFSC  FA6.1
33B6:  BRA    33B4
33B8:  BCF    FA6.2
33BA:  MOVF   00,W
33BC:  IORWF  FF2,F
....................             write_eeprom(0x0E,RxD_Buff[16]); 
33BE:  CLRF   FAA
33C0:  MOVLW  0E
33C2:  MOVWF  FA9
33C4:  MOVFF  186,FA8
33C8:  BCF    FA6.6
33CA:  BCF    FA6.7
33CC:  BSF    FA6.2
33CE:  MOVFF  FF2,00
33D2:  BCF    FF2.7
33D4:  MOVLW  55
33D6:  MOVWF  FA7
33D8:  MOVLW  AA
33DA:  MOVWF  FA7
33DC:  BSF    FA6.1
33DE:  BTFSC  FA6.1
33E0:  BRA    33DE
33E2:  BCF    FA6.2
33E4:  MOVF   00,W
33E6:  IORWF  FF2,F
....................             write_eeprom(0x0F,RxD_Buff[17]); 
33E8:  CLRF   FAA
33EA:  MOVLW  0F
33EC:  MOVWF  FA9
33EE:  MOVFF  187,FA8
33F2:  BCF    FA6.6
33F4:  BCF    FA6.7
33F6:  BSF    FA6.2
33F8:  MOVFF  FF2,00
33FC:  BCF    FF2.7
33FE:  MOVLW  55
3400:  MOVWF  FA7
3402:  MOVLW  AA
3404:  MOVWF  FA7
3406:  BSF    FA6.1
3408:  BTFSC  FA6.1
340A:  BRA    3408
340C:  BCF    FA6.2
340E:  MOVF   00,W
3410:  IORWF  FF2,F
....................           
....................             // LED Colour Config 
....................             write_eeprom(0x10,RxD_Buff[18]); //Red1_8 
3412:  CLRF   FAA
3414:  MOVLW  10
3416:  MOVWF  FA9
3418:  MOVFF  188,FA8
341C:  BCF    FA6.6
341E:  BCF    FA6.7
3420:  BSF    FA6.2
3422:  MOVFF  FF2,00
3426:  BCF    FF2.7
3428:  MOVLW  55
342A:  MOVWF  FA7
342C:  MOVLW  AA
342E:  MOVWF  FA7
3430:  BSF    FA6.1
3432:  BTFSC  FA6.1
3434:  BRA    3432
3436:  BCF    FA6.2
3438:  MOVF   00,W
343A:  IORWF  FF2,F
....................             write_eeprom(0x11,RxD_Buff[19]); //Red9_10 
343C:  CLRF   FAA
343E:  MOVLW  11
3440:  MOVWF  FA9
3442:  MOVFF  189,FA8
3446:  BCF    FA6.6
3448:  BCF    FA6.7
344A:  BSF    FA6.2
344C:  MOVFF  FF2,00
3450:  BCF    FF2.7
3452:  MOVLW  55
3454:  MOVWF  FA7
3456:  MOVLW  AA
3458:  MOVWF  FA7
345A:  BSF    FA6.1
345C:  BTFSC  FA6.1
345E:  BRA    345C
3460:  BCF    FA6.2
3462:  MOVF   00,W
3464:  IORWF  FF2,F
....................             write_eeprom(0x12,RxD_Buff[20]); //Red11_18 
3466:  CLRF   FAA
3468:  MOVLW  12
346A:  MOVWF  FA9
346C:  MOVFF  18A,FA8
3470:  BCF    FA6.6
3472:  BCF    FA6.7
3474:  BSF    FA6.2
3476:  MOVFF  FF2,00
347A:  BCF    FF2.7
347C:  MOVLW  55
347E:  MOVWF  FA7
3480:  MOVLW  AA
3482:  MOVWF  FA7
3484:  BSF    FA6.1
3486:  BTFSC  FA6.1
3488:  BRA    3486
348A:  BCF    FA6.2
348C:  MOVF   00,W
348E:  IORWF  FF2,F
....................             write_eeprom(0x13,RxD_Buff[21]); //Red19_20 
3490:  CLRF   FAA
3492:  MOVLW  13
3494:  MOVWF  FA9
3496:  MOVFF  18B,FA8
349A:  BCF    FA6.6
349C:  BCF    FA6.7
349E:  BSF    FA6.2
34A0:  MOVFF  FF2,00
34A4:  BCF    FF2.7
34A6:  MOVLW  55
34A8:  MOVWF  FA7
34AA:  MOVLW  AA
34AC:  MOVWF  FA7
34AE:  BSF    FA6.1
34B0:  BTFSC  FA6.1
34B2:  BRA    34B0
34B4:  BCF    FA6.2
34B6:  MOVF   00,W
34B8:  IORWF  FF2,F
....................             write_eeprom(0x14,RxD_Buff[22]); //Green1_8 
34BA:  CLRF   FAA
34BC:  MOVLW  14
34BE:  MOVWF  FA9
34C0:  MOVFF  18C,FA8
34C4:  BCF    FA6.6
34C6:  BCF    FA6.7
34C8:  BSF    FA6.2
34CA:  MOVFF  FF2,00
34CE:  BCF    FF2.7
34D0:  MOVLW  55
34D2:  MOVWF  FA7
34D4:  MOVLW  AA
34D6:  MOVWF  FA7
34D8:  BSF    FA6.1
34DA:  BTFSC  FA6.1
34DC:  BRA    34DA
34DE:  BCF    FA6.2
34E0:  MOVF   00,W
34E2:  IORWF  FF2,F
....................             write_eeprom(0x15,RxD_Buff[23]); //Green9_10 
34E4:  CLRF   FAA
34E6:  MOVLW  15
34E8:  MOVWF  FA9
34EA:  MOVFF  18D,FA8
34EE:  BCF    FA6.6
34F0:  BCF    FA6.7
34F2:  BSF    FA6.2
34F4:  MOVFF  FF2,00
34F8:  BCF    FF2.7
34FA:  MOVLW  55
34FC:  MOVWF  FA7
34FE:  MOVLW  AA
3500:  MOVWF  FA7
3502:  BSF    FA6.1
3504:  BTFSC  FA6.1
3506:  BRA    3504
3508:  BCF    FA6.2
350A:  MOVF   00,W
350C:  IORWF  FF2,F
....................             write_eeprom(0x16,RxD_Buff[24]); //Green11_18 
350E:  CLRF   FAA
3510:  MOVLW  16
3512:  MOVWF  FA9
3514:  MOVFF  18E,FA8
3518:  BCF    FA6.6
351A:  BCF    FA6.7
351C:  BSF    FA6.2
351E:  MOVFF  FF2,00
3522:  BCF    FF2.7
3524:  MOVLW  55
3526:  MOVWF  FA7
3528:  MOVLW  AA
352A:  MOVWF  FA7
352C:  BSF    FA6.1
352E:  BTFSC  FA6.1
3530:  BRA    352E
3532:  BCF    FA6.2
3534:  MOVF   00,W
3536:  IORWF  FF2,F
....................             write_eeprom(0x17,RxD_Buff[25]); //Green19_20 
3538:  CLRF   FAA
353A:  MOVLW  17
353C:  MOVWF  FA9
353E:  MOVFF  18F,FA8
3542:  BCF    FA6.6
3544:  BCF    FA6.7
3546:  BSF    FA6.2
3548:  MOVFF  FF2,00
354C:  BCF    FF2.7
354E:  MOVLW  55
3550:  MOVWF  FA7
3552:  MOVLW  AA
3554:  MOVWF  FA7
3556:  BSF    FA6.1
3558:  BTFSC  FA6.1
355A:  BRA    3558
355C:  BCF    FA6.2
355E:  MOVF   00,W
3560:  IORWF  FF2,F
....................                 
....................             write_eeprom(0x18,RxD_Buff[26]);   //Auto acknowledge 
3562:  CLRF   FAA
3564:  MOVLW  18
3566:  MOVWF  FA9
3568:  MOVFF  190,FA8
356C:  BCF    FA6.6
356E:  BCF    FA6.7
3570:  BSF    FA6.2
3572:  MOVFF  FF2,00
3576:  BCF    FF2.7
3578:  MOVLW  55
357A:  MOVWF  FA7
357C:  MOVLW  AA
357E:  MOVWF  FA7
3580:  BSF    FA6.1
3582:  BTFSC  FA6.1
3584:  BRA    3582
3586:  BCF    FA6.2
3588:  MOVF   00,W
358A:  IORWF  FF2,F
....................             write_eeprom(0x19,RxD_Buff[27]);   //Auto acknowledge Time 
358C:  CLRF   FAA
358E:  MOVLW  19
3590:  MOVWF  FA9
3592:  MOVFF  191,FA8
3596:  BCF    FA6.6
3598:  BCF    FA6.7
359A:  BSF    FA6.2
359C:  MOVFF  FF2,00
35A0:  BCF    FF2.7
35A2:  MOVLW  55
35A4:  MOVWF  FA7
35A6:  MOVLW  AA
35A8:  MOVWF  FA7
35AA:  BSF    FA6.1
35AC:  BTFSC  FA6.1
35AE:  BRA    35AC
35B0:  BCF    FA6.2
35B2:  MOVF   00,W
35B4:  IORWF  FF2,F
....................             write_eeprom(0x1A,RxD_Buff[28]);   //Flashing Rate 
35B6:  CLRF   FAA
35B8:  MOVLW  1A
35BA:  MOVWF  FA9
35BC:  MOVFF  192,FA8
35C0:  BCF    FA6.6
35C2:  BCF    FA6.7
35C4:  BSF    FA6.2
35C6:  MOVFF  FF2,00
35CA:  BCF    FF2.7
35CC:  MOVLW  55
35CE:  MOVWF  FA7
35D0:  MOVLW  AA
35D2:  MOVWF  FA7
35D4:  BSF    FA6.1
35D6:  BTFSC  FA6.1
35D8:  BRA    35D6
35DA:  BCF    FA6.2
35DC:  MOVF   00,W
35DE:  IORWF  FF2,F
....................             write_eeprom(0x1B,RxD_Buff[29]);   //No of point 
35E0:  CLRF   FAA
35E2:  MOVLW  1B
35E4:  MOVWF  FA9
35E6:  MOVFF  193,FA8
35EA:  BCF    FA6.6
35EC:  BCF    FA6.7
35EE:  BSF    FA6.2
35F0:  MOVFF  FF2,00
35F4:  BCF    FF2.7
35F6:  MOVLW  55
35F8:  MOVWF  FA7
35FA:  MOVLW  AA
35FC:  MOVWF  FA7
35FE:  BSF    FA6.1
3600:  BTFSC  FA6.1
3602:  BRA    3600
3604:  BCF    FA6.2
3606:  MOVF   00,W
3608:  IORWF  FF2,F
....................             write_eeprom(0x1C,RxD_Buff[30]);   //Master / Slave 
360A:  CLRF   FAA
360C:  MOVLW  1C
360E:  MOVWF  FA9
3610:  MOVFF  194,FA8
3614:  BCF    FA6.6
3616:  BCF    FA6.7
3618:  BSF    FA6.2
361A:  MOVFF  FF2,00
361E:  BCF    FF2.7
3620:  MOVLW  55
3622:  MOVWF  FA7
3624:  MOVLW  AA
3626:  MOVWF  FA7
3628:  BSF    FA6.1
362A:  BTFSC  FA6.1
362C:  BRA    362A
362E:  BCF    FA6.2
3630:  MOVF   00,W
3632:  IORWF  FF2,F
....................             write_eeprom(0x1D,RxD_Buff[31]);   //Communication Address 
3634:  CLRF   FAA
3636:  MOVLW  1D
3638:  MOVWF  FA9
363A:  MOVFF  195,FA8
363E:  BCF    FA6.6
3640:  BCF    FA6.7
3642:  BSF    FA6.2
3644:  MOVFF  FF2,00
3648:  BCF    FF2.7
364A:  MOVLW  55
364C:  MOVWF  FA7
364E:  MOVLW  AA
3650:  MOVWF  FA7
3652:  BSF    FA6.1
3654:  BTFSC  FA6.1
3656:  BRA    3654
3658:  BCF    FA6.2
365A:  MOVF   00,W
365C:  IORWF  FF2,F
....................  
....................             write_eeprom(0x1E,RxD_Buff[32]);   //Communication Address 
365E:  CLRF   FAA
3660:  MOVLW  1E
3662:  MOVWF  FA9
3664:  MOVFF  196,FA8
3668:  BCF    FA6.6
366A:  BCF    FA6.7
366C:  BSF    FA6.2
366E:  MOVFF  FF2,00
3672:  BCF    FF2.7
3674:  MOVLW  55
3676:  MOVWF  FA7
3678:  MOVLW  AA
367A:  MOVWF  FA7
367C:  BSF    FA6.1
367E:  BTFSC  FA6.1
3680:  BRA    367E
3682:  BCF    FA6.2
3684:  MOVF   00,W
3686:  IORWF  FF2,F
....................             write_eeprom(0x1F,RxD_Buff[33]);   //Communication Address 
3688:  CLRF   FAA
368A:  MOVLW  1F
368C:  MOVWF  FA9
368E:  MOVFF  197,FA8
3692:  BCF    FA6.6
3694:  BCF    FA6.7
3696:  BSF    FA6.2
3698:  MOVFF  FF2,00
369C:  BCF    FF2.7
369E:  MOVLW  55
36A0:  MOVWF  FA7
36A2:  MOVLW  AA
36A4:  MOVWF  FA7
36A6:  BSF    FA6.1
36A8:  BTFSC  FA6.1
36AA:  BRA    36A8
36AC:  BCF    FA6.2
36AE:  MOVF   00,W
36B0:  IORWF  FF2,F
....................             write_eeprom(0x20,RxD_Buff[34]);   //Communication Address 
36B2:  CLRF   FAA
36B4:  MOVLW  20
36B6:  MOVWF  FA9
36B8:  MOVFF  198,FA8
36BC:  BCF    FA6.6
36BE:  BCF    FA6.7
36C0:  BSF    FA6.2
36C2:  MOVFF  FF2,00
36C6:  BCF    FF2.7
36C8:  MOVLW  55
36CA:  MOVWF  FA7
36CC:  MOVLW  AA
36CE:  MOVWF  FA7
36D0:  BSF    FA6.1
36D2:  BTFSC  FA6.1
36D4:  BRA    36D2
36D6:  BCF    FA6.2
36D8:  MOVF   00,W
36DA:  IORWF  FF2,F
....................             write_eeprom(0x21,RxD_Buff[35]);   //Communication Address 
36DC:  CLRF   FAA
36DE:  MOVLW  21
36E0:  MOVWF  FA9
36E2:  MOVFF  199,FA8
36E6:  BCF    FA6.6
36E8:  BCF    FA6.7
36EA:  BSF    FA6.2
36EC:  MOVFF  FF2,00
36F0:  BCF    FF2.7
36F2:  MOVLW  55
36F4:  MOVWF  FA7
36F6:  MOVLW  AA
36F8:  MOVWF  FA7
36FA:  BSF    FA6.1
36FC:  BTFSC  FA6.1
36FE:  BRA    36FC
3700:  BCF    FA6.2
3702:  MOVF   00,W
3704:  IORWF  FF2,F
....................             write_eeprom(0x22,RxD_Buff[36]);   //Communication Address 
3706:  CLRF   FAA
3708:  MOVLW  22
370A:  MOVWF  FA9
370C:  MOVFF  19A,FA8
3710:  BCF    FA6.6
3712:  BCF    FA6.7
3714:  BSF    FA6.2
3716:  MOVFF  FF2,00
371A:  BCF    FF2.7
371C:  MOVLW  55
371E:  MOVWF  FA7
3720:  MOVLW  AA
3722:  MOVWF  FA7
3724:  BSF    FA6.1
3726:  BTFSC  FA6.1
3728:  BRA    3726
372A:  BCF    FA6.2
372C:  MOVF   00,W
372E:  IORWF  FF2,F
....................             write_eeprom(0x23,RxD_Buff[37]);   //Communication Address 
3730:  CLRF   FAA
3732:  MOVLW  23
3734:  MOVWF  FA9
3736:  MOVFF  19B,FA8
373A:  BCF    FA6.6
373C:  BCF    FA6.7
373E:  BSF    FA6.2
3740:  MOVFF  FF2,00
3744:  BCF    FF2.7
3746:  MOVLW  55
3748:  MOVWF  FA7
374A:  MOVLW  AA
374C:  MOVWF  FA7
374E:  BSF    FA6.1
3750:  BTFSC  FA6.1
3752:  BRA    3750
3754:  BCF    FA6.2
3756:  MOVF   00,W
3758:  IORWF  FF2,F
....................             write_eeprom(0x24,RxD_Buff[38]);   //Communication Address 
375A:  CLRF   FAA
375C:  MOVLW  24
375E:  MOVWF  FA9
3760:  MOVFF  19C,FA8
3764:  BCF    FA6.6
3766:  BCF    FA6.7
3768:  BSF    FA6.2
376A:  MOVFF  FF2,00
376E:  BCF    FF2.7
3770:  MOVLW  55
3772:  MOVWF  FA7
3774:  MOVLW  AA
3776:  MOVWF  FA7
3778:  BSF    FA6.1
377A:  BTFSC  FA6.1
377C:  BRA    377A
377E:  BCF    FA6.2
3780:  MOVF   00,W
3782:  IORWF  FF2,F
....................             write_eeprom(0x25,RxD_Buff[39]);   //Communication Address 
3784:  CLRF   FAA
3786:  MOVLW  25
3788:  MOVWF  FA9
378A:  MOVFF  19D,FA8
378E:  BCF    FA6.6
3790:  BCF    FA6.7
3792:  BSF    FA6.2
3794:  MOVFF  FF2,00
3798:  BCF    FF2.7
379A:  MOVLW  55
379C:  MOVWF  FA7
379E:  MOVLW  AA
37A0:  MOVWF  FA7
37A2:  BSF    FA6.1
37A4:  BTFSC  FA6.1
37A6:  BRA    37A4
37A8:  BCF    FA6.2
37AA:  MOVF   00,W
37AC:  IORWF  FF2,F
....................             write_eeprom(0x26,RxD_Buff[40]);   //Communication Address 
37AE:  CLRF   FAA
37B0:  MOVLW  26
37B2:  MOVWF  FA9
37B4:  MOVFF  19E,FA8
37B8:  BCF    FA6.6
37BA:  BCF    FA6.7
37BC:  BSF    FA6.2
37BE:  MOVFF  FF2,00
37C2:  BCF    FF2.7
37C4:  MOVLW  55
37C6:  MOVWF  FA7
37C8:  MOVLW  AA
37CA:  MOVWF  FA7
37CC:  BSF    FA6.1
37CE:  BTFSC  FA6.1
37D0:  BRA    37CE
37D2:  BCF    FA6.2
37D4:  MOVF   00,W
37D6:  IORWF  FF2,F
....................             write_eeprom(0x27,RxD_Buff[41]);   //Communication Address 
37D8:  CLRF   FAA
37DA:  MOVLW  27
37DC:  MOVWF  FA9
37DE:  MOVFF  19F,FA8
37E2:  BCF    FA6.6
37E4:  BCF    FA6.7
37E6:  BSF    FA6.2
37E8:  MOVFF  FF2,00
37EC:  BCF    FF2.7
37EE:  MOVLW  55
37F0:  MOVWF  FA7
37F2:  MOVLW  AA
37F4:  MOVWF  FA7
37F6:  BSF    FA6.1
37F8:  BTFSC  FA6.1
37FA:  BRA    37F8
37FC:  BCF    FA6.2
37FE:  MOVF   00,W
3800:  IORWF  FF2,F
....................             write_eeprom(0x28,RxD_Buff[42]);   //Communication Address 
3802:  CLRF   FAA
3804:  MOVLW  28
3806:  MOVWF  FA9
3808:  MOVFF  1A0,FA8
380C:  BCF    FA6.6
380E:  BCF    FA6.7
3810:  BSF    FA6.2
3812:  MOVFF  FF2,00
3816:  BCF    FF2.7
3818:  MOVLW  55
381A:  MOVWF  FA7
381C:  MOVLW  AA
381E:  MOVWF  FA7
3820:  BSF    FA6.1
3822:  BTFSC  FA6.1
3824:  BRA    3822
3826:  BCF    FA6.2
3828:  MOVF   00,W
382A:  IORWF  FF2,F
....................             write_eeprom(0x29,RxD_Buff[43]);   //Communication Address 
382C:  CLRF   FAA
382E:  MOVLW  29
3830:  MOVWF  FA9
3832:  MOVFF  1A1,FA8
3836:  BCF    FA6.6
3838:  BCF    FA6.7
383A:  BSF    FA6.2
383C:  MOVFF  FF2,00
3840:  BCF    FF2.7
3842:  MOVLW  55
3844:  MOVWF  FA7
3846:  MOVLW  AA
3848:  MOVWF  FA7
384A:  BSF    FA6.1
384C:  BTFSC  FA6.1
384E:  BRA    384C
3850:  BCF    FA6.2
3852:  MOVF   00,W
3854:  IORWF  FF2,F
....................             write_eeprom(0x2A,RxD_Buff[44]);   //Communication Address 
3856:  CLRF   FAA
3858:  MOVLW  2A
385A:  MOVWF  FA9
385C:  MOVFF  1A2,FA8
3860:  BCF    FA6.6
3862:  BCF    FA6.7
3864:  BSF    FA6.2
3866:  MOVFF  FF2,00
386A:  BCF    FF2.7
386C:  MOVLW  55
386E:  MOVWF  FA7
3870:  MOVLW  AA
3872:  MOVWF  FA7
3874:  BSF    FA6.1
3876:  BTFSC  FA6.1
3878:  BRA    3876
387A:  BCF    FA6.2
387C:  MOVF   00,W
387E:  IORWF  FF2,F
....................             write_eeprom(0x2B,RxD_Buff[45]);   //Communication Address 
3880:  CLRF   FAA
3882:  MOVLW  2B
3884:  MOVWF  FA9
3886:  MOVFF  1A3,FA8
388A:  BCF    FA6.6
388C:  BCF    FA6.7
388E:  BSF    FA6.2
3890:  MOVFF  FF2,00
3894:  BCF    FF2.7
3896:  MOVLW  55
3898:  MOVWF  FA7
389A:  MOVLW  AA
389C:  MOVWF  FA7
389E:  BSF    FA6.1
38A0:  BTFSC  FA6.1
38A2:  BRA    38A0
38A4:  BCF    FA6.2
38A6:  MOVF   00,W
38A8:  IORWF  FF2,F
....................             write_eeprom(0x2C,RxD_Buff[46]);   //Communication Address 
38AA:  CLRF   FAA
38AC:  MOVLW  2C
38AE:  MOVWF  FA9
38B0:  MOVFF  1A4,FA8
38B4:  BCF    FA6.6
38B6:  BCF    FA6.7
38B8:  BSF    FA6.2
38BA:  MOVFF  FF2,00
38BE:  BCF    FF2.7
38C0:  MOVLW  55
38C2:  MOVWF  FA7
38C4:  MOVLW  AA
38C6:  MOVWF  FA7
38C8:  BSF    FA6.1
38CA:  BTFSC  FA6.1
38CC:  BRA    38CA
38CE:  BCF    FA6.2
38D0:  MOVF   00,W
38D2:  IORWF  FF2,F
....................             write_eeprom(0x2D,RxD_Buff[47]);   //Communication Address 
38D4:  CLRF   FAA
38D6:  MOVLW  2D
38D8:  MOVWF  FA9
38DA:  MOVFF  1A5,FA8
38DE:  BCF    FA6.6
38E0:  BCF    FA6.7
38E2:  BSF    FA6.2
38E4:  MOVFF  FF2,00
38E8:  BCF    FF2.7
38EA:  MOVLW  55
38EC:  MOVWF  FA7
38EE:  MOVLW  AA
38F0:  MOVWF  FA7
38F2:  BSF    FA6.1
38F4:  BTFSC  FA6.1
38F6:  BRA    38F4
38F8:  BCF    FA6.2
38FA:  MOVF   00,W
38FC:  IORWF  FF2,F
....................             write_eeprom(0x2E,RxD_Buff[48]);   //Communication Address 
38FE:  CLRF   FAA
3900:  MOVLW  2E
3902:  MOVWF  FA9
3904:  MOVFF  1A6,FA8
3908:  BCF    FA6.6
390A:  BCF    FA6.7
390C:  BSF    FA6.2
390E:  MOVFF  FF2,00
3912:  BCF    FF2.7
3914:  MOVLW  55
3916:  MOVWF  FA7
3918:  MOVLW  AA
391A:  MOVWF  FA7
391C:  BSF    FA6.1
391E:  BTFSC  FA6.1
3920:  BRA    391E
3922:  BCF    FA6.2
3924:  MOVF   00,W
3926:  IORWF  FF2,F
....................             write_eeprom(0x2F,RxD_Buff[49]);   //Communication Address 
3928:  CLRF   FAA
392A:  MOVLW  2F
392C:  MOVWF  FA9
392E:  MOVFF  1A7,FA8
3932:  BCF    FA6.6
3934:  BCF    FA6.7
3936:  BSF    FA6.2
3938:  MOVFF  FF2,00
393C:  BCF    FF2.7
393E:  MOVLW  55
3940:  MOVWF  FA7
3942:  MOVLW  AA
3944:  MOVWF  FA7
3946:  BSF    FA6.1
3948:  BTFSC  FA6.1
394A:  BRA    3948
394C:  BCF    FA6.2
394E:  MOVF   00,W
3950:  IORWF  FF2,F
....................             write_eeprom(0x30,RxD_Buff[50]);   //Communication Address 
3952:  CLRF   FAA
3954:  MOVLW  30
3956:  MOVWF  FA9
3958:  MOVFF  1A8,FA8
395C:  BCF    FA6.6
395E:  BCF    FA6.7
3960:  BSF    FA6.2
3962:  MOVFF  FF2,00
3966:  BCF    FF2.7
3968:  MOVLW  55
396A:  MOVWF  FA7
396C:  MOVLW  AA
396E:  MOVWF  FA7
3970:  BSF    FA6.1
3972:  BTFSC  FA6.1
3974:  BRA    3972
3976:  BCF    FA6.2
3978:  MOVF   00,W
397A:  IORWF  FF2,F
....................             write_eeprom(0x31,RxD_Buff[51]);   //Communication Address 
397C:  CLRF   FAA
397E:  MOVLW  31
3980:  MOVWF  FA9
3982:  MOVFF  1A9,FA8
3986:  BCF    FA6.6
3988:  BCF    FA6.7
398A:  BSF    FA6.2
398C:  MOVFF  FF2,00
3990:  BCF    FF2.7
3992:  MOVLW  55
3994:  MOVWF  FA7
3996:  MOVLW  AA
3998:  MOVWF  FA7
399A:  BSF    FA6.1
399C:  BTFSC  FA6.1
399E:  BRA    399C
39A0:  BCF    FA6.2
39A2:  MOVF   00,W
39A4:  IORWF  FF2,F
....................              
....................             int16  a = 0;  
....................             unsigned char  phonenum; 
39A6:  MOVLB  8
39A8:  CLRF   x71
39AA:  CLRF   x70
....................             for(; ; a++) 
....................             { 
....................                restart_wdt(); 
39AC:  CLRWDT
....................                phonenum = RxD_Buff[52 + a]; 
39AE:  MOVLW  AA
39B0:  ADDWF  x70,W
39B2:  MOVWF  FE9
39B4:  MOVLW  01
39B6:  ADDWFC x71,W
39B8:  MOVWF  FEA
39BA:  MOVFF  FEF,872
....................                if((phonenum == 0x0D) || (a > 15)) 
39BE:  MOVF   x72,W
39C0:  SUBLW  0D
39C2:  BZ    39CE
39C4:  MOVF   x71,F
39C6:  BNZ   39CE
39C8:  MOVF   x70,W
39CA:  SUBLW  0F
39CC:  BC    3A1C
....................                { 
....................                   sms_phonenumber[a] =  '\0' ; 
39CE:  MOVLW  83
39D0:  ADDWF  x70,W
39D2:  MOVWF  FE9
39D4:  MOVLW  06
39D6:  ADDWFC x71,W
39D8:  MOVWF  FEA
39DA:  CLRF   FEF
....................                   write_eeprom(0x32+a,phonenum); 
39DC:  MOVLW  32
39DE:  ADDWF  x70,W
39E0:  MOVWF  x79
39E2:  MOVLW  00
39E4:  ADDWFC x71,W
39E6:  MOVWF  x7A
39E8:  MOVFF  87A,FAA
39EC:  MOVFF  879,FA9
39F0:  MOVFF  872,FA8
39F4:  BCF    FA6.6
39F6:  BCF    FA6.7
39F8:  BSF    FA6.2
39FA:  MOVF   FF2,W
39FC:  MOVWF  00
39FE:  BCF    FF2.7
3A00:  MOVLB  F
3A02:  MOVLW  55
3A04:  MOVWF  FA7
3A06:  MOVLW  AA
3A08:  MOVWF  FA7
3A0A:  BSF    FA6.1
3A0C:  BTFSC  FA6.1
3A0E:  BRA    3A0C
3A10:  BCF    FA6.2
3A12:  MOVF   00,W
3A14:  IORWF  FF2,F
....................                   break; 
3A16:  BRA    3A72
....................                } 
....................                else 
3A18:  BRA    3A66
3A1A:  MOVLB  8
....................                { 
....................                   sms_phonenumber[a] = phonenum; 
3A1C:  MOVLW  83
3A1E:  ADDWF  x70,W
3A20:  MOVWF  FE9
3A22:  MOVLW  06
3A24:  ADDWFC x71,W
3A26:  MOVWF  FEA
3A28:  MOVFF  872,FEF
....................                    
....................                   write_eeprom(0x32+a,phonenum); 
3A2C:  MOVLW  32
3A2E:  ADDWF  x70,W
3A30:  MOVWF  x79
3A32:  MOVLW  00
3A34:  ADDWFC x71,W
3A36:  MOVWF  x7A
3A38:  MOVFF  87A,FAA
3A3C:  MOVFF  879,FA9
3A40:  MOVFF  872,FA8
3A44:  BCF    FA6.6
3A46:  BCF    FA6.7
3A48:  BSF    FA6.2
3A4A:  MOVF   FF2,W
3A4C:  MOVWF  00
3A4E:  BCF    FF2.7
3A50:  MOVLB  F
3A52:  MOVLW  55
3A54:  MOVWF  FA7
3A56:  MOVLW  AA
3A58:  MOVWF  FA7
3A5A:  BSF    FA6.1
3A5C:  BTFSC  FA6.1
3A5E:  BRA    3A5C
3A60:  BCF    FA6.2
3A62:  MOVF   00,W
3A64:  IORWF  FF2,F
....................                } 
....................             } 
3A66:  MOVLB  8
3A68:  INCF   x70,F
3A6A:  BTFSC  FD8.2
3A6C:  INCF   x71,F
3A6E:  BRA    39AC
3A70:  MOVLB  F
....................  
....................              
....................             /* 
....................             write_eeprom(0x32,RxD_Buff[52]); 
....................             write_eeprom(0x33,RxD_Buff[53]); 
....................             write_eeprom(0x34,RxD_Buff[54]); 
....................             write_eeprom(0x35,RxD_Buff[55]); 
....................             write_eeprom(0x36,RxD_Buff[56]); 
....................             write_eeprom(0x37,RxD_Buff[57]); 
....................             write_eeprom(0x38,RxD_Buff[58]); 
....................             write_eeprom(0x39,RxD_Buff[59]); 
....................             write_eeprom(0x3A,RxD_Buff[60]); 
....................             write_eeprom(0x3B,RxD_Buff[61]); 
....................             */ 
....................              
....................                  
....................             TxD_Buff[0] = Address ;         //Address 
3A72:  MOVFF  75,77
....................             TxD_Buff[1] = 0x21 ;            //return function code 
3A76:  MOVLW  21
3A78:  MOVWF  78
....................  
....................             CRC(TxD_Buff,2)   ;            //Cal CRC 2 byte 
3A7A:  MOVLB  8
3A7C:  CLRF   x7B
3A7E:  MOVLW  77
3A80:  MOVWF  x7A
3A82:  MOVLW  02
3A84:  MOVWF  x7C
3A86:  MOVLB  0
3A88:  CALL   1F56
....................  
....................             TxD_Buff[2] = CRC_Hi ; 
3A8C:  MOVFF  577,79
....................             TxD_Buff[3] = CRC_Lo ; 
3A90:  MOVFF  576,7A
....................  
....................             output_bit(P485ctrl,1); 
3A94:  BSF    F8A.3
3A96:  BCF    F93.3
....................             delay_ms(10); 
3A98:  MOVLW  0A
3A9A:  MOVLB  8
3A9C:  MOVWF  x79
3A9E:  MOVLB  0
3AA0:  CALL   0772
....................  
....................             putc(Txd_Buff[0]); 
3AA4:  MOVF   77,W
3AA6:  CALL   1F4C
....................             putc(Txd_Buff[1]); 
3AAA:  MOVF   78,W
3AAC:  CALL   1F4C
....................             putc(Txd_Buff[2]); 
3AB0:  MOVF   79,W
3AB2:  CALL   1F4C
....................             putc(Txd_Buff[3]); 
3AB6:  MOVF   7A,W
3AB8:  CALL   1F4C
....................  
....................             delay_ms(3); 
3ABC:  MOVLW  03
3ABE:  MOVLB  8
3AC0:  MOVWF  x79
3AC2:  MOVLB  0
3AC4:  CALL   0772
....................             output_bit(P485ctrl,0); 
3AC8:  BCF    F8A.3
3ACA:  BCF    F93.3
....................              
....................             reset_cpu(); 
3ACC:  RESET
....................             //Read_Config(); //jj 
....................          } 
....................           
....................          else if(RxD_Buff[1] == 0x22)///////////// WRITE Faultname ///////////////////// 
3ACE:  GOTO   43C0
3AD2:  MOVLB  1
3AD4:  MOVF   x77,W
3AD6:  SUBLW  22
3AD8:  BTFSS  FD8.2
3ADA:  GOTO   43C0
....................          { 
....................             //SMS_Massage 
....................             int16  i =3,j=0,k=0; 
3ADE:  MOVLB  8
3AE0:  CLRF   x74
3AE2:  MOVLW  03
3AE4:  MOVWF  x73
3AE6:  CLRF   x76
3AE8:  CLRF   x75
3AEA:  CLRF   x78
3AEC:  CLRF   x77
....................             for(; ; i++,j++) 
....................             { 
....................                restart_wdt(); 
3AEE:  CLRWDT
....................                if((RxD_Buff[i] == 0x0D) || (j > 41)) 
3AF0:  MOVLW  76
3AF2:  ADDWF  x73,W
3AF4:  MOVWF  FE9
3AF6:  MOVLW  01
3AF8:  ADDWFC x74,W
3AFA:  MOVWF  FEA
3AFC:  MOVF   FEF,W
3AFE:  SUBLW  0D
3B00:  BZ    3B0C
3B02:  MOVF   x76,F
3B04:  BNZ   3B0C
3B06:  MOVF   x75,W
3B08:  SUBLW  29
3B0A:  BC    3B5C
....................                { 
....................                   write_eeprom(0x5D+i,RxD_Buff[i]); 
3B0C:  MOVLW  5D
3B0E:  ADDWF  x73,W
3B10:  MOVWF  x79
3B12:  MOVLW  00
3B14:  ADDWFC x74,W
3B16:  MOVWF  x7A
3B18:  MOVLW  76
3B1A:  ADDWF  x73,W
3B1C:  MOVWF  FE9
3B1E:  MOVLW  01
3B20:  ADDWFC x74,W
3B22:  MOVWF  FEA
3B24:  MOVFF  FEF,87B
3B28:  MOVFF  87A,FAA
3B2C:  MOVFF  879,FA9
3B30:  MOVFF  87B,FA8
3B34:  BCF    FA6.6
3B36:  BCF    FA6.7
3B38:  BSF    FA6.2
3B3A:  MOVF   FF2,W
3B3C:  MOVWF  00
3B3E:  BCF    FF2.7
3B40:  MOVLB  F
3B42:  MOVLW  55
3B44:  MOVWF  FA7
3B46:  MOVLW  AA
3B48:  MOVWF  FA7
3B4A:  BSF    FA6.1
3B4C:  BTFSC  FA6.1
3B4E:  BRA    3B4C
3B50:  BCF    FA6.2
3B52:  MOVF   00,W
3B54:  IORWF  FF2,F
....................                   break; 
3B56:  BRA    3BE4
....................                } 
....................                else 
3B58:  BRA    3BCE
3B5A:  MOVLB  8
....................                { 
....................                   SMS_Massage1[j] = RxD_Buff[i]; 
3B5C:  MOVLW  92
3B5E:  ADDWF  x75,W
3B60:  MOVWF  01
3B62:  MOVLW  06
3B64:  ADDWFC x76,W
3B66:  MOVWF  03
3B68:  MOVLW  76
3B6A:  ADDWF  x73,W
3B6C:  MOVWF  FE9
3B6E:  MOVLW  01
3B70:  ADDWFC x74,W
3B72:  MOVWF  FEA
3B74:  MOVFF  FEF,87B
3B78:  MOVFF  03,FEA
3B7C:  MOVFF  01,FE9
3B80:  MOVFF  87B,FEF
....................                    
....................                   write_eeprom(0x5D+i,RxD_Buff[i]); 
3B84:  MOVLW  5D
3B86:  ADDWF  x73,W
3B88:  MOVWF  x79
3B8A:  MOVLW  00
3B8C:  ADDWFC x74,W
3B8E:  MOVWF  x7A
3B90:  MOVLW  76
3B92:  ADDWF  x73,W
3B94:  MOVWF  FE9
3B96:  MOVLW  01
3B98:  ADDWFC x74,W
3B9A:  MOVWF  FEA
3B9C:  MOVFF  FEF,87B
3BA0:  MOVFF  87A,FAA
3BA4:  MOVFF  879,FA9
3BA8:  MOVFF  87B,FA8
3BAC:  BCF    FA6.6
3BAE:  BCF    FA6.7
3BB0:  BSF    FA6.2
3BB2:  MOVF   FF2,W
3BB4:  MOVWF  00
3BB6:  BCF    FF2.7
3BB8:  MOVLB  F
3BBA:  MOVLW  55
3BBC:  MOVWF  FA7
3BBE:  MOVLW  AA
3BC0:  MOVWF  FA7
3BC2:  BSF    FA6.1
3BC4:  BTFSC  FA6.1
3BC6:  BRA    3BC4
3BC8:  BCF    FA6.2
3BCA:  MOVF   00,W
3BCC:  IORWF  FF2,F
....................                } 
....................             } 
3BCE:  MOVLB  8
3BD0:  MOVFF  874,03
3BD4:  MOVF   x73,W
3BD6:  INCF   x73,F
3BD8:  BTFSC  FD8.2
3BDA:  INCF   x74,F
3BDC:  INCF   x75,F
3BDE:  BTFSC  FD8.2
3BE0:  INCF   x76,F
3BE2:  BRA    3AEE
....................             SMS_Massage1[j] = '\0' ; // end string 
3BE4:  MOVLW  92
3BE6:  MOVLB  8
3BE8:  ADDWF  x75,W
3BEA:  MOVWF  FE9
3BEC:  MOVLW  06
3BEE:  ADDWFC x76,W
3BF0:  MOVWF  FEA
3BF2:  CLRF   FEF
....................              
....................             j=0; 
3BF4:  CLRF   x76
3BF6:  CLRF   x75
....................             i++; 
3BF8:  INCF   x73,F
3BFA:  BTFSC  FD8.2
3BFC:  INCF   x74,F
....................              
....................             for(; ; i++,j++) 
....................             { 
....................                restart_wdt(); 
3BFE:  CLRWDT
....................                if((RxD_Buff[i] == 0x0D) || (j > 41)) 
3C00:  MOVLW  76
3C02:  ADDWF  x73,W
3C04:  MOVWF  FE9
3C06:  MOVLW  01
3C08:  ADDWFC x74,W
3C0A:  MOVWF  FEA
3C0C:  MOVF   FEF,W
3C0E:  SUBLW  0D
3C10:  BZ    3C1C
3C12:  MOVF   x76,F
3C14:  BNZ   3C1C
3C16:  MOVF   x75,W
3C18:  SUBLW  29
3C1A:  BC    3C6C
....................                {   
....................                   write_eeprom(0x5D+i,RxD_Buff[i]); 
3C1C:  MOVLW  5D
3C1E:  ADDWF  x73,W
3C20:  MOVWF  x79
3C22:  MOVLW  00
3C24:  ADDWFC x74,W
3C26:  MOVWF  x7A
3C28:  MOVLW  76
3C2A:  ADDWF  x73,W
3C2C:  MOVWF  FE9
3C2E:  MOVLW  01
3C30:  ADDWFC x74,W
3C32:  MOVWF  FEA
3C34:  MOVFF  FEF,87B
3C38:  MOVFF  87A,FAA
3C3C:  MOVFF  879,FA9
3C40:  MOVFF  87B,FA8
3C44:  BCF    FA6.6
3C46:  BCF    FA6.7
3C48:  BSF    FA6.2
3C4A:  MOVF   FF2,W
3C4C:  MOVWF  00
3C4E:  BCF    FF2.7
3C50:  MOVLB  F
3C52:  MOVLW  55
3C54:  MOVWF  FA7
3C56:  MOVLW  AA
3C58:  MOVWF  FA7
3C5A:  BSF    FA6.1
3C5C:  BTFSC  FA6.1
3C5E:  BRA    3C5C
3C60:  BCF    FA6.2
3C62:  MOVF   00,W
3C64:  IORWF  FF2,F
....................                   break; 
3C66:  BRA    3CF4
....................                } 
....................                else 
3C68:  BRA    3CDE
3C6A:  MOVLB  8
....................                { 
....................                   SMS_Massage2[j] = RxD_Buff[i]; 
3C6C:  MOVLW  BB
3C6E:  ADDWF  x75,W
3C70:  MOVWF  01
3C72:  MOVLW  06
3C74:  ADDWFC x76,W
3C76:  MOVWF  03
3C78:  MOVLW  76
3C7A:  ADDWF  x73,W
3C7C:  MOVWF  FE9
3C7E:  MOVLW  01
3C80:  ADDWFC x74,W
3C82:  MOVWF  FEA
3C84:  MOVFF  FEF,87B
3C88:  MOVFF  03,FEA
3C8C:  MOVFF  01,FE9
3C90:  MOVFF  87B,FEF
....................                   write_eeprom(0x5D+i,RxD_Buff[i]); 
3C94:  MOVLW  5D
3C96:  ADDWF  x73,W
3C98:  MOVWF  x79
3C9A:  MOVLW  00
3C9C:  ADDWFC x74,W
3C9E:  MOVWF  x7A
3CA0:  MOVLW  76
3CA2:  ADDWF  x73,W
3CA4:  MOVWF  FE9
3CA6:  MOVLW  01
3CA8:  ADDWFC x74,W
3CAA:  MOVWF  FEA
3CAC:  MOVFF  FEF,87B
3CB0:  MOVFF  87A,FAA
3CB4:  MOVFF  879,FA9
3CB8:  MOVFF  87B,FA8
3CBC:  BCF    FA6.6
3CBE:  BCF    FA6.7
3CC0:  BSF    FA6.2
3CC2:  MOVF   FF2,W
3CC4:  MOVWF  00
3CC6:  BCF    FF2.7
3CC8:  MOVLB  F
3CCA:  MOVLW  55
3CCC:  MOVWF  FA7
3CCE:  MOVLW  AA
3CD0:  MOVWF  FA7
3CD2:  BSF    FA6.1
3CD4:  BTFSC  FA6.1
3CD6:  BRA    3CD4
3CD8:  BCF    FA6.2
3CDA:  MOVF   00,W
3CDC:  IORWF  FF2,F
....................                } 
....................             } 
3CDE:  MOVLB  8
3CE0:  MOVFF  874,03
3CE4:  MOVF   x73,W
3CE6:  INCF   x73,F
3CE8:  BTFSC  FD8.2
3CEA:  INCF   x74,F
3CEC:  INCF   x75,F
3CEE:  BTFSC  FD8.2
3CF0:  INCF   x76,F
3CF2:  BRA    3BFE
....................             SMS_Massage2[j] = '\0' ; // end string 
3CF4:  MOVLW  BB
3CF6:  MOVLB  8
3CF8:  ADDWF  x75,W
3CFA:  MOVWF  FE9
3CFC:  MOVLW  06
3CFE:  ADDWFC x76,W
3D00:  MOVWF  FEA
3D02:  CLRF   FEF
....................              
....................             j=0; 
3D04:  CLRF   x76
3D06:  CLRF   x75
....................             i++; 
3D08:  INCF   x73,F
3D0A:  BTFSC  FD8.2
3D0C:  INCF   x74,F
....................              
....................             for(; ; i++,j++) 
....................             { 
....................                restart_wdt(); 
3D0E:  CLRWDT
....................                if((RxD_Buff[i] == 0x0D) || (j > 41)) 
3D10:  MOVLW  76
3D12:  ADDWF  x73,W
3D14:  MOVWF  FE9
3D16:  MOVLW  01
3D18:  ADDWFC x74,W
3D1A:  MOVWF  FEA
3D1C:  MOVF   FEF,W
3D1E:  SUBLW  0D
3D20:  BZ    3D2C
3D22:  MOVF   x76,F
3D24:  BNZ   3D2C
3D26:  MOVF   x75,W
3D28:  SUBLW  29
3D2A:  BC    3D7C
....................                { 
....................                   write_eeprom(0x5D+i,RxD_Buff[i]); 
3D2C:  MOVLW  5D
3D2E:  ADDWF  x73,W
3D30:  MOVWF  x79
3D32:  MOVLW  00
3D34:  ADDWFC x74,W
3D36:  MOVWF  x7A
3D38:  MOVLW  76
3D3A:  ADDWF  x73,W
3D3C:  MOVWF  FE9
3D3E:  MOVLW  01
3D40:  ADDWFC x74,W
3D42:  MOVWF  FEA
3D44:  MOVFF  FEF,87B
3D48:  MOVFF  87A,FAA
3D4C:  MOVFF  879,FA9
3D50:  MOVFF  87B,FA8
3D54:  BCF    FA6.6
3D56:  BCF    FA6.7
3D58:  BSF    FA6.2
3D5A:  MOVF   FF2,W
3D5C:  MOVWF  00
3D5E:  BCF    FF2.7
3D60:  MOVLB  F
3D62:  MOVLW  55
3D64:  MOVWF  FA7
3D66:  MOVLW  AA
3D68:  MOVWF  FA7
3D6A:  BSF    FA6.1
3D6C:  BTFSC  FA6.1
3D6E:  BRA    3D6C
3D70:  BCF    FA6.2
3D72:  MOVF   00,W
3D74:  IORWF  FF2,F
....................                   break; 
3D76:  BRA    3E04
....................                } 
....................                else 
3D78:  BRA    3DEE
3D7A:  MOVLB  8
....................                { 
....................                   SMS_Massage3[j] = RxD_Buff[i]; 
3D7C:  MOVLW  E4
3D7E:  ADDWF  x75,W
3D80:  MOVWF  01
3D82:  MOVLW  06
3D84:  ADDWFC x76,W
3D86:  MOVWF  03
3D88:  MOVLW  76
3D8A:  ADDWF  x73,W
3D8C:  MOVWF  FE9
3D8E:  MOVLW  01
3D90:  ADDWFC x74,W
3D92:  MOVWF  FEA
3D94:  MOVFF  FEF,87B
3D98:  MOVFF  03,FEA
3D9C:  MOVFF  01,FE9
3DA0:  MOVFF  87B,FEF
....................                   write_eeprom(0x5D+i,RxD_Buff[i]); 
3DA4:  MOVLW  5D
3DA6:  ADDWF  x73,W
3DA8:  MOVWF  x79
3DAA:  MOVLW  00
3DAC:  ADDWFC x74,W
3DAE:  MOVWF  x7A
3DB0:  MOVLW  76
3DB2:  ADDWF  x73,W
3DB4:  MOVWF  FE9
3DB6:  MOVLW  01
3DB8:  ADDWFC x74,W
3DBA:  MOVWF  FEA
3DBC:  MOVFF  FEF,87B
3DC0:  MOVFF  87A,FAA
3DC4:  MOVFF  879,FA9
3DC8:  MOVFF  87B,FA8
3DCC:  BCF    FA6.6
3DCE:  BCF    FA6.7
3DD0:  BSF    FA6.2
3DD2:  MOVF   FF2,W
3DD4:  MOVWF  00
3DD6:  BCF    FF2.7
3DD8:  MOVLB  F
3DDA:  MOVLW  55
3DDC:  MOVWF  FA7
3DDE:  MOVLW  AA
3DE0:  MOVWF  FA7
3DE2:  BSF    FA6.1
3DE4:  BTFSC  FA6.1
3DE6:  BRA    3DE4
3DE8:  BCF    FA6.2
3DEA:  MOVF   00,W
3DEC:  IORWF  FF2,F
....................                } 
....................             } 
3DEE:  MOVLB  8
3DF0:  MOVFF  874,03
3DF4:  MOVF   x73,W
3DF6:  INCF   x73,F
3DF8:  BTFSC  FD8.2
3DFA:  INCF   x74,F
3DFC:  INCF   x75,F
3DFE:  BTFSC  FD8.2
3E00:  INCF   x76,F
3E02:  BRA    3D0E
....................             SMS_Massage3[j] = '\0' ; // end string 
3E04:  MOVLW  E4
3E06:  MOVLB  8
3E08:  ADDWF  x75,W
3E0A:  MOVWF  FE9
3E0C:  MOVLW  06
3E0E:  ADDWFC x76,W
3E10:  MOVWF  FEA
3E12:  CLRF   FEF
....................              
....................             j=0; 
3E14:  CLRF   x76
3E16:  CLRF   x75
....................             i++; 
3E18:  INCF   x73,F
3E1A:  BTFSC  FD8.2
3E1C:  INCF   x74,F
....................              
....................             for(; ; i++,j++) 
....................             { 
....................                restart_wdt(); 
3E1E:  CLRWDT
....................                if((RxD_Buff[i] == 0x0D) || (j > 41)) 
3E20:  MOVLW  76
3E22:  ADDWF  x73,W
3E24:  MOVWF  FE9
3E26:  MOVLW  01
3E28:  ADDWFC x74,W
3E2A:  MOVWF  FEA
3E2C:  MOVF   FEF,W
3E2E:  SUBLW  0D
3E30:  BZ    3E3C
3E32:  MOVF   x76,F
3E34:  BNZ   3E3C
3E36:  MOVF   x75,W
3E38:  SUBLW  29
3E3A:  BC    3E8C
....................                { 
....................                   write_eeprom(0x5D+i,RxD_Buff[i]); 
3E3C:  MOVLW  5D
3E3E:  ADDWF  x73,W
3E40:  MOVWF  x79
3E42:  MOVLW  00
3E44:  ADDWFC x74,W
3E46:  MOVWF  x7A
3E48:  MOVLW  76
3E4A:  ADDWF  x73,W
3E4C:  MOVWF  FE9
3E4E:  MOVLW  01
3E50:  ADDWFC x74,W
3E52:  MOVWF  FEA
3E54:  MOVFF  FEF,87B
3E58:  MOVFF  87A,FAA
3E5C:  MOVFF  879,FA9
3E60:  MOVFF  87B,FA8
3E64:  BCF    FA6.6
3E66:  BCF    FA6.7
3E68:  BSF    FA6.2
3E6A:  MOVF   FF2,W
3E6C:  MOVWF  00
3E6E:  BCF    FF2.7
3E70:  MOVLB  F
3E72:  MOVLW  55
3E74:  MOVWF  FA7
3E76:  MOVLW  AA
3E78:  MOVWF  FA7
3E7A:  BSF    FA6.1
3E7C:  BTFSC  FA6.1
3E7E:  BRA    3E7C
3E80:  BCF    FA6.2
3E82:  MOVF   00,W
3E84:  IORWF  FF2,F
....................                   break; 
3E86:  BRA    3F14
....................                } 
....................                else 
3E88:  BRA    3EFE
3E8A:  MOVLB  8
....................                { 
....................                   SMS_Massage4[j] = RxD_Buff[i]; 
3E8C:  MOVLW  0D
3E8E:  ADDWF  x75,W
3E90:  MOVWF  01
3E92:  MOVLW  07
3E94:  ADDWFC x76,W
3E96:  MOVWF  03
3E98:  MOVLW  76
3E9A:  ADDWF  x73,W
3E9C:  MOVWF  FE9
3E9E:  MOVLW  01
3EA0:  ADDWFC x74,W
3EA2:  MOVWF  FEA
3EA4:  MOVFF  FEF,87B
3EA8:  MOVFF  03,FEA
3EAC:  MOVFF  01,FE9
3EB0:  MOVFF  87B,FEF
....................                   write_eeprom(0x5D+i,RxD_Buff[i]); 
3EB4:  MOVLW  5D
3EB6:  ADDWF  x73,W
3EB8:  MOVWF  x79
3EBA:  MOVLW  00
3EBC:  ADDWFC x74,W
3EBE:  MOVWF  x7A
3EC0:  MOVLW  76
3EC2:  ADDWF  x73,W
3EC4:  MOVWF  FE9
3EC6:  MOVLW  01
3EC8:  ADDWFC x74,W
3ECA:  MOVWF  FEA
3ECC:  MOVFF  FEF,87B
3ED0:  MOVFF  87A,FAA
3ED4:  MOVFF  879,FA9
3ED8:  MOVFF  87B,FA8
3EDC:  BCF    FA6.6
3EDE:  BCF    FA6.7
3EE0:  BSF    FA6.2
3EE2:  MOVF   FF2,W
3EE4:  MOVWF  00
3EE6:  BCF    FF2.7
3EE8:  MOVLB  F
3EEA:  MOVLW  55
3EEC:  MOVWF  FA7
3EEE:  MOVLW  AA
3EF0:  MOVWF  FA7
3EF2:  BSF    FA6.1
3EF4:  BTFSC  FA6.1
3EF6:  BRA    3EF4
3EF8:  BCF    FA6.2
3EFA:  MOVF   00,W
3EFC:  IORWF  FF2,F
....................                } 
....................             } 
3EFE:  MOVLB  8
3F00:  MOVFF  874,03
3F04:  MOVF   x73,W
3F06:  INCF   x73,F
3F08:  BTFSC  FD8.2
3F0A:  INCF   x74,F
3F0C:  INCF   x75,F
3F0E:  BTFSC  FD8.2
3F10:  INCF   x76,F
3F12:  BRA    3E1E
....................             SMS_Massage4[j] = '\0' ; // end string 
3F14:  MOVLW  0D
3F16:  MOVLB  8
3F18:  ADDWF  x75,W
3F1A:  MOVWF  FE9
3F1C:  MOVLW  07
3F1E:  ADDWFC x76,W
3F20:  MOVWF  FEA
3F22:  CLRF   FEF
....................              
....................             j=0; 
3F24:  CLRF   x76
3F26:  CLRF   x75
....................             i++; 
3F28:  INCF   x73,F
3F2A:  BTFSC  FD8.2
3F2C:  INCF   x74,F
....................              
....................             for(; ; i++,j++) 
....................             { 
....................                restart_wdt(); 
3F2E:  CLRWDT
....................                if((RxD_Buff[i] == 0x0D) || (j > 41)) 
3F30:  MOVLW  76
3F32:  ADDWF  x73,W
3F34:  MOVWF  FE9
3F36:  MOVLW  01
3F38:  ADDWFC x74,W
3F3A:  MOVWF  FEA
3F3C:  MOVF   FEF,W
3F3E:  SUBLW  0D
3F40:  BZ    3F4C
3F42:  MOVF   x76,F
3F44:  BNZ   3F4C
3F46:  MOVF   x75,W
3F48:  SUBLW  29
3F4A:  BC    3F9C
....................                { 
....................                   write_eeprom(0x5D+i,RxD_Buff[i]); 
3F4C:  MOVLW  5D
3F4E:  ADDWF  x73,W
3F50:  MOVWF  x79
3F52:  MOVLW  00
3F54:  ADDWFC x74,W
3F56:  MOVWF  x7A
3F58:  MOVLW  76
3F5A:  ADDWF  x73,W
3F5C:  MOVWF  FE9
3F5E:  MOVLW  01
3F60:  ADDWFC x74,W
3F62:  MOVWF  FEA
3F64:  MOVFF  FEF,87B
3F68:  MOVFF  87A,FAA
3F6C:  MOVFF  879,FA9
3F70:  MOVFF  87B,FA8
3F74:  BCF    FA6.6
3F76:  BCF    FA6.7
3F78:  BSF    FA6.2
3F7A:  MOVF   FF2,W
3F7C:  MOVWF  00
3F7E:  BCF    FF2.7
3F80:  MOVLB  F
3F82:  MOVLW  55
3F84:  MOVWF  FA7
3F86:  MOVLW  AA
3F88:  MOVWF  FA7
3F8A:  BSF    FA6.1
3F8C:  BTFSC  FA6.1
3F8E:  BRA    3F8C
3F90:  BCF    FA6.2
3F92:  MOVF   00,W
3F94:  IORWF  FF2,F
....................                   break; 
3F96:  BRA    4024
....................                } 
....................                else 
3F98:  BRA    400E
3F9A:  MOVLB  8
....................                { 
....................                   SMS_Massage5[j] = RxD_Buff[i]; 
3F9C:  MOVLW  36
3F9E:  ADDWF  x75,W
3FA0:  MOVWF  01
3FA2:  MOVLW  07
3FA4:  ADDWFC x76,W
3FA6:  MOVWF  03
3FA8:  MOVLW  76
3FAA:  ADDWF  x73,W
3FAC:  MOVWF  FE9
3FAE:  MOVLW  01
3FB0:  ADDWFC x74,W
3FB2:  MOVWF  FEA
3FB4:  MOVFF  FEF,87B
3FB8:  MOVFF  03,FEA
3FBC:  MOVFF  01,FE9
3FC0:  MOVFF  87B,FEF
....................                   write_eeprom(0x5D+i,RxD_Buff[i]); 
3FC4:  MOVLW  5D
3FC6:  ADDWF  x73,W
3FC8:  MOVWF  x79
3FCA:  MOVLW  00
3FCC:  ADDWFC x74,W
3FCE:  MOVWF  x7A
3FD0:  MOVLW  76
3FD2:  ADDWF  x73,W
3FD4:  MOVWF  FE9
3FD6:  MOVLW  01
3FD8:  ADDWFC x74,W
3FDA:  MOVWF  FEA
3FDC:  MOVFF  FEF,87B
3FE0:  MOVFF  87A,FAA
3FE4:  MOVFF  879,FA9
3FE8:  MOVFF  87B,FA8
3FEC:  BCF    FA6.6
3FEE:  BCF    FA6.7
3FF0:  BSF    FA6.2
3FF2:  MOVF   FF2,W
3FF4:  MOVWF  00
3FF6:  BCF    FF2.7
3FF8:  MOVLB  F
3FFA:  MOVLW  55
3FFC:  MOVWF  FA7
3FFE:  MOVLW  AA
4000:  MOVWF  FA7
4002:  BSF    FA6.1
4004:  BTFSC  FA6.1
4006:  BRA    4004
4008:  BCF    FA6.2
400A:  MOVF   00,W
400C:  IORWF  FF2,F
....................                } 
....................             } 
400E:  MOVLB  8
4010:  MOVFF  874,03
4014:  MOVF   x73,W
4016:  INCF   x73,F
4018:  BTFSC  FD8.2
401A:  INCF   x74,F
401C:  INCF   x75,F
401E:  BTFSC  FD8.2
4020:  INCF   x76,F
4022:  BRA    3F2E
....................             SMS_Massage5[j] = '\0' ; // end string 
4024:  MOVLW  36
4026:  MOVLB  8
4028:  ADDWF  x75,W
402A:  MOVWF  FE9
402C:  MOVLW  07
402E:  ADDWFC x76,W
4030:  MOVWF  FEA
4032:  CLRF   FEF
....................              
....................             j=0; 
4034:  CLRF   x76
4036:  CLRF   x75
....................             i++; 
4038:  INCF   x73,F
403A:  BTFSC  FD8.2
403C:  INCF   x74,F
....................              
....................             for(; ; i++,j++) 
....................             { 
....................                restart_wdt(); 
403E:  CLRWDT
....................                if((RxD_Buff[i] == 0x0D) || (j > 41)) 
4040:  MOVLW  76
4042:  ADDWF  x73,W
4044:  MOVWF  FE9
4046:  MOVLW  01
4048:  ADDWFC x74,W
404A:  MOVWF  FEA
404C:  MOVF   FEF,W
404E:  SUBLW  0D
4050:  BZ    405C
4052:  MOVF   x76,F
4054:  BNZ   405C
4056:  MOVF   x75,W
4058:  SUBLW  29
405A:  BC    40AC
....................                { 
....................                   write_eeprom(0x5D+i,RxD_Buff[i]); 
405C:  MOVLW  5D
405E:  ADDWF  x73,W
4060:  MOVWF  x79
4062:  MOVLW  00
4064:  ADDWFC x74,W
4066:  MOVWF  x7A
4068:  MOVLW  76
406A:  ADDWF  x73,W
406C:  MOVWF  FE9
406E:  MOVLW  01
4070:  ADDWFC x74,W
4072:  MOVWF  FEA
4074:  MOVFF  FEF,87B
4078:  MOVFF  87A,FAA
407C:  MOVFF  879,FA9
4080:  MOVFF  87B,FA8
4084:  BCF    FA6.6
4086:  BCF    FA6.7
4088:  BSF    FA6.2
408A:  MOVF   FF2,W
408C:  MOVWF  00
408E:  BCF    FF2.7
4090:  MOVLB  F
4092:  MOVLW  55
4094:  MOVWF  FA7
4096:  MOVLW  AA
4098:  MOVWF  FA7
409A:  BSF    FA6.1
409C:  BTFSC  FA6.1
409E:  BRA    409C
40A0:  BCF    FA6.2
40A2:  MOVF   00,W
40A4:  IORWF  FF2,F
....................                   break; 
40A6:  BRA    4138
....................                } 
....................                else 
40A8:  BRA    4122
40AA:  MOVLB  8
....................                { 
....................                   write_eeprom(0x5D+i,RxD_Buff[i]); 
40AC:  MOVLW  5D
40AE:  ADDWF  x73,W
40B0:  MOVWF  x79
40B2:  MOVLW  00
40B4:  ADDWFC x74,W
40B6:  MOVWF  x7A
40B8:  MOVLW  76
40BA:  ADDWF  x73,W
40BC:  MOVWF  FE9
40BE:  MOVLW  01
40C0:  ADDWFC x74,W
40C2:  MOVWF  FEA
40C4:  MOVFF  FEF,87B
40C8:  MOVFF  87A,FAA
40CC:  MOVFF  879,FA9
40D0:  MOVFF  87B,FA8
40D4:  BCF    FA6.6
40D6:  BCF    FA6.7
40D8:  BSF    FA6.2
40DA:  MOVF   FF2,W
40DC:  MOVWF  00
40DE:  BCF    FF2.7
40E0:  MOVLB  F
40E2:  MOVLW  55
40E4:  MOVWF  FA7
40E6:  MOVLW  AA
40E8:  MOVWF  FA7
40EA:  BSF    FA6.1
40EC:  BTFSC  FA6.1
40EE:  BRA    40EC
40F0:  BCF    FA6.2
40F2:  MOVF   00,W
40F4:  IORWF  FF2,F
....................                   SMS_Massage6[j] = RxD_Buff[i]; 
40F6:  MOVLW  5F
40F8:  MOVLB  8
40FA:  ADDWF  x75,W
40FC:  MOVWF  01
40FE:  MOVLW  07
4100:  ADDWFC x76,W
4102:  MOVWF  03
4104:  MOVLW  76
4106:  ADDWF  x73,W
4108:  MOVWF  FE9
410A:  MOVLW  01
410C:  ADDWFC x74,W
410E:  MOVWF  FEA
4110:  MOVFF  FEF,87B
4114:  MOVFF  03,FEA
4118:  MOVFF  01,FE9
411C:  MOVFF  87B,FEF
4120:  MOVLB  F
....................                } 
....................             } 
4122:  MOVLB  8
4124:  MOVFF  874,03
4128:  MOVF   x73,W
412A:  INCF   x73,F
412C:  BTFSC  FD8.2
412E:  INCF   x74,F
4130:  INCF   x75,F
4132:  BTFSC  FD8.2
4134:  INCF   x76,F
4136:  BRA    403E
....................             SMS_Massage6[j] = '\0' ; // end string 
4138:  MOVLW  5F
413A:  MOVLB  8
413C:  ADDWF  x75,W
413E:  MOVWF  FE9
4140:  MOVLW  07
4142:  ADDWFC x76,W
4144:  MOVWF  FEA
4146:  CLRF   FEF
....................              
....................             j=0; 
4148:  CLRF   x76
414A:  CLRF   x75
....................             i++; 
414C:  INCF   x73,F
414E:  BTFSC  FD8.2
4150:  INCF   x74,F
....................              
....................             for(; ; i++,j++) 
....................             { 
....................                restart_wdt(); 
4152:  CLRWDT
....................                if((RxD_Buff[i] == 0x0D) || (j > 41)) 
4154:  MOVLW  76
4156:  ADDWF  x73,W
4158:  MOVWF  FE9
415A:  MOVLW  01
415C:  ADDWFC x74,W
415E:  MOVWF  FEA
4160:  MOVF   FEF,W
4162:  SUBLW  0D
4164:  BZ    4170
4166:  MOVF   x76,F
4168:  BNZ   4170
416A:  MOVF   x75,W
416C:  SUBLW  29
416E:  BC    41C0
....................                { 
....................                   write_eeprom(0x5D+i,RxD_Buff[i]); 
4170:  MOVLW  5D
4172:  ADDWF  x73,W
4174:  MOVWF  x79
4176:  MOVLW  00
4178:  ADDWFC x74,W
417A:  MOVWF  x7A
417C:  MOVLW  76
417E:  ADDWF  x73,W
4180:  MOVWF  FE9
4182:  MOVLW  01
4184:  ADDWFC x74,W
4186:  MOVWF  FEA
4188:  MOVFF  FEF,87B
418C:  MOVFF  87A,FAA
4190:  MOVFF  879,FA9
4194:  MOVFF  87B,FA8
4198:  BCF    FA6.6
419A:  BCF    FA6.7
419C:  BSF    FA6.2
419E:  MOVF   FF2,W
41A0:  MOVWF  00
41A2:  BCF    FF2.7
41A4:  MOVLB  F
41A6:  MOVLW  55
41A8:  MOVWF  FA7
41AA:  MOVLW  AA
41AC:  MOVWF  FA7
41AE:  BSF    FA6.1
41B0:  BTFSC  FA6.1
41B2:  BRA    41B0
41B4:  BCF    FA6.2
41B6:  MOVF   00,W
41B8:  IORWF  FF2,F
....................                   break; 
41BA:  BRA    4248
....................                } 
....................                else 
41BC:  BRA    4232
41BE:  MOVLB  8
....................                { 
....................                   SMS_Massage7[j] = RxD_Buff[i]; 
41C0:  MOVLW  88
41C2:  ADDWF  x75,W
41C4:  MOVWF  01
41C6:  MOVLW  07
41C8:  ADDWFC x76,W
41CA:  MOVWF  03
41CC:  MOVLW  76
41CE:  ADDWF  x73,W
41D0:  MOVWF  FE9
41D2:  MOVLW  01
41D4:  ADDWFC x74,W
41D6:  MOVWF  FEA
41D8:  MOVFF  FEF,87B
41DC:  MOVFF  03,FEA
41E0:  MOVFF  01,FE9
41E4:  MOVFF  87B,FEF
....................                   write_eeprom(0x5D+i,RxD_Buff[i]); 
41E8:  MOVLW  5D
41EA:  ADDWF  x73,W
41EC:  MOVWF  x79
41EE:  MOVLW  00
41F0:  ADDWFC x74,W
41F2:  MOVWF  x7A
41F4:  MOVLW  76
41F6:  ADDWF  x73,W
41F8:  MOVWF  FE9
41FA:  MOVLW  01
41FC:  ADDWFC x74,W
41FE:  MOVWF  FEA
4200:  MOVFF  FEF,87B
4204:  MOVFF  87A,FAA
4208:  MOVFF  879,FA9
420C:  MOVFF  87B,FA8
4210:  BCF    FA6.6
4212:  BCF    FA6.7
4214:  BSF    FA6.2
4216:  MOVF   FF2,W
4218:  MOVWF  00
421A:  BCF    FF2.7
421C:  MOVLB  F
421E:  MOVLW  55
4220:  MOVWF  FA7
4222:  MOVLW  AA
4224:  MOVWF  FA7
4226:  BSF    FA6.1
4228:  BTFSC  FA6.1
422A:  BRA    4228
422C:  BCF    FA6.2
422E:  MOVF   00,W
4230:  IORWF  FF2,F
....................                } 
....................             } 
4232:  MOVLB  8
4234:  MOVFF  874,03
4238:  MOVF   x73,W
423A:  INCF   x73,F
423C:  BTFSC  FD8.2
423E:  INCF   x74,F
4240:  INCF   x75,F
4242:  BTFSC  FD8.2
4244:  INCF   x76,F
4246:  BRA    4152
....................             SMS_Massage7[j] = '\0' ; // end string 
4248:  MOVLW  88
424A:  MOVLB  8
424C:  ADDWF  x75,W
424E:  MOVWF  FE9
4250:  MOVLW  07
4252:  ADDWFC x76,W
4254:  MOVWF  FEA
4256:  CLRF   FEF
....................              
....................             j=0; 
4258:  CLRF   x76
425A:  CLRF   x75
....................             i++; 
425C:  INCF   x73,F
425E:  BTFSC  FD8.2
4260:  INCF   x74,F
....................              
....................             for(; ; i++,j++) 
....................             { 
....................                restart_wdt(); 
4262:  CLRWDT
....................                if((RxD_Buff[i] == 0x0D) || (j > 41)) 
4264:  MOVLW  76
4266:  ADDWF  x73,W
4268:  MOVWF  FE9
426A:  MOVLW  01
426C:  ADDWFC x74,W
426E:  MOVWF  FEA
4270:  MOVF   FEF,W
4272:  SUBLW  0D
4274:  BZ    4280
4276:  MOVF   x76,F
4278:  BNZ   4280
427A:  MOVF   x75,W
427C:  SUBLW  29
427E:  BC    42D0
....................                { 
....................                   write_eeprom(0x5D+i,RxD_Buff[i]); 
4280:  MOVLW  5D
4282:  ADDWF  x73,W
4284:  MOVWF  x79
4286:  MOVLW  00
4288:  ADDWFC x74,W
428A:  MOVWF  x7A
428C:  MOVLW  76
428E:  ADDWF  x73,W
4290:  MOVWF  FE9
4292:  MOVLW  01
4294:  ADDWFC x74,W
4296:  MOVWF  FEA
4298:  MOVFF  FEF,87B
429C:  MOVFF  87A,FAA
42A0:  MOVFF  879,FA9
42A4:  MOVFF  87B,FA8
42A8:  BCF    FA6.6
42AA:  BCF    FA6.7
42AC:  BSF    FA6.2
42AE:  MOVF   FF2,W
42B0:  MOVWF  00
42B2:  BCF    FF2.7
42B4:  MOVLB  F
42B6:  MOVLW  55
42B8:  MOVWF  FA7
42BA:  MOVLW  AA
42BC:  MOVWF  FA7
42BE:  BSF    FA6.1
42C0:  BTFSC  FA6.1
42C2:  BRA    42C0
42C4:  BCF    FA6.2
42C6:  MOVF   00,W
42C8:  IORWF  FF2,F
....................                   break; 
42CA:  BRA    4358
....................                } 
....................                else 
42CC:  BRA    4342
42CE:  MOVLB  8
....................                { 
....................                   SMS_Massage8[j] = RxD_Buff[i]; 
42D0:  MOVLW  B1
42D2:  ADDWF  x75,W
42D4:  MOVWF  01
42D6:  MOVLW  07
42D8:  ADDWFC x76,W
42DA:  MOVWF  03
42DC:  MOVLW  76
42DE:  ADDWF  x73,W
42E0:  MOVWF  FE9
42E2:  MOVLW  01
42E4:  ADDWFC x74,W
42E6:  MOVWF  FEA
42E8:  MOVFF  FEF,87B
42EC:  MOVFF  03,FEA
42F0:  MOVFF  01,FE9
42F4:  MOVFF  87B,FEF
....................                   write_eeprom(0x5D+i,RxD_Buff[i]); 
42F8:  MOVLW  5D
42FA:  ADDWF  x73,W
42FC:  MOVWF  x79
42FE:  MOVLW  00
4300:  ADDWFC x74,W
4302:  MOVWF  x7A
4304:  MOVLW  76
4306:  ADDWF  x73,W
4308:  MOVWF  FE9
430A:  MOVLW  01
430C:  ADDWFC x74,W
430E:  MOVWF  FEA
4310:  MOVFF  FEF,87B
4314:  MOVFF  87A,FAA
4318:  MOVFF  879,FA9
431C:  MOVFF  87B,FA8
4320:  BCF    FA6.6
4322:  BCF    FA6.7
4324:  BSF    FA6.2
4326:  MOVF   FF2,W
4328:  MOVWF  00
432A:  BCF    FF2.7
432C:  MOVLB  F
432E:  MOVLW  55
4330:  MOVWF  FA7
4332:  MOVLW  AA
4334:  MOVWF  FA7
4336:  BSF    FA6.1
4338:  BTFSC  FA6.1
433A:  BRA    4338
433C:  BCF    FA6.2
433E:  MOVF   00,W
4340:  IORWF  FF2,F
....................                } 
....................             } 
4342:  MOVLB  8
4344:  MOVFF  874,03
4348:  MOVF   x73,W
434A:  INCF   x73,F
434C:  BTFSC  FD8.2
434E:  INCF   x74,F
4350:  INCF   x75,F
4352:  BTFSC  FD8.2
4354:  INCF   x76,F
4356:  BRA    4262
....................             SMS_Massage8[j] = '\0' ; // end string 
4358:  MOVLW  B1
435A:  MOVLB  8
435C:  ADDWF  x75,W
435E:  MOVWF  FE9
4360:  MOVLW  07
4362:  ADDWFC x76,W
4364:  MOVWF  FEA
4366:  CLRF   FEF
....................              
....................           
....................             TxD_Buff[0] = Address ;         //Address 
4368:  MOVFF  75,77
....................             TxD_Buff[1] = 0x21 ;            //return function code 
436C:  MOVLW  21
436E:  MOVWF  78
....................  
....................             CRC(TxD_Buff,2)   ;            //Cal CRC 2 byte 
4370:  CLRF   x7B
4372:  MOVLW  77
4374:  MOVWF  x7A
4376:  MOVLW  02
4378:  MOVWF  x7C
437A:  MOVLB  0
437C:  CALL   1F56
....................  
....................             TxD_Buff[2] = CRC_Hi ; 
4380:  MOVFF  577,79
....................             TxD_Buff[3] = CRC_Lo ; 
4384:  MOVFF  576,7A
....................  
....................             output_bit(P485ctrl,1); 
4388:  BSF    F8A.3
438A:  BCF    F93.3
....................             delay_ms(10); 
438C:  MOVLW  0A
438E:  MOVLB  8
4390:  MOVWF  x79
4392:  MOVLB  0
4394:  CALL   0772
....................  
....................             putc(Txd_Buff[0]); 
4398:  MOVF   77,W
439A:  CALL   1F4C
....................             putc(Txd_Buff[1]); 
439E:  MOVF   78,W
43A0:  CALL   1F4C
....................             putc(Txd_Buff[2]); 
43A4:  MOVF   79,W
43A6:  CALL   1F4C
....................             putc(Txd_Buff[3]); 
43AA:  MOVF   7A,W
43AC:  CALL   1F4C
....................  
....................             delay_ms(3); 
43B0:  MOVLW  03
43B2:  MOVLB  8
43B4:  MOVWF  x79
43B6:  MOVLB  0
43B8:  CALL   0772
....................             output_bit(P485ctrl,0); 
43BC:  BCF    F8A.3
43BE:  BCF    F93.3
....................          } 
....................  
....................          if(RxD_Buff[1] == 0x03)///////////// READ HOLDING REGGISTER ///////////////////// 
43C0:  MOVLB  1
43C2:  MOVF   x77,W
43C4:  SUBLW  03
43C6:  BNZ   4452
....................          { 
....................  
....................             Data_Buff[0] = 0x00;// dummy data 
43C8:  MOVLB  5
43CA:  CLRF   x7F
....................             Data_Buff[1] = Input1_8; 
43CC:  MOVFF  46,580
....................              
....................              
....................             TxD_Buff[0] = Address ;         //Address 
43D0:  MOVFF  75,77
....................             TxD_Buff[1] = 0x03 ;           //Function Code 
43D4:  MOVLW  03
43D6:  MOVWF  78
....................             TxD_Buff[2] = 0x02 ;          //Byte Count 
43D8:  MOVLW  02
43DA:  MOVWF  79
....................             TxD_Buff[3] = Data_Buff[0];   //first byte Data 
43DC:  MOVFF  57F,7A
....................             TxD_Buff[4] = Data_Buff[1];   //first byte Data 
43E0:  MOVFF  580,7B
....................  
....................             CRC(TxD_Buff,5)   ;            //Cal CRC 5 Byte 
43E4:  MOVLB  8
43E6:  CLRF   x7B
43E8:  MOVLW  77
43EA:  MOVWF  x7A
43EC:  MOVLW  05
43EE:  MOVWF  x7C
43F0:  MOVLB  0
43F2:  CALL   1F56
....................  
....................             TxD_Buff[5] = CRC_Hi ; 
43F6:  MOVFF  577,7C
....................             TxD_Buff[6] = CRC_Lo ; 
43FA:  MOVFF  576,7D
....................  
....................  
....................             output_bit(P485ctrl,1); 
43FE:  BSF    F8A.3
4400:  BCF    F93.3
....................             restart_wdt(); 
4402:  CLRWDT
....................             delay_ms(4); 
4404:  MOVLW  04
4406:  MOVLB  8
4408:  MOVWF  x79
440A:  MOVLB  0
440C:  CALL   0772
....................             restart_wdt(); 
4410:  CLRWDT
....................  
....................             putc(TxD_Buff[0]) ;               //Address 
4412:  MOVF   77,W
4414:  CALL   1F4C
....................             putc(TxD_Buff[1]) ;               //Function Code 
4418:  MOVF   78,W
441A:  CALL   1F4C
....................             putc(TxD_Buff[2]) ;               //Byte Count 
441E:  MOVF   79,W
4420:  CALL   1F4C
....................             putc(TxD_Buff[3]) ; 
4424:  MOVF   7A,W
4426:  CALL   1F4C
....................             putc(TxD_Buff[4]) ; 
442A:  MOVF   7B,W
442C:  CALL   1F4C
....................             putc(TxD_Buff[5]) ; 
4430:  MOVF   7C,W
4432:  CALL   1F4C
....................             putc(TxD_Buff[6]) ; 
4436:  MOVF   7D,W
4438:  CALL   1F4C
....................  
....................             restart_wdt(); 
443C:  CLRWDT
....................             delay_ms(3); 
443E:  MOVLW  03
4440:  MOVLB  8
4442:  MOVWF  x79
4444:  MOVLB  0
4446:  CALL   0772
....................             restart_wdt(); 
444A:  CLRWDT
....................             output_bit(P485ctrl,0); 
444C:  BCF    F8A.3
444E:  BCF    F93.3
4450:  MOVLB  1
....................  
....................          } 
....................         
....................        /*-----JACK Comment 18/6/58----------// 
....................          else 
....................          { 
....................             //Invalid function 
....................             TxD_Buff[0] = Address ;         //Address 
....................             TxD_Buff[1] = 0x81 ;         //Function Code 
....................             TxD_Buff[2] = 0x01 ;         //illegal function 
....................  
....................             CRC(TxD_Buff,3)   ;            //Cal CRC 3 Byte 
....................  
....................             TxD_Buff[3] = CRC_Hi ; 
....................             TxD_Buff[4] = CRC_Lo ; 
....................  
....................             output_bit(P485ctrl,1); 
....................             delay_ms(10); 
....................  
....................             putc(Txd_Buff[0]); 
....................             putc(Txd_Buff[1]); 
....................             putc(Txd_Buff[2]); 
....................             putc(Txd_Buff[3]); 
....................             putc(Txd_Buff[4]); 
....................  
....................             delay_ms(3); 
....................             output_bit(P485ctrl,0); 
....................          } 
....................        *///-----JACK Comment----------// 
....................       }   
....................  
....................       Send_check_Time = 500; //5 Second 
4452:  MOVLW  01
4454:  MOVLB  5
4456:  MOVWF  x79
4458:  MOVLW  F4
445A:  MOVWF  x78
....................    } // if crc 
....................  
....................    recieve_completed = 0 ; 
445C:  BCF    2D.5
....................    sequence = end_sq ; 
445E:  MOVFF  6C,74
....................    T_timeout = 0x00; 
4462:  MOVLB  6
4464:  CLRF   x80
....................    RxD_DataLen = 0x00 ; 
4466:  CLRF   76
....................    output_bit(P485ctrl,0); 
4468:  BCF    F8A.3
446A:  BCF    F93.3
.................... } 
446C:  MOVLB  0
446E:  GOTO   6AB4 (RETURN)
....................  
....................  
.................... //////////////////////////////////////////////////////////////////// 
....................  
.................... void Read_Input(void) 
.................... { 
....................    //if(NoOfPoint >= 10) 
....................    //{ 
....................       // if(NoOfPoint >= 20) 
....................    //{    
....................       
....................       ///////////////////////--Edit--/////////////////// 
....................       MCP23s17_Ip_dat = IO_INPUT_A(IO_DEVICE_1); 
*
15B8:  MOVLW  02
15BA:  MOVLB  8
15BC:  MOVWF  x7A
15BE:  MOVLB  0
15C0:  BRA    14A0
15C2:  MOVFF  01,67E
....................            
....................       if (AutoTestFlag)  // TEST FROM MODBUS 
15C6:  BTFSS  17.4
15C8:  BRA    15D0
....................       { 
....................          MCP23s17_Ip_dat = ~MCP23s17_Ip_dat; 
15CA:  MOVLB  6
15CC:  COMF   x7E,F
15CE:  MOVLB  0
....................           
....................       } 
....................        
....................      // FaultNow[11] = MCP23s17_Ip_dat; 
....................       FaultNow[1] = MCP23s17_Ip_dat >> 1; 
15D0:  BCF    FD8.0
15D2:  MOVLB  6
15D4:  RRCF   x7E,W
15D6:  MOVLB  7
15D8:  BCF    xED.1
15DA:  BTFSC  FE8.0
15DC:  BSF    xED.1
....................       FaultNow[2] = MCP23s17_Ip_dat >> 2; 
15DE:  MOVLB  6
15E0:  RRCF   x7E,W
15E2:  MOVWF  00
15E4:  RRCF   00,F
15E6:  MOVLW  3F
15E8:  ANDWF  00,F
15EA:  MOVLB  7
15EC:  BCF    xED.2
15EE:  BTFSC  00.0
15F0:  BSF    xED.2
....................       FaultNow[3] = MCP23s17_Ip_dat >> 3; 
15F2:  MOVLB  6
15F4:  RRCF   x7E,W
15F6:  MOVWF  00
15F8:  RRCF   00,F
15FA:  RRCF   00,F
15FC:  MOVLW  1F
15FE:  ANDWF  00,F
1600:  MOVLB  7
1602:  BCF    xED.3
1604:  BTFSC  00.0
1606:  BSF    xED.3
....................       FaultNow[4] = MCP23s17_Ip_dat >> 4; 
1608:  MOVLB  6
160A:  SWAPF  x7E,W
160C:  MOVWF  00
160E:  MOVLW  0F
1610:  ANDWF  00,F
1612:  MOVLB  7
1614:  BCF    xED.4
1616:  BTFSC  00.0
1618:  BSF    xED.4
....................       FaultNow[5] = MCP23s17_Ip_dat >> 5; 
161A:  MOVLB  6
161C:  SWAPF  x7E,W
161E:  MOVWF  00
1620:  RRCF   00,F
1622:  MOVLW  07
1624:  ANDWF  00,F
1626:  MOVLB  7
1628:  BCF    xED.5
162A:  BTFSC  00.0
162C:  BSF    xED.5
....................       FaultNow[6] = MCP23s17_Ip_dat >> 6; 
162E:  MOVLB  6
1630:  SWAPF  x7E,W
1632:  MOVWF  00
1634:  RRCF   00,F
1636:  RRCF   00,F
1638:  MOVLW  03
163A:  ANDWF  00,F
163C:  MOVLB  7
163E:  BCF    xED.6
1640:  BTFSC  00.0
1642:  BSF    xED.6
....................       FaultNow[7] = MCP23s17_Ip_dat >> 7; 
1644:  CLRF   00
1646:  MOVLB  6
1648:  BTFSC  x7E.7
164A:  BSF    00.0
164C:  MOVLB  7
164E:  BCF    xED.7
1650:  BTFSC  00.0
1652:  BSF    xED.7
....................        
....................       MCP23s17_Ip_dat = IO_INPUT_B(IO_DEVICE_1); 
1654:  MOVLW  02
1656:  MOVLB  8
1658:  MOVWF  x7A
165A:  MOVLB  0
165C:  BRA    14BE
165E:  MOVFF  01,67E
....................        
....................       if (AutoTestFlag)  // TEST FROM MODBUS 
1662:  BTFSS  17.4
1664:  BRA    166A
....................       { 
....................          MCP23s17_Ip_dat = ~MCP23s17_Ip_dat; 
1666:  MOVLB  6
1668:  COMF   x7E,F
....................       } 
....................        
....................       FaultNow[8] = MCP23s17_Ip_dat; 
166A:  MOVLB  7
166C:  BCF    xEE.0
166E:  MOVLB  6
1670:  BTFSS  x7E.0
1672:  BRA    167A
1674:  MOVLB  7
1676:  BSF    xEE.0
1678:  MOVLB  6
....................        
....................  
....................       ///////////////---Anal Fault---////////////////// 
....................       unsigned char i; 
....................       for( i=1; i<=8; i++) 
167A:  MOVLW  01
167C:  MOVLB  8
167E:  MOVWF  x79
1680:  MOVF   x79,W
1682:  SUBLW  08
1684:  BTFSS  FD8.0
1686:  BRA    1BB0
....................       { 
....................          if(FaultNCNO[i] ==NO) 
1688:  MOVFF  879,87B
168C:  MOVLW  08
168E:  MOVWF  x7D
1690:  MOVLW  69
1692:  MOVWF  x7C
1694:  MOVLB  0
1696:  RCALL  14DC
1698:  MOVLW  00
169A:  BTFSC  01.0
169C:  MOVLW  01
169E:  ANDLW  01
16A0:  SUBLW  01
16A2:  BTFSS  FD8.2
16A4:  BRA    1918
....................          { 
....................              if(FaultNow[i]==0) 
16A6:  MOVFF  879,87B
16AA:  MOVLW  07
16AC:  MOVLB  8
16AE:  MOVWF  x7D
16B0:  MOVLW  ED
16B2:  MOVWF  x7C
16B4:  MOVLB  0
16B6:  RCALL  14DC
16B8:  MOVLW  00
16BA:  BTFSC  01.0
16BC:  MOVLW  01
16BE:  ANDLW  01
16C0:  BTFSS  FD8.2
16C2:  BRA    17EE
....................              {    
....................                if(FaultAgo[i]==0) 
16C4:  MOVFF  879,87B
16C8:  MOVLW  07
16CA:  MOVLB  8
16CC:  MOVWF  x7D
16CE:  MOVLW  E9
16D0:  MOVWF  x7C
16D2:  MOVLB  0
16D4:  RCALL  14DC
16D6:  MOVLW  00
16D8:  BTFSC  01.0
16DA:  MOVLW  01
16DC:  ANDLW  01
16DE:  BTFSS  FD8.2
16E0:  BRA    17D2
....................                { 
....................                    ReleaseTime[i]++; 
16E2:  BCF    FD8.0
16E4:  MOVLB  8
16E6:  RLCF   x79,W
16E8:  CLRF   03
16EA:  ADDLW  F1
16EC:  MOVWF  FE9
16EE:  MOVLW  07
16F0:  ADDWFC 03,W
16F2:  MOVWF  FEA
16F4:  MOVLW  01
16F6:  ADDWF  FEE,F
16F8:  BNC   16FC
16FA:  INCF   FEF,F
....................                    
....................                    if(ReleaseTime[i]>=((FaultDelayTime[i]*75)+15)) //time per loop are 368 microSec. (1.89*10=200ms) 
16FC:  BCF    FD8.0
16FE:  RLCF   x79,W
1700:  CLRF   03
1702:  ADDLW  F1
1704:  MOVWF  FE9
1706:  MOVLW  07
1708:  ADDWFC 03,W
170A:  MOVWF  FEA
170C:  MOVFF  FEC,87B
1710:  MOVF   FED,F
1712:  MOVFF  FEF,87A
1716:  BCF    FD8.0
1718:  RLCF   x79,W
171A:  CLRF   03
171C:  ADDLW  2D
171E:  MOVWF  FE9
1720:  MOVLW  08
1722:  ADDWFC 03,W
1724:  MOVWF  FEA
1726:  MOVFF  FEC,87D
172A:  MOVF   FED,F
172C:  MOVFF  FEF,87C
1730:  MOVFF  87D,87F
1734:  MOVFF  87C,87E
1738:  CLRF   x81
173A:  MOVLW  4B
173C:  MOVWF  x80
173E:  MOVLB  0
1740:  RCALL  150E
1742:  MOVFF  02,87D
1746:  MOVFF  01,87C
174A:  MOVLW  0F
174C:  MOVLB  8
174E:  ADDWF  01,W
1750:  MOVWF  01
1752:  MOVLW  00
1754:  ADDWFC 02,W
1756:  MOVWF  03
1758:  MOVF   03,W
175A:  SUBWF  x7B,W
175C:  BNC   17CE
175E:  BNZ   1766
1760:  MOVF   01,W
1762:  SUBWF  x7A,W
1764:  BNC   17CE
....................                    {    
....................                      ReleaseTime[i] = 0; 
1766:  BCF    FD8.0
1768:  RLCF   x79,W
176A:  CLRF   03
176C:  ADDLW  F1
176E:  MOVWF  FE9
1770:  MOVLW  07
1772:  ADDWFC 03,W
1774:  MOVWF  FEA
1776:  CLRF   FEC
1778:  MOVF   FED,F
177A:  CLRF   FEF
....................                      switch(i) 
....................                      { 
177C:  MOVLW  01
177E:  SUBWF  x79,W
1780:  ADDLW  F8
1782:  BC    17CE
1784:  ADDLW  08
1786:  MOVLB  0
1788:  GOTO   1C52
....................                         case 1: 
....................                            Input.B1 = 0;  
178C:  MOVLB  7
178E:  BCF    xDA.0
....................                         break; 
1790:  MOVLB  8
1792:  BRA    17CE
....................                         case 2: 
....................                            Input.B2 = 0;  
1794:  MOVLB  7
1796:  BCF    xDA.1
....................                         break; 
1798:  MOVLB  8
179A:  BRA    17CE
....................                         case 3: 
....................                            Input.B3 = 0;  
179C:  MOVLB  7
179E:  BCF    xDA.2
....................                         break; 
17A0:  MOVLB  8
17A2:  BRA    17CE
....................                         case 4: 
....................                            Input.B4 = 0;  
17A4:  MOVLB  7
17A6:  BCF    xDA.3
....................                         break; 
17A8:  MOVLB  8
17AA:  BRA    17CE
....................                         case 5: 
....................                            Input.B5 = 0;  
17AC:  MOVLB  7
17AE:  BCF    xDA.4
....................                         break; 
17B0:  MOVLB  8
17B2:  BRA    17CE
....................                         case 6: 
....................                            Input.B6 = 0;  
17B4:  MOVLB  7
17B6:  BCF    xDA.5
....................                         break; 
17B8:  MOVLB  8
17BA:  BRA    17CE
....................                         case 7: 
....................                            Input.B7 = 0;  
17BC:  MOVLB  7
17BE:  BCF    xDA.6
....................                          break; 
17C0:  MOVLB  8
17C2:  BRA    17CE
....................                          case 8: 
....................                            Input.B8 = 0;  
17C4:  MOVLB  7
17C6:  BCF    xDA.7
....................                         break; 
17C8:  MOVLB  8
17CA:  BRA    17CE
17CC:  MOVLB  8
....................             
....................                      }                  
....................                    } 
....................                } 
....................                else 
17CE:  BRA    17EA
17D0:  MOVLB  0
....................                { 
....................                   ReleaseTime[i] = 0; 
17D2:  BCF    FD8.0
17D4:  MOVLB  8
17D6:  RLCF   x79,W
17D8:  CLRF   03
17DA:  ADDLW  F1
17DC:  MOVWF  FE9
17DE:  MOVLW  07
17E0:  ADDWFC 03,W
17E2:  MOVWF  FEA
17E4:  CLRF   FEC
17E6:  MOVF   FED,F
17E8:  CLRF   FEF
....................                } 
....................              } 
....................              else //if(FaultNow[i]==1 
17EA:  BRA    1916
17EC:  MOVLB  0
....................              { 
....................                if(FaultAgo[i]==1) 
17EE:  MOVFF  879,87B
17F2:  MOVLW  07
17F4:  MOVLB  8
17F6:  MOVWF  x7D
17F8:  MOVLW  E9
17FA:  MOVWF  x7C
17FC:  MOVLB  0
17FE:  RCALL  14DC
1800:  MOVLW  00
1802:  BTFSC  01.0
1804:  MOVLW  01
1806:  ANDLW  01
1808:  SUBLW  01
180A:  BTFSS  FD8.2
180C:  BRA    18FE
....................                { 
....................                    ReleaseTime[i]++; 
180E:  BCF    FD8.0
1810:  MOVLB  8
1812:  RLCF   x79,W
1814:  CLRF   03
1816:  ADDLW  F1
1818:  MOVWF  FE9
181A:  MOVLW  07
181C:  ADDWFC 03,W
181E:  MOVWF  FEA
1820:  MOVLW  01
1822:  ADDWF  FEE,F
1824:  BNC   1828
1826:  INCF   FEF,F
....................                    
....................                    if(ReleaseTime[i]>=((FaultDelayTime[i]*75)+15)) //time per loop are 368 microSec. (1.89*10=200ms) 
1828:  BCF    FD8.0
182A:  RLCF   x79,W
182C:  CLRF   03
182E:  ADDLW  F1
1830:  MOVWF  FE9
1832:  MOVLW  07
1834:  ADDWFC 03,W
1836:  MOVWF  FEA
1838:  MOVFF  FEC,87B
183C:  MOVF   FED,F
183E:  MOVFF  FEF,87A
1842:  BCF    FD8.0
1844:  RLCF   x79,W
1846:  CLRF   03
1848:  ADDLW  2D
184A:  MOVWF  FE9
184C:  MOVLW  08
184E:  ADDWFC 03,W
1850:  MOVWF  FEA
1852:  MOVFF  FEC,87D
1856:  MOVF   FED,F
1858:  MOVFF  FEF,87C
185C:  MOVFF  87D,87F
1860:  MOVFF  87C,87E
1864:  CLRF   x81
1866:  MOVLW  4B
1868:  MOVWF  x80
186A:  MOVLB  0
186C:  RCALL  150E
186E:  MOVFF  02,87D
1872:  MOVFF  01,87C
1876:  MOVLW  0F
1878:  MOVLB  8
187A:  ADDWF  01,W
187C:  MOVWF  01
187E:  MOVLW  00
1880:  ADDWFC 02,W
1882:  MOVWF  03
1884:  MOVF   03,W
1886:  SUBWF  x7B,W
1888:  BNC   18FA
188A:  BNZ   1892
188C:  MOVF   01,W
188E:  SUBWF  x7A,W
1890:  BNC   18FA
....................                    {    
....................                      ReleaseTime[i] = 1; 
1892:  BCF    FD8.0
1894:  RLCF   x79,W
1896:  CLRF   03
1898:  ADDLW  F1
189A:  MOVWF  FE9
189C:  MOVLW  07
189E:  ADDWFC 03,W
18A0:  MOVWF  FEA
18A2:  CLRF   FEC
18A4:  MOVF   FED,F
18A6:  MOVLW  01
18A8:  MOVWF  FEF
....................                      switch(i) 
....................                      { 
18AA:  SUBWF  x79,W
18AC:  ADDLW  F8
18AE:  BC    18FA
18B0:  ADDLW  08
18B2:  MOVLB  0
18B4:  GOTO   1C86
....................                         case 1: 
....................                            Input.B1 = 1;  
18B8:  MOVLB  7
18BA:  BSF    xDA.0
....................                         break; 
18BC:  MOVLB  8
18BE:  BRA    18FA
....................                         case 2: 
....................                            Input.B2 = 1;  
18C0:  MOVLB  7
18C2:  BSF    xDA.1
....................                         break; 
18C4:  MOVLB  8
18C6:  BRA    18FA
....................                         case 3: 
....................                            Input.B3 = 1;  
18C8:  MOVLB  7
18CA:  BSF    xDA.2
....................                         break; 
18CC:  MOVLB  8
18CE:  BRA    18FA
....................                         case 4: 
....................                            Input.B4 = 1;  
18D0:  MOVLB  7
18D2:  BSF    xDA.3
....................                         break; 
18D4:  MOVLB  8
18D6:  BRA    18FA
....................                         case 5: 
....................                            Input.B5 = 1;  
18D8:  MOVLB  7
18DA:  BSF    xDA.4
....................                         break; 
18DC:  MOVLB  8
18DE:  BRA    18FA
....................                         case 6: 
....................                            Input.B6 = 1;  
18E0:  MOVLB  7
18E2:  BSF    xDA.5
....................                         break; 
18E4:  MOVLB  8
18E6:  BRA    18FA
....................                         case 7: 
....................                            Input.B7 = 1;  
18E8:  MOVLB  7
18EA:  BSF    xDA.6
....................                          break; 
18EC:  MOVLB  8
18EE:  BRA    18FA
....................                          case 8: 
....................                            Input.B8 = 1;  
18F0:  MOVLB  7
18F2:  BSF    xDA.7
....................                         break; 
18F4:  MOVLB  8
18F6:  BRA    18FA
18F8:  MOVLB  8
....................           
....................                      }                  
....................                    } 
....................                } 
....................                else 
18FA:  BRA    1916
18FC:  MOVLB  0
....................                { 
....................                   ReleaseTime[i] = 0; 
18FE:  BCF    FD8.0
1900:  MOVLB  8
1902:  RLCF   x79,W
1904:  CLRF   03
1906:  ADDLW  F1
1908:  MOVWF  FE9
190A:  MOVLW  07
190C:  ADDWFC 03,W
190E:  MOVWF  FEA
1910:  CLRF   FEC
1912:  MOVF   FED,F
1914:  CLRF   FEF
....................                } 
....................               
....................  
....................              } 
....................           } 
....................           else if(FaultNCNO[i] ==NC) 
1916:  BRA    1BA8
1918:  MOVFF  879,87B
191C:  MOVLW  08
191E:  MOVLB  8
1920:  MOVWF  x7D
1922:  MOVLW  69
1924:  MOVWF  x7C
1926:  MOVLB  0
1928:  RCALL  14DC
192A:  MOVLW  00
192C:  BTFSC  01.0
192E:  MOVLW  01
1930:  ANDLW  01
1932:  BTFSS  FD8.2
1934:  BRA    1BAA
....................           { 
....................              if(FaultNow[i]==1) 
1936:  MOVFF  879,87B
193A:  MOVLW  07
193C:  MOVLB  8
193E:  MOVWF  x7D
1940:  MOVLW  ED
1942:  MOVWF  x7C
1944:  MOVLB  0
1946:  RCALL  14DC
1948:  MOVLW  00
194A:  BTFSC  01.0
194C:  MOVLW  01
194E:  ANDLW  01
1950:  SUBLW  01
1952:  BTFSS  FD8.2
1954:  BRA    1A82
....................              { 
....................                if(FaultAgo[i]==1) 
1956:  MOVFF  879,87B
195A:  MOVLW  07
195C:  MOVLB  8
195E:  MOVWF  x7D
1960:  MOVLW  E9
1962:  MOVWF  x7C
1964:  MOVLB  0
1966:  RCALL  14DC
1968:  MOVLW  00
196A:  BTFSC  01.0
196C:  MOVLW  01
196E:  ANDLW  01
1970:  SUBLW  01
1972:  BTFSS  FD8.2
1974:  BRA    1A66
....................                { 
....................                    ReleaseTime[i]++; 
1976:  BCF    FD8.0
1978:  MOVLB  8
197A:  RLCF   x79,W
197C:  CLRF   03
197E:  ADDLW  F1
1980:  MOVWF  FE9
1982:  MOVLW  07
1984:  ADDWFC 03,W
1986:  MOVWF  FEA
1988:  MOVLW  01
198A:  ADDWF  FEE,F
198C:  BNC   1990
198E:  INCF   FEF,F
....................                    if(ReleaseTime[i]>=((FaultDelayTime[i]*75)+15)) //time per loop are 368 microSec. (1.89*10=200ms) 
1990:  BCF    FD8.0
1992:  RLCF   x79,W
1994:  CLRF   03
1996:  ADDLW  F1
1998:  MOVWF  FE9
199A:  MOVLW  07
199C:  ADDWFC 03,W
199E:  MOVWF  FEA
19A0:  MOVFF  FEC,87B
19A4:  MOVF   FED,F
19A6:  MOVFF  FEF,87A
19AA:  BCF    FD8.0
19AC:  RLCF   x79,W
19AE:  CLRF   03
19B0:  ADDLW  2D
19B2:  MOVWF  FE9
19B4:  MOVLW  08
19B6:  ADDWFC 03,W
19B8:  MOVWF  FEA
19BA:  MOVFF  FEC,87D
19BE:  MOVF   FED,F
19C0:  MOVFF  FEF,87C
19C4:  MOVFF  87D,87F
19C8:  MOVFF  87C,87E
19CC:  CLRF   x81
19CE:  MOVLW  4B
19D0:  MOVWF  x80
19D2:  MOVLB  0
19D4:  RCALL  150E
19D6:  MOVFF  02,87D
19DA:  MOVFF  01,87C
19DE:  MOVLW  0F
19E0:  MOVLB  8
19E2:  ADDWF  01,W
19E4:  MOVWF  01
19E6:  MOVLW  00
19E8:  ADDWFC 02,W
19EA:  MOVWF  03
19EC:  MOVF   03,W
19EE:  SUBWF  x7B,W
19F0:  BNC   1A62
19F2:  BNZ   19FA
19F4:  MOVF   01,W
19F6:  SUBWF  x7A,W
19F8:  BNC   1A62
....................                    {    
....................                      ReleaseTime[i] = 0; 
19FA:  BCF    FD8.0
19FC:  RLCF   x79,W
19FE:  CLRF   03
1A00:  ADDLW  F1
1A02:  MOVWF  FE9
1A04:  MOVLW  07
1A06:  ADDWFC 03,W
1A08:  MOVWF  FEA
1A0A:  CLRF   FEC
1A0C:  MOVF   FED,F
1A0E:  CLRF   FEF
....................                      switch(i) 
....................                      { 
1A10:  MOVLW  01
1A12:  SUBWF  x79,W
1A14:  ADDLW  F8
1A16:  BC    1A62
1A18:  ADDLW  08
1A1A:  MOVLB  0
1A1C:  GOTO   1CBA
....................                         case 1: 
....................                            Input.B1 = 1;  
1A20:  MOVLB  7
1A22:  BSF    xDA.0
....................                         break; 
1A24:  MOVLB  8
1A26:  BRA    1A62
....................                         case 2: 
....................                            Input.B2 = 1;  
1A28:  MOVLB  7
1A2A:  BSF    xDA.1
....................                         break; 
1A2C:  MOVLB  8
1A2E:  BRA    1A62
....................                         case 3: 
....................                            Input.B3 = 1;  
1A30:  MOVLB  7
1A32:  BSF    xDA.2
....................                         break; 
1A34:  MOVLB  8
1A36:  BRA    1A62
....................                         case 4: 
....................                            Input.B4 = 1;  
1A38:  MOVLB  7
1A3A:  BSF    xDA.3
....................                         break; 
1A3C:  MOVLB  8
1A3E:  BRA    1A62
....................                         case 5: 
....................                            Input.B5 = 1;  
1A40:  MOVLB  7
1A42:  BSF    xDA.4
....................                         break; 
1A44:  MOVLB  8
1A46:  BRA    1A62
....................                         case 6: 
....................                            Input.B6 = 1;  
1A48:  MOVLB  7
1A4A:  BSF    xDA.5
....................                         break; 
1A4C:  MOVLB  8
1A4E:  BRA    1A62
....................                         case 7: 
....................                            Input.B7 = 1;  
1A50:  MOVLB  7
1A52:  BSF    xDA.6
....................                          break; 
1A54:  MOVLB  8
1A56:  BRA    1A62
....................                          case 8: 
....................                            Input.B8 = 1;  
1A58:  MOVLB  7
1A5A:  BSF    xDA.7
....................                         break; 
1A5C:  MOVLB  8
1A5E:  BRA    1A62
1A60:  MOVLB  8
....................                                             
....................                      }                  
....................                   } 
....................                } 
....................                else 
1A62:  BRA    1A7E
1A64:  MOVLB  0
....................                { 
....................                   ReleaseTime[i] = 0; 
1A66:  BCF    FD8.0
1A68:  MOVLB  8
1A6A:  RLCF   x79,W
1A6C:  CLRF   03
1A6E:  ADDLW  F1
1A70:  MOVWF  FE9
1A72:  MOVLW  07
1A74:  ADDWFC 03,W
1A76:  MOVWF  FEA
1A78:  CLRF   FEC
1A7A:  MOVF   FED,F
1A7C:  CLRF   FEF
....................                } 
....................              } 
....................              else //if(FaultNow[i]==0 
1A7E:  BRA    1BA8
1A80:  MOVLB  0
....................              { 
....................                if(FaultAgo[i]==0) 
1A82:  MOVFF  879,87B
1A86:  MOVLW  07
1A88:  MOVLB  8
1A8A:  MOVWF  x7D
1A8C:  MOVLW  E9
1A8E:  MOVWF  x7C
1A90:  MOVLB  0
1A92:  RCALL  14DC
1A94:  MOVLW  00
1A96:  BTFSC  01.0
1A98:  MOVLW  01
1A9A:  ANDLW  01
1A9C:  BTFSS  FD8.2
1A9E:  BRA    1B90
....................                { 
....................                    ReleaseTime[i]++; 
1AA0:  BCF    FD8.0
1AA2:  MOVLB  8
1AA4:  RLCF   x79,W
1AA6:  CLRF   03
1AA8:  ADDLW  F1
1AAA:  MOVWF  FE9
1AAC:  MOVLW  07
1AAE:  ADDWFC 03,W
1AB0:  MOVWF  FEA
1AB2:  MOVLW  01
1AB4:  ADDWF  FEE,F
1AB6:  BNC   1ABA
1AB8:  INCF   FEF,F
....................                    
....................                    if(ReleaseTime[i]>=((FaultDelayTime[i]*75)+15)) //time per loop are 368 microSec. (1.89*10=200ms) 
1ABA:  BCF    FD8.0
1ABC:  RLCF   x79,W
1ABE:  CLRF   03
1AC0:  ADDLW  F1
1AC2:  MOVWF  FE9
1AC4:  MOVLW  07
1AC6:  ADDWFC 03,W
1AC8:  MOVWF  FEA
1ACA:  MOVFF  FEC,87B
1ACE:  MOVF   FED,F
1AD0:  MOVFF  FEF,87A
1AD4:  BCF    FD8.0
1AD6:  RLCF   x79,W
1AD8:  CLRF   03
1ADA:  ADDLW  2D
1ADC:  MOVWF  FE9
1ADE:  MOVLW  08
1AE0:  ADDWFC 03,W
1AE2:  MOVWF  FEA
1AE4:  MOVFF  FEC,87D
1AE8:  MOVF   FED,F
1AEA:  MOVFF  FEF,87C
1AEE:  MOVFF  87D,87F
1AF2:  MOVFF  87C,87E
1AF6:  CLRF   x81
1AF8:  MOVLW  4B
1AFA:  MOVWF  x80
1AFC:  MOVLB  0
1AFE:  RCALL  150E
1B00:  MOVFF  02,87D
1B04:  MOVFF  01,87C
1B08:  MOVLW  0F
1B0A:  MOVLB  8
1B0C:  ADDWF  01,W
1B0E:  MOVWF  01
1B10:  MOVLW  00
1B12:  ADDWFC 02,W
1B14:  MOVWF  03
1B16:  MOVF   03,W
1B18:  SUBWF  x7B,W
1B1A:  BNC   1B8C
1B1C:  BNZ   1B24
1B1E:  MOVF   01,W
1B20:  SUBWF  x7A,W
1B22:  BNC   1B8C
....................                    {    
....................                      ReleaseTime[i] = 0; 
1B24:  BCF    FD8.0
1B26:  RLCF   x79,W
1B28:  CLRF   03
1B2A:  ADDLW  F1
1B2C:  MOVWF  FE9
1B2E:  MOVLW  07
1B30:  ADDWFC 03,W
1B32:  MOVWF  FEA
1B34:  CLRF   FEC
1B36:  MOVF   FED,F
1B38:  CLRF   FEF
....................                      switch(i) 
....................                      { 
1B3A:  MOVLW  01
1B3C:  SUBWF  x79,W
1B3E:  ADDLW  F8
1B40:  BC    1B8C
1B42:  ADDLW  08
1B44:  MOVLB  0
1B46:  GOTO   1CEE
....................                         case 1: 
....................                            Input.B1 = 0;  
1B4A:  MOVLB  7
1B4C:  BCF    xDA.0
....................                         break; 
1B4E:  MOVLB  8
1B50:  BRA    1B8C
....................                         case 2: 
....................                            Input.B2 = 0;  
1B52:  MOVLB  7
1B54:  BCF    xDA.1
....................                         break; 
1B56:  MOVLB  8
1B58:  BRA    1B8C
....................                         case 3: 
....................                            Input.B3 = 0;  
1B5A:  MOVLB  7
1B5C:  BCF    xDA.2
....................                         break; 
1B5E:  MOVLB  8
1B60:  BRA    1B8C
....................                         case 4: 
....................                            Input.B4 = 0;  
1B62:  MOVLB  7
1B64:  BCF    xDA.3
....................                         break; 
1B66:  MOVLB  8
1B68:  BRA    1B8C
....................                         case 5: 
....................                            Input.B5 = 0;  
1B6A:  MOVLB  7
1B6C:  BCF    xDA.4
....................                         break; 
1B6E:  MOVLB  8
1B70:  BRA    1B8C
....................                         case 6: 
....................                            Input.B6 = 0;  
1B72:  MOVLB  7
1B74:  BCF    xDA.5
....................                         break; 
1B76:  MOVLB  8
1B78:  BRA    1B8C
....................                         case 7: 
....................                            Input.B7 = 0;  
1B7A:  MOVLB  7
1B7C:  BCF    xDA.6
....................                          break; 
1B7E:  MOVLB  8
1B80:  BRA    1B8C
....................                          case 8: 
....................                            Input.B8 = 0;  
1B82:  MOVLB  7
1B84:  BCF    xDA.7
....................                         break; 
1B86:  MOVLB  8
1B88:  BRA    1B8C
1B8A:  MOVLB  8
....................                
....................                      }                  
....................                    } 
....................                } 
....................                else 
1B8C:  BRA    1BA8
1B8E:  MOVLB  0
....................                { 
....................                   ReleaseTime[i] = 0; 
1B90:  BCF    FD8.0
1B92:  MOVLB  8
1B94:  RLCF   x79,W
1B96:  CLRF   03
1B98:  ADDLW  F1
1B9A:  MOVWF  FE9
1B9C:  MOVLW  07
1B9E:  ADDWFC 03,W
1BA0:  MOVWF  FEA
1BA2:  CLRF   FEC
1BA4:  MOVF   FED,F
1BA6:  CLRF   FEF
1BA8:  MOVLB  0
....................                } 
....................  
....................              } 
....................           } 
....................       } 
1BAA:  MOVLB  8
1BAC:  INCF   x79,F
1BAE:  BRA    1680
....................        
....................       StoreReleaseFault(); 
1BB0:  MOVLB  0
1BB2:  BRA    1572
....................  
....................     
....................       Input1_8 = 0x00; 
1BB4:  CLRF   46
....................       Input1_8 = Input1_8 | ~Input.B8; 
1BB6:  MOVLW  00
1BB8:  MOVLB  7
1BBA:  BTFSS  xDA.7
1BBC:  MOVLW  01
1BBE:  IORWF  46,F
....................       Input1_8 = (Input1_8 << 1) | ~Input.B7; 
1BC0:  BCF    FD8.0
1BC2:  RLCF   46,W
1BC4:  MOVLB  8
1BC6:  MOVWF  x7A
1BC8:  MOVLW  00
1BCA:  MOVLB  7
1BCC:  BTFSS  xDA.6
1BCE:  MOVLW  01
1BD0:  MOVLB  8
1BD2:  IORWF  x7A,W
1BD4:  MOVWF  46
....................       Input1_8 = (Input1_8 << 1) | ~Input.B6; 
1BD6:  BCF    FD8.0
1BD8:  RLCF   46,W
1BDA:  MOVWF  x7A
1BDC:  MOVLW  00
1BDE:  MOVLB  7
1BE0:  BTFSS  xDA.5
1BE2:  MOVLW  01
1BE4:  MOVLB  8
1BE6:  IORWF  x7A,W
1BE8:  MOVWF  46
....................       Input1_8 = (Input1_8 << 1) | ~Input.B5; 
1BEA:  BCF    FD8.0
1BEC:  RLCF   46,W
1BEE:  MOVWF  x7A
1BF0:  MOVLW  00
1BF2:  MOVLB  7
1BF4:  BTFSS  xDA.4
1BF6:  MOVLW  01
1BF8:  MOVLB  8
1BFA:  IORWF  x7A,W
1BFC:  MOVWF  46
....................       Input1_8 = (Input1_8 << 1) | ~Input.B4; 
1BFE:  BCF    FD8.0
1C00:  RLCF   46,W
1C02:  MOVWF  x7A
1C04:  MOVLW  00
1C06:  MOVLB  7
1C08:  BTFSS  xDA.3
1C0A:  MOVLW  01
1C0C:  MOVLB  8
1C0E:  IORWF  x7A,W
1C10:  MOVWF  46
....................       Input1_8 = (Input1_8 << 1) | ~Input.B3; 
1C12:  BCF    FD8.0
1C14:  RLCF   46,W
1C16:  MOVWF  x7A
1C18:  MOVLW  00
1C1A:  MOVLB  7
1C1C:  BTFSS  xDA.2
1C1E:  MOVLW  01
1C20:  MOVLB  8
1C22:  IORWF  x7A,W
1C24:  MOVWF  46
....................       Input1_8 = (Input1_8 << 1) | ~Input.B2; 
1C26:  BCF    FD8.0
1C28:  RLCF   46,W
1C2A:  MOVWF  x7A
1C2C:  MOVLW  00
1C2E:  MOVLB  7
1C30:  BTFSS  xDA.1
1C32:  MOVLW  01
1C34:  MOVLB  8
1C36:  IORWF  x7A,W
1C38:  MOVWF  46
....................       Input1_8 = (Input1_8 << 1) | ~Input.B1; 
1C3A:  BCF    FD8.0
1C3C:  RLCF   46,W
1C3E:  MOVWF  x7A
1C40:  MOVLW  00
1C42:  MOVLB  7
1C44:  BTFSS  xDA.0
1C46:  MOVLW  01
1C48:  MOVLB  8
1C4A:  IORWF  x7A,W
1C4C:  MOVWF  46
....................      
....................  
....................     
.................... } 
1C4E:  MOVLB  0
1C50:  RETLW  00
.................... /*----------------------------------------------------------------------------*/ 
.................... /*----------------------------------------------------------------------------*/ 
....................  
....................  
.................... void Read_Config(void) 
.................... { 
....................     
....................  
....................    EEpDat = read_eeprom(0x01);   // Input type 1-8 
*
0890:  MOVFF  FF2,87A
0894:  BCF    FF2.7
0896:  CLRF   FAA
0898:  MOVLW  01
089A:  MOVWF  FA9
089C:  BCF    FA6.6
089E:  BCF    FA6.7
08A0:  BSF    FA6.0
08A2:  MOVF   FA8,W
08A4:  MOVLB  8
08A6:  BTFSC  x7A.7
08A8:  BSF    FF2.7
08AA:  MOVWF  36
....................    InputType1_8 = EEpDat; 
08AC:  MOVFF  36,37
....................  
....................    InputType.B1 = EEpDat; 
08B0:  MOVLB  7
08B2:  BCF    xDC.0
08B4:  BTFSC  36.0
08B6:  BSF    xDC.0
....................    InputType.B2 = EEpDat >> 1; 
08B8:  BCF    FD8.0
08BA:  RRCF   36,W
08BC:  BCF    xDC.1
08BE:  BTFSC  FE8.0
08C0:  BSF    xDC.1
....................    InputType.B3 = EEpDat >> 2; 
08C2:  RRCF   36,W
08C4:  MOVWF  00
08C6:  RRCF   00,F
08C8:  MOVLW  3F
08CA:  ANDWF  00,F
08CC:  BCF    xDC.2
08CE:  BTFSC  00.0
08D0:  BSF    xDC.2
....................    InputType.B4 = EEpDat >> 3; 
08D2:  RRCF   36,W
08D4:  MOVWF  00
08D6:  RRCF   00,F
08D8:  RRCF   00,F
08DA:  MOVLW  1F
08DC:  ANDWF  00,F
08DE:  BCF    xDC.3
08E0:  BTFSC  00.0
08E2:  BSF    xDC.3
....................    InputType.B5 = EEpDat >> 4; 
08E4:  SWAPF  36,W
08E6:  MOVWF  00
08E8:  MOVLW  0F
08EA:  ANDWF  00,F
08EC:  BCF    xDC.4
08EE:  BTFSC  00.0
08F0:  BSF    xDC.4
....................    InputType.B6 = EEpDat >> 5; 
08F2:  SWAPF  36,W
08F4:  MOVWF  00
08F6:  RRCF   00,F
08F8:  MOVLW  07
08FA:  ANDWF  00,F
08FC:  BCF    xDC.5
08FE:  BTFSC  00.0
0900:  BSF    xDC.5
....................    InputType.B7 = EEpDat >> 6; 
0902:  SWAPF  36,W
0904:  MOVWF  00
0906:  RRCF   00,F
0908:  RRCF   00,F
090A:  MOVLW  03
090C:  ANDWF  00,F
090E:  BCF    xDC.6
0910:  BTFSC  00.0
0912:  BSF    xDC.6
....................    InputType.B8 = EEpDat >> 7; 
0914:  CLRF   00
0916:  BTFSC  36.7
0918:  BSF    00.0
091A:  BCF    xDC.7
091C:  BTFSC  00.0
091E:  BSF    xDC.7
....................     
....................    FaultNCNO[1] = InputType.B1; 
0920:  MOVLB  8
0922:  BCF    x69.1
0924:  MOVLB  7
0926:  BTFSS  xDC.0
0928:  BRA    0930
092A:  MOVLB  8
092C:  BSF    x69.1
092E:  MOVLB  7
....................    FaultNCNO[2] = InputType.B2; 
0930:  MOVLB  8
0932:  BCF    x69.2
0934:  MOVLB  7
0936:  BTFSS  xDC.1
0938:  BRA    0940
093A:  MOVLB  8
093C:  BSF    x69.2
093E:  MOVLB  7
....................    FaultNCNO[3] = InputType.B3; 
0940:  MOVLB  8
0942:  BCF    x69.3
0944:  MOVLB  7
0946:  BTFSS  xDC.2
0948:  BRA    0950
094A:  MOVLB  8
094C:  BSF    x69.3
094E:  MOVLB  7
....................    FaultNCNO[4] = InputType.B4; 
0950:  MOVLB  8
0952:  BCF    x69.4
0954:  MOVLB  7
0956:  BTFSS  xDC.3
0958:  BRA    0960
095A:  MOVLB  8
095C:  BSF    x69.4
095E:  MOVLB  7
....................    FaultNCNO[5] = InputType.B5; 
0960:  MOVLB  8
0962:  BCF    x69.5
0964:  MOVLB  7
0966:  BTFSS  xDC.4
0968:  BRA    0970
096A:  MOVLB  8
096C:  BSF    x69.5
096E:  MOVLB  7
....................    FaultNCNO[6] = InputType.B6; 
0970:  MOVLB  8
0972:  BCF    x69.6
0974:  MOVLB  7
0976:  BTFSS  xDC.5
0978:  BRA    0980
097A:  MOVLB  8
097C:  BSF    x69.6
097E:  MOVLB  7
....................    FaultNCNO[7] = InputType.B7; 
0980:  MOVLB  8
0982:  BCF    x69.7
0984:  MOVLB  7
0986:  BTFSS  xDC.6
0988:  BRA    0990
098A:  MOVLB  8
098C:  BSF    x69.7
098E:  MOVLB  7
....................    FaultNCNO[8] = InputType.B8; 
0990:  MOVLB  8
0992:  BCF    x6A.0
0994:  MOVLB  7
0996:  BTFSS  xDC.7
0998:  BRA    09A0
099A:  MOVLB  8
099C:  BSF    x6A.0
099E:  MOVLB  7
....................  
....................  
....................    //////////////////////////////////////// 
....................  
....................    EEpDat = read_eeprom(0x04);   // Fault type 1-8 
09A0:  MOVFF  FF2,87A
09A4:  BCF    FF2.7
09A6:  CLRF   FAA
09A8:  MOVLW  04
09AA:  MOVWF  FA9
09AC:  BCF    FA6.6
09AE:  BCF    FA6.7
09B0:  BSF    FA6.0
09B2:  MOVF   FA8,W
09B4:  MOVLB  8
09B6:  BTFSC  x7A.7
09B8:  BSF    FF2.7
09BA:  MOVWF  36
....................    FaultType1_8 = EEpDat; 
09BC:  MOVFF  36,3A
....................  
....................    FaultType.B1 = EEpDat; 
09C0:  MOVLB  7
09C2:  BCF    xDD.0
09C4:  BTFSC  36.0
09C6:  BSF    xDD.0
....................    FaultType.B2 = EEpDat >> 1; 
09C8:  BCF    FD8.0
09CA:  RRCF   36,W
09CC:  BCF    xDD.1
09CE:  BTFSC  FE8.0
09D0:  BSF    xDD.1
....................    FaultType.B3 = EEpDat >> 2; 
09D2:  RRCF   36,W
09D4:  MOVWF  00
09D6:  RRCF   00,F
09D8:  MOVLW  3F
09DA:  ANDWF  00,F
09DC:  BCF    xDD.2
09DE:  BTFSC  00.0
09E0:  BSF    xDD.2
....................    FaultType.B4 = EEpDat >> 3; 
09E2:  RRCF   36,W
09E4:  MOVWF  00
09E6:  RRCF   00,F
09E8:  RRCF   00,F
09EA:  MOVLW  1F
09EC:  ANDWF  00,F
09EE:  BCF    xDD.3
09F0:  BTFSC  00.0
09F2:  BSF    xDD.3
....................    FaultType.B5 = EEpDat >> 4; 
09F4:  SWAPF  36,W
09F6:  MOVWF  00
09F8:  MOVLW  0F
09FA:  ANDWF  00,F
09FC:  BCF    xDD.4
09FE:  BTFSC  00.0
0A00:  BSF    xDD.4
....................    FaultType.B6 = EEpDat >> 5; 
0A02:  SWAPF  36,W
0A04:  MOVWF  00
0A06:  RRCF   00,F
0A08:  MOVLW  07
0A0A:  ANDWF  00,F
0A0C:  BCF    xDD.5
0A0E:  BTFSC  00.0
0A10:  BSF    xDD.5
....................    FaultType.B7 = EEpDat >> 6; 
0A12:  SWAPF  36,W
0A14:  MOVWF  00
0A16:  RRCF   00,F
0A18:  RRCF   00,F
0A1A:  MOVLW  03
0A1C:  ANDWF  00,F
0A1E:  BCF    xDD.6
0A20:  BTFSC  00.0
0A22:  BSF    xDD.6
....................    FaultType.B8 = EEpDat >> 7; 
0A24:  CLRF   00
0A26:  BTFSC  36.7
0A28:  BSF    00.0
0A2A:  BCF    xDD.7
0A2C:  BTFSC  00.0
0A2E:  BSF    xDD.7
....................  
....................  
....................    //////////////////////////////////////////////// 
....................  
....................    EEpDat = read_eeprom(0x07);   // Output type 1-8 
0A30:  MOVFF  FF2,87A
0A34:  BCF    FF2.7
0A36:  CLRF   FAA
0A38:  MOVLW  07
0A3A:  MOVWF  FA9
0A3C:  BCF    FA6.6
0A3E:  BCF    FA6.7
0A40:  BSF    FA6.0
0A42:  MOVF   FA8,W
0A44:  MOVLB  8
0A46:  BTFSC  x7A.7
0A48:  BSF    FF2.7
0A4A:  MOVWF  36
....................    OutputType1_8 = EEpDat; 
0A4C:  MOVFF  36,3D
....................  
....................    OutputType.B1 = EEpDat; 
0A50:  MOVLB  7
0A52:  BCF    xDE.0
0A54:  BTFSC  36.0
0A56:  BSF    xDE.0
....................    OutputType.B2 = EEpDat >> 1; 
0A58:  BCF    FD8.0
0A5A:  RRCF   36,W
0A5C:  BCF    xDE.1
0A5E:  BTFSC  FE8.0
0A60:  BSF    xDE.1
....................    OutputType.B3 = EEpDat >> 2; 
0A62:  RRCF   36,W
0A64:  MOVWF  00
0A66:  RRCF   00,F
0A68:  MOVLW  3F
0A6A:  ANDWF  00,F
0A6C:  BCF    xDE.2
0A6E:  BTFSC  00.0
0A70:  BSF    xDE.2
....................    OutputType.B4 = EEpDat >> 3; 
0A72:  RRCF   36,W
0A74:  MOVWF  00
0A76:  RRCF   00,F
0A78:  RRCF   00,F
0A7A:  MOVLW  1F
0A7C:  ANDWF  00,F
0A7E:  BCF    xDE.3
0A80:  BTFSC  00.0
0A82:  BSF    xDE.3
....................    OutputType.B5 = EEpDat >> 4; 
0A84:  SWAPF  36,W
0A86:  MOVWF  00
0A88:  MOVLW  0F
0A8A:  ANDWF  00,F
0A8C:  BCF    xDE.4
0A8E:  BTFSC  00.0
0A90:  BSF    xDE.4
....................    OutputType.B6 = EEpDat >> 5; 
0A92:  SWAPF  36,W
0A94:  MOVWF  00
0A96:  RRCF   00,F
0A98:  MOVLW  07
0A9A:  ANDWF  00,F
0A9C:  BCF    xDE.5
0A9E:  BTFSC  00.0
0AA0:  BSF    xDE.5
....................    OutputType.B7 = EEpDat >> 6; 
0AA2:  SWAPF  36,W
0AA4:  MOVWF  00
0AA6:  RRCF   00,F
0AA8:  RRCF   00,F
0AAA:  MOVLW  03
0AAC:  ANDWF  00,F
0AAE:  BCF    xDE.6
0AB0:  BTFSC  00.0
0AB2:  BSF    xDE.6
....................    OutputType.B8 = EEpDat >> 7; 
0AB4:  CLRF   00
0AB6:  BTFSC  36.7
0AB8:  BSF    00.0
0ABA:  BCF    xDE.7
0ABC:  BTFSC  00.0
0ABE:  BSF    xDE.7
....................  
....................  
....................    //////////////////////////////////////// 
....................  
....................    EEpDat = read_eeprom(0x0A);   // Output Both 1-8 
0AC0:  MOVFF  FF2,87A
0AC4:  BCF    FF2.7
0AC6:  CLRF   FAA
0AC8:  MOVLW  0A
0ACA:  MOVWF  FA9
0ACC:  BCF    FA6.6
0ACE:  BCF    FA6.7
0AD0:  BSF    FA6.0
0AD2:  MOVF   FA8,W
0AD4:  MOVLB  8
0AD6:  BTFSC  x7A.7
0AD8:  BSF    FF2.7
0ADA:  MOVWF  36
....................    OutputBoth1_8 = EEpDat; 
0ADC:  MOVFF  36,40
....................  
....................    OutputBoth.B1 = EEpDat; 
0AE0:  MOVLB  7
0AE2:  BCF    xDF.0
0AE4:  BTFSC  36.0
0AE6:  BSF    xDF.0
....................    OutputBoth.B2 = EEpDat >> 1; 
0AE8:  BCF    FD8.0
0AEA:  RRCF   36,W
0AEC:  BCF    xDF.1
0AEE:  BTFSC  FE8.0
0AF0:  BSF    xDF.1
....................    OutputBoth.B3 = EEpDat >> 2; 
0AF2:  RRCF   36,W
0AF4:  MOVWF  00
0AF6:  RRCF   00,F
0AF8:  MOVLW  3F
0AFA:  ANDWF  00,F
0AFC:  BCF    xDF.2
0AFE:  BTFSC  00.0
0B00:  BSF    xDF.2
....................    OutputBoth.B4 = EEpDat >> 3; 
0B02:  RRCF   36,W
0B04:  MOVWF  00
0B06:  RRCF   00,F
0B08:  RRCF   00,F
0B0A:  MOVLW  1F
0B0C:  ANDWF  00,F
0B0E:  BCF    xDF.3
0B10:  BTFSC  00.0
0B12:  BSF    xDF.3
....................    OutputBoth.B5 = EEpDat >> 4; 
0B14:  SWAPF  36,W
0B16:  MOVWF  00
0B18:  MOVLW  0F
0B1A:  ANDWF  00,F
0B1C:  BCF    xDF.4
0B1E:  BTFSC  00.0
0B20:  BSF    xDF.4
....................    OutputBoth.B6 = EEpDat >> 5; 
0B22:  SWAPF  36,W
0B24:  MOVWF  00
0B26:  RRCF   00,F
0B28:  MOVLW  07
0B2A:  ANDWF  00,F
0B2C:  BCF    xDF.5
0B2E:  BTFSC  00.0
0B30:  BSF    xDF.5
....................    OutputBoth.B7 = EEpDat >> 6; 
0B32:  SWAPF  36,W
0B34:  MOVWF  00
0B36:  RRCF   00,F
0B38:  RRCF   00,F
0B3A:  MOVLW  03
0B3C:  ANDWF  00,F
0B3E:  BCF    xDF.6
0B40:  BTFSC  00.0
0B42:  BSF    xDF.6
....................    OutputBoth.B8 = EEpDat >> 7; 
0B44:  CLRF   00
0B46:  BTFSC  36.7
0B48:  BSF    00.0
0B4A:  BCF    xDF.7
0B4C:  BTFSC  00.0
0B4E:  BSF    xDF.7
....................  
....................  
....................    ///////////////////////////////////////////////// 
....................  
....................    EEpDat = read_eeprom(0x0D);   // AlarmIndicator 1-8 
0B50:  MOVFF  FF2,87A
0B54:  BCF    FF2.7
0B56:  CLRF   FAA
0B58:  MOVLW  0D
0B5A:  MOVWF  FA9
0B5C:  BCF    FA6.6
0B5E:  BCF    FA6.7
0B60:  BSF    FA6.0
0B62:  MOVF   FA8,W
0B64:  MOVLB  8
0B66:  BTFSC  x7A.7
0B68:  BSF    FF2.7
0B6A:  MOVWF  36
....................    Alarm_Indicator1_8 = EEpDat; 
0B6C:  MOVFF  36,43
....................  
....................    AlarmIndicator.B1 = EEpDat; 
0B70:  MOVLB  7
0B72:  BCF    xE0.0
0B74:  BTFSC  36.0
0B76:  BSF    xE0.0
....................    AlarmIndicator.B2 = EEpDat >> 1; 
0B78:  BCF    FD8.0
0B7A:  RRCF   36,W
0B7C:  BCF    xE0.1
0B7E:  BTFSC  FE8.0
0B80:  BSF    xE0.1
....................    AlarmIndicator.B3 = EEpDat >> 2; 
0B82:  RRCF   36,W
0B84:  MOVWF  00
0B86:  RRCF   00,F
0B88:  MOVLW  3F
0B8A:  ANDWF  00,F
0B8C:  BCF    xE0.2
0B8E:  BTFSC  00.0
0B90:  BSF    xE0.2
....................    AlarmIndicator.B4 = EEpDat >> 3; 
0B92:  RRCF   36,W
0B94:  MOVWF  00
0B96:  RRCF   00,F
0B98:  RRCF   00,F
0B9A:  MOVLW  1F
0B9C:  ANDWF  00,F
0B9E:  BCF    xE0.3
0BA0:  BTFSC  00.0
0BA2:  BSF    xE0.3
....................    AlarmIndicator.B5 = EEpDat >> 4; 
0BA4:  SWAPF  36,W
0BA6:  MOVWF  00
0BA8:  MOVLW  0F
0BAA:  ANDWF  00,F
0BAC:  BCF    xE0.4
0BAE:  BTFSC  00.0
0BB0:  BSF    xE0.4
....................    AlarmIndicator.B6 = EEpDat >> 5; 
0BB2:  SWAPF  36,W
0BB4:  MOVWF  00
0BB6:  RRCF   00,F
0BB8:  MOVLW  07
0BBA:  ANDWF  00,F
0BBC:  BCF    xE0.5
0BBE:  BTFSC  00.0
0BC0:  BSF    xE0.5
....................    AlarmIndicator.B7 = EEpDat >> 6; 
0BC2:  SWAPF  36,W
0BC4:  MOVWF  00
0BC6:  RRCF   00,F
0BC8:  RRCF   00,F
0BCA:  MOVLW  03
0BCC:  ANDWF  00,F
0BCE:  BCF    xE0.6
0BD0:  BTFSC  00.0
0BD2:  BSF    xE0.6
....................    AlarmIndicator.B8 = EEpDat >> 7; 
0BD4:  CLRF   00
0BD6:  BTFSC  36.7
0BD8:  BSF    00.0
0BDA:  BCF    xE0.7
0BDC:  BTFSC  00.0
0BDE:  BSF    xE0.7
....................  
....................    ////////////////////////////////////////////////// 
....................    EEpDat = read_eeprom(0x10); 
0BE0:  MOVFF  FF2,87A
0BE4:  BCF    FF2.7
0BE6:  CLRF   FAA
0BE8:  MOVLW  10
0BEA:  MOVWF  FA9
0BEC:  BCF    FA6.6
0BEE:  BCF    FA6.7
0BF0:  BSF    FA6.0
0BF2:  MOVF   FA8,W
0BF4:  MOVLB  8
0BF6:  BTFSC  x7A.7
0BF8:  BSF    FF2.7
0BFA:  MOVWF  36
....................    //Red1_8 = EEpDat; 
....................    RED_Colour.B1 = EEpDat; 
0BFC:  MOVLB  7
0BFE:  BCF    xE6.0
0C00:  BTFSC  36.0
0C02:  BSF    xE6.0
....................    RED_Colour.B2 = EEpDat >> 1; 
0C04:  BCF    FD8.0
0C06:  RRCF   36,W
0C08:  BCF    xE6.1
0C0A:  BTFSC  FE8.0
0C0C:  BSF    xE6.1
....................    RED_Colour.B3 = EEpDat >> 2; 
0C0E:  RRCF   36,W
0C10:  MOVWF  00
0C12:  RRCF   00,F
0C14:  MOVLW  3F
0C16:  ANDWF  00,F
0C18:  BCF    xE6.2
0C1A:  BTFSC  00.0
0C1C:  BSF    xE6.2
....................    RED_Colour.B4 = EEpDat >> 3; 
0C1E:  RRCF   36,W
0C20:  MOVWF  00
0C22:  RRCF   00,F
0C24:  RRCF   00,F
0C26:  MOVLW  1F
0C28:  ANDWF  00,F
0C2A:  BCF    xE6.3
0C2C:  BTFSC  00.0
0C2E:  BSF    xE6.3
....................    RED_Colour.B5 = EEpDat >> 4; 
0C30:  SWAPF  36,W
0C32:  MOVWF  00
0C34:  MOVLW  0F
0C36:  ANDWF  00,F
0C38:  BCF    xE6.4
0C3A:  BTFSC  00.0
0C3C:  BSF    xE6.4
....................    RED_Colour.B6 = EEpDat >> 5; 
0C3E:  SWAPF  36,W
0C40:  MOVWF  00
0C42:  RRCF   00,F
0C44:  MOVLW  07
0C46:  ANDWF  00,F
0C48:  BCF    xE6.5
0C4A:  BTFSC  00.0
0C4C:  BSF    xE6.5
....................    RED_Colour.B7 = EEpDat >> 6; 
0C4E:  SWAPF  36,W
0C50:  MOVWF  00
0C52:  RRCF   00,F
0C54:  RRCF   00,F
0C56:  MOVLW  03
0C58:  ANDWF  00,F
0C5A:  BCF    xE6.6
0C5C:  BTFSC  00.0
0C5E:  BSF    xE6.6
....................    RED_Colour.B8 = EEpDat >> 7; 
0C60:  CLRF   00
0C62:  BTFSC  36.7
0C64:  BSF    00.0
0C66:  BCF    xE6.7
0C68:  BTFSC  00.0
0C6A:  BSF    xE6.7
....................      
....................    EEpDat = read_eeprom(0x14); 
0C6C:  MOVFF  FF2,87A
0C70:  BCF    FF2.7
0C72:  CLRF   FAA
0C74:  MOVLW  14
0C76:  MOVWF  FA9
0C78:  BCF    FA6.6
0C7A:  BCF    FA6.7
0C7C:  BSF    FA6.0
0C7E:  MOVF   FA8,W
0C80:  MOVLB  8
0C82:  BTFSC  x7A.7
0C84:  BSF    FF2.7
0C86:  MOVWF  36
....................    //Green1_8 = EEpDat; 
....................    GREEN_Colour.B1 = EEpDat; 
0C88:  MOVLB  7
0C8A:  BCF    xE7.0
0C8C:  BTFSC  36.0
0C8E:  BSF    xE7.0
....................    GREEN_Colour.B2 = EEpDat >> 1; 
0C90:  BCF    FD8.0
0C92:  RRCF   36,W
0C94:  BCF    xE7.1
0C96:  BTFSC  FE8.0
0C98:  BSF    xE7.1
....................    GREEN_Colour.B3 = EEpDat >> 2; 
0C9A:  RRCF   36,W
0C9C:  MOVWF  00
0C9E:  RRCF   00,F
0CA0:  MOVLW  3F
0CA2:  ANDWF  00,F
0CA4:  BCF    xE7.2
0CA6:  BTFSC  00.0
0CA8:  BSF    xE7.2
....................    GREEN_Colour.B4 = EEpDat >> 3; 
0CAA:  RRCF   36,W
0CAC:  MOVWF  00
0CAE:  RRCF   00,F
0CB0:  RRCF   00,F
0CB2:  MOVLW  1F
0CB4:  ANDWF  00,F
0CB6:  BCF    xE7.3
0CB8:  BTFSC  00.0
0CBA:  BSF    xE7.3
....................    GREEN_Colour.B5 = EEpDat >> 4; 
0CBC:  SWAPF  36,W
0CBE:  MOVWF  00
0CC0:  MOVLW  0F
0CC2:  ANDWF  00,F
0CC4:  BCF    xE7.4
0CC6:  BTFSC  00.0
0CC8:  BSF    xE7.4
....................    GREEN_Colour.B6 = EEpDat >> 5; 
0CCA:  SWAPF  36,W
0CCC:  MOVWF  00
0CCE:  RRCF   00,F
0CD0:  MOVLW  07
0CD2:  ANDWF  00,F
0CD4:  BCF    xE7.5
0CD6:  BTFSC  00.0
0CD8:  BSF    xE7.5
....................    GREEN_Colour.B7 = EEpDat >> 6; 
0CDA:  SWAPF  36,W
0CDC:  MOVWF  00
0CDE:  RRCF   00,F
0CE0:  RRCF   00,F
0CE2:  MOVLW  03
0CE4:  ANDWF  00,F
0CE6:  BCF    xE7.6
0CE8:  BTFSC  00.0
0CEA:  BSF    xE7.6
....................    GREEN_Colour.B8 = EEpDat >> 7; 
0CEC:  CLRF   00
0CEE:  BTFSC  36.7
0CF0:  BSF    00.0
0CF2:  BCF    xE7.7
0CF4:  BTFSC  00.0
0CF6:  BSF    xE7.7
....................  
....................    ////////////////////////////////////////////////// 
....................  
....................    AutoAck = read_eeprom(0x18);          // Auto Acknoeledge 
0CF8:  MOVFF  FF2,87A
0CFC:  BCF    FF2.7
0CFE:  CLRF   FAA
0D00:  MOVLW  18
0D02:  MOVWF  FA9
0D04:  BCF    FA6.6
0D06:  BCF    FA6.7
0D08:  BSF    FA6.0
0D0A:  MOVF   FA8,W
0D0C:  MOVLB  8
0D0E:  BTFSC  x7A.7
0D10:  BSF    FF2.7
0D12:  MOVWF  67
....................    AutoAckTime = read_eeprom(0x19);      // Auto Acknoeledge Time 
0D14:  MOVFF  FF2,87A
0D18:  BCF    FF2.7
0D1A:  CLRF   FAA
0D1C:  MOVLW  19
0D1E:  MOVWF  FA9
0D20:  BCF    FA6.6
0D22:  BCF    FA6.7
0D24:  BSF    FA6.0
0D26:  MOVF   FA8,W
0D28:  BTFSC  x7A.7
0D2A:  BSF    FF2.7
0D2C:  MOVWF  68
....................    FlashingRate = read_eeprom(0x1A); // Flashing rate 
0D2E:  MOVFF  FF2,87A
0D32:  BCF    FF2.7
0D34:  CLRF   FAA
0D36:  MOVLW  1A
0D38:  MOVWF  FA9
0D3A:  BCF    FA6.6
0D3C:  BCF    FA6.7
0D3E:  BSF    FA6.0
0D40:  MOVF   FA8,W
0D42:  BTFSC  x7A.7
0D44:  BSF    FF2.7
0D46:  MOVWF  69
....................    NoOfPoint = read_eeprom(0x1B);        // Number of total point 
0D48:  MOVFF  FF2,87A
0D4C:  BCF    FF2.7
0D4E:  CLRF   FAA
0D50:  MOVLW  1B
0D52:  MOVWF  FA9
0D54:  BCF    FA6.6
0D56:  BCF    FA6.7
0D58:  BSF    FA6.0
0D5A:  MOVF   FA8,W
0D5C:  BTFSC  x7A.7
0D5E:  BSF    FF2.7
0D60:  MOVWF  6A
....................    FaultDelayTime = read_eeprom(0x1C);  // Master or slave sync(flashing) 
0D62:  MOVFF  FF2,87A
0D66:  BCF    FF2.7
0D68:  CLRF   FAA
0D6A:  MOVLW  1C
0D6C:  MOVWF  FA9
0D6E:  BCF    FA6.6
0D70:  BCF    FA6.7
0D72:  BSF    FA6.0
0D74:  MOVF   FA8,W
0D76:  BTFSC  x7A.7
0D78:  BSF    FF2.7
0D7A:  CLRF   03
0D7C:  MOVWF  x2D
0D7E:  MOVFF  03,82E
....................  
....................    Address = read_eeprom(0x1D);          //Communication address 
0D82:  MOVFF  FF2,87A
0D86:  BCF    FF2.7
0D88:  CLRF   FAA
0D8A:  MOVLW  1D
0D8C:  MOVWF  FA9
0D8E:  BCF    FA6.6
0D90:  BCF    FA6.7
0D92:  BSF    FA6.0
0D94:  MOVF   FA8,W
0D96:  BTFSC  x7A.7
0D98:  BSF    FF2.7
0D9A:  MOVWF  75
....................     
....................    FaultDelayTime[1] = read_eeprom(0x1E); 
0D9C:  MOVFF  FF2,87A
0DA0:  BCF    FF2.7
0DA2:  CLRF   FAA
0DA4:  MOVLW  1E
0DA6:  MOVWF  FA9
0DA8:  BCF    FA6.6
0DAA:  BCF    FA6.7
0DAC:  BSF    FA6.0
0DAE:  MOVF   FA8,W
0DB0:  BTFSC  x7A.7
0DB2:  BSF    FF2.7
0DB4:  CLRF   x30
0DB6:  MOVWF  x2F
....................    FaultDelayTime[2] = read_eeprom(0x1F); 
0DB8:  MOVFF  FF2,87A
0DBC:  BCF    FF2.7
0DBE:  CLRF   FAA
0DC0:  MOVLW  1F
0DC2:  MOVWF  FA9
0DC4:  BCF    FA6.6
0DC6:  BCF    FA6.7
0DC8:  BSF    FA6.0
0DCA:  MOVF   FA8,W
0DCC:  BTFSC  x7A.7
0DCE:  BSF    FF2.7
0DD0:  CLRF   x32
0DD2:  MOVWF  x31
....................    FaultDelayTime[3] = read_eeprom(0x20); 
0DD4:  MOVFF  FF2,87A
0DD8:  BCF    FF2.7
0DDA:  CLRF   FAA
0DDC:  MOVLW  20
0DDE:  MOVWF  FA9
0DE0:  BCF    FA6.6
0DE2:  BCF    FA6.7
0DE4:  BSF    FA6.0
0DE6:  MOVF   FA8,W
0DE8:  BTFSC  x7A.7
0DEA:  BSF    FF2.7
0DEC:  CLRF   x34
0DEE:  MOVWF  x33
....................    FaultDelayTime[4] = read_eeprom(0x21); 
0DF0:  MOVFF  FF2,87A
0DF4:  BCF    FF2.7
0DF6:  CLRF   FAA
0DF8:  MOVLW  21
0DFA:  MOVWF  FA9
0DFC:  BCF    FA6.6
0DFE:  BCF    FA6.7
0E00:  BSF    FA6.0
0E02:  MOVF   FA8,W
0E04:  BTFSC  x7A.7
0E06:  BSF    FF2.7
0E08:  CLRF   x36
0E0A:  MOVWF  x35
....................    FaultDelayTime[5] = read_eeprom(0x22); 
0E0C:  MOVFF  FF2,87A
0E10:  BCF    FF2.7
0E12:  CLRF   FAA
0E14:  MOVLW  22
0E16:  MOVWF  FA9
0E18:  BCF    FA6.6
0E1A:  BCF    FA6.7
0E1C:  BSF    FA6.0
0E1E:  MOVF   FA8,W
0E20:  BTFSC  x7A.7
0E22:  BSF    FF2.7
0E24:  CLRF   x38
0E26:  MOVWF  x37
....................    FaultDelayTime[6] = read_eeprom(0x23); 
0E28:  MOVFF  FF2,87A
0E2C:  BCF    FF2.7
0E2E:  CLRF   FAA
0E30:  MOVLW  23
0E32:  MOVWF  FA9
0E34:  BCF    FA6.6
0E36:  BCF    FA6.7
0E38:  BSF    FA6.0
0E3A:  MOVF   FA8,W
0E3C:  BTFSC  x7A.7
0E3E:  BSF    FF2.7
0E40:  CLRF   x3A
0E42:  MOVWF  x39
....................    FaultDelayTime[7] = read_eeprom(0x24); 
0E44:  MOVFF  FF2,87A
0E48:  BCF    FF2.7
0E4A:  CLRF   FAA
0E4C:  MOVLW  24
0E4E:  MOVWF  FA9
0E50:  BCF    FA6.6
0E52:  BCF    FA6.7
0E54:  BSF    FA6.0
0E56:  MOVF   FA8,W
0E58:  BTFSC  x7A.7
0E5A:  BSF    FF2.7
0E5C:  CLRF   x3C
0E5E:  MOVWF  x3B
....................    FaultDelayTime[8] = read_eeprom(0x25); 
0E60:  MOVFF  FF2,87A
0E64:  BCF    FF2.7
0E66:  CLRF   FAA
0E68:  MOVLW  25
0E6A:  MOVWF  FA9
0E6C:  BCF    FA6.6
0E6E:  BCF    FA6.7
0E70:  BSF    FA6.0
0E72:  MOVF   FA8,W
0E74:  BTFSC  x7A.7
0E76:  BSF    FF2.7
0E78:  CLRF   x3E
0E7A:  MOVWF  x3D
....................    FaultDelayTime[9] = read_eeprom(0x26); 
0E7C:  MOVFF  FF2,87A
0E80:  BCF    FF2.7
0E82:  CLRF   FAA
0E84:  MOVLW  26
0E86:  MOVWF  FA9
0E88:  BCF    FA6.6
0E8A:  BCF    FA6.7
0E8C:  BSF    FA6.0
0E8E:  MOVF   FA8,W
0E90:  BTFSC  x7A.7
0E92:  BSF    FF2.7
0E94:  CLRF   x40
0E96:  MOVWF  x3F
....................    FaultDelayTime[10] = read_eeprom(0x27); 
0E98:  MOVFF  FF2,87A
0E9C:  BCF    FF2.7
0E9E:  CLRF   FAA
0EA0:  MOVLW  27
0EA2:  MOVWF  FA9
0EA4:  BCF    FA6.6
0EA6:  BCF    FA6.7
0EA8:  BSF    FA6.0
0EAA:  MOVF   FA8,W
0EAC:  BTFSC  x7A.7
0EAE:  BSF    FF2.7
0EB0:  CLRF   x42
0EB2:  MOVWF  x41
....................    FaultDelayTime[11] = read_eeprom(0x28); 
0EB4:  MOVFF  FF2,87A
0EB8:  BCF    FF2.7
0EBA:  CLRF   FAA
0EBC:  MOVLW  28
0EBE:  MOVWF  FA9
0EC0:  BCF    FA6.6
0EC2:  BCF    FA6.7
0EC4:  BSF    FA6.0
0EC6:  MOVF   FA8,W
0EC8:  BTFSC  x7A.7
0ECA:  BSF    FF2.7
0ECC:  CLRF   x44
0ECE:  MOVWF  x43
....................    FaultDelayTime[12] = read_eeprom(0x29); 
0ED0:  MOVFF  FF2,87A
0ED4:  BCF    FF2.7
0ED6:  CLRF   FAA
0ED8:  MOVLW  29
0EDA:  MOVWF  FA9
0EDC:  BCF    FA6.6
0EDE:  BCF    FA6.7
0EE0:  BSF    FA6.0
0EE2:  MOVF   FA8,W
0EE4:  BTFSC  x7A.7
0EE6:  BSF    FF2.7
0EE8:  CLRF   x46
0EEA:  MOVWF  x45
....................    FaultDelayTime[13] = read_eeprom(0x2A); 
0EEC:  MOVFF  FF2,87A
0EF0:  BCF    FF2.7
0EF2:  CLRF   FAA
0EF4:  MOVLW  2A
0EF6:  MOVWF  FA9
0EF8:  BCF    FA6.6
0EFA:  BCF    FA6.7
0EFC:  BSF    FA6.0
0EFE:  MOVF   FA8,W
0F00:  BTFSC  x7A.7
0F02:  BSF    FF2.7
0F04:  CLRF   x48
0F06:  MOVWF  x47
....................    FaultDelayTime[14] = read_eeprom(0x2B); 
0F08:  MOVFF  FF2,87A
0F0C:  BCF    FF2.7
0F0E:  CLRF   FAA
0F10:  MOVLW  2B
0F12:  MOVWF  FA9
0F14:  BCF    FA6.6
0F16:  BCF    FA6.7
0F18:  BSF    FA6.0
0F1A:  MOVF   FA8,W
0F1C:  BTFSC  x7A.7
0F1E:  BSF    FF2.7
0F20:  CLRF   x4A
0F22:  MOVWF  x49
....................    FaultDelayTime[15] = read_eeprom(0x2C); 
0F24:  MOVFF  FF2,87A
0F28:  BCF    FF2.7
0F2A:  CLRF   FAA
0F2C:  MOVLW  2C
0F2E:  MOVWF  FA9
0F30:  BCF    FA6.6
0F32:  BCF    FA6.7
0F34:  BSF    FA6.0
0F36:  MOVF   FA8,W
0F38:  BTFSC  x7A.7
0F3A:  BSF    FF2.7
0F3C:  CLRF   x4C
0F3E:  MOVWF  x4B
....................    FaultDelayTime[16] = read_eeprom(0x2D); 
0F40:  MOVFF  FF2,87A
0F44:  BCF    FF2.7
0F46:  CLRF   FAA
0F48:  MOVLW  2D
0F4A:  MOVWF  FA9
0F4C:  BCF    FA6.6
0F4E:  BCF    FA6.7
0F50:  BSF    FA6.0
0F52:  MOVF   FA8,W
0F54:  BTFSC  x7A.7
0F56:  BSF    FF2.7
0F58:  CLRF   x4E
0F5A:  MOVWF  x4D
....................    FaultDelayTime[17] = read_eeprom(0x2E); 
0F5C:  MOVFF  FF2,87A
0F60:  BCF    FF2.7
0F62:  CLRF   FAA
0F64:  MOVLW  2E
0F66:  MOVWF  FA9
0F68:  BCF    FA6.6
0F6A:  BCF    FA6.7
0F6C:  BSF    FA6.0
0F6E:  MOVF   FA8,W
0F70:  BTFSC  x7A.7
0F72:  BSF    FF2.7
0F74:  CLRF   x50
0F76:  MOVWF  x4F
....................    FaultDelayTime[18] = read_eeprom(0x2F); 
0F78:  MOVFF  FF2,87A
0F7C:  BCF    FF2.7
0F7E:  CLRF   FAA
0F80:  MOVLW  2F
0F82:  MOVWF  FA9
0F84:  BCF    FA6.6
0F86:  BCF    FA6.7
0F88:  BSF    FA6.0
0F8A:  MOVF   FA8,W
0F8C:  BTFSC  x7A.7
0F8E:  BSF    FF2.7
0F90:  CLRF   x52
0F92:  MOVWF  x51
....................    FaultDelayTime[19] = read_eeprom(0x30); 
0F94:  MOVFF  FF2,87A
0F98:  BCF    FF2.7
0F9A:  CLRF   FAA
0F9C:  MOVLW  30
0F9E:  MOVWF  FA9
0FA0:  BCF    FA6.6
0FA2:  BCF    FA6.7
0FA4:  BSF    FA6.0
0FA6:  MOVF   FA8,W
0FA8:  BTFSC  x7A.7
0FAA:  BSF    FF2.7
0FAC:  CLRF   x54
0FAE:  MOVWF  x53
....................    FaultDelayTime[20] = read_eeprom(0x31); 
0FB0:  MOVFF  FF2,87A
0FB4:  BCF    FF2.7
0FB6:  CLRF   FAA
0FB8:  MOVLW  31
0FBA:  MOVWF  FA9
0FBC:  BCF    FA6.6
0FBE:  BCF    FA6.7
0FC0:  BSF    FA6.0
0FC2:  MOVF   FA8,W
0FC4:  BTFSC  x7A.7
0FC6:  BSF    FF2.7
0FC8:  CLRF   x56
0FCA:  MOVWF  x55
....................     
....................     
....................    unsigned int  a = 0;  
....................    unsigned char  phonenum; 
0FCC:  CLRF   x70
....................    for(; ; a++) 
....................    { 
....................       restart_wdt(); 
0FCE:  CLRWDT
....................       phonenum = read_eeprom(0x32 + a); 
0FD0:  MOVLW  32
0FD2:  ADDWF  x70,W
0FD4:  MOVWF  x7A
0FD6:  MOVFF  FF2,87B
0FDA:  BCF    FF2.7
0FDC:  CLRF   FAA
0FDE:  MOVFF  87A,FA9
0FE2:  BCF    FA6.6
0FE4:  BCF    FA6.7
0FE6:  BSF    FA6.0
0FE8:  MOVF   FA8,W
0FEA:  BTFSC  x7B.7
0FEC:  BSF    FF2.7
0FEE:  MOVWF  x71
....................       if((phonenum == 0x0D) || (a > 15)) 
0FF0:  MOVF   x71,W
0FF2:  SUBLW  0D
0FF4:  BZ    0FFC
0FF6:  MOVF   x70,W
0FF8:  SUBLW  0F
0FFA:  BC    1044
....................       { 
....................          sms_phonenumber[a] =  '\0'; 
0FFC:  CLRF   03
0FFE:  MOVF   x70,W
1000:  ADDLW  83
1002:  MOVWF  FE9
1004:  MOVLW  06
1006:  ADDWFC 03,W
1008:  MOVWF  FEA
100A:  CLRF   FEF
....................          write_eeprom(0x32+a,phonenum); 
100C:  MOVLW  32
100E:  ADDWF  x70,W
1010:  MOVWF  x7A
1012:  CLRF   FAA
1014:  MOVFF  87A,FA9
1018:  MOVFF  871,FA8
101C:  BCF    FA6.6
101E:  BCF    FA6.7
1020:  BSF    FA6.2
1022:  MOVF   FF2,W
1024:  MOVWF  00
1026:  BCF    FF2.7
1028:  MOVLB  F
102A:  MOVLW  55
102C:  MOVWF  FA7
102E:  MOVLW  AA
1030:  MOVWF  FA7
1032:  BSF    FA6.1
1034:  BTFSC  FA6.1
1036:  BRA    1034
1038:  BCF    FA6.2
103A:  MOVF   00,W
103C:  IORWF  FF2,F
....................          break; 
103E:  BRA    105E
....................       } 
....................       else 
1040:  BRA    1058
1042:  MOVLB  8
....................       { 
....................          sms_phonenumber[a] = phonenum; 
1044:  CLRF   03
1046:  MOVF   x70,W
1048:  ADDLW  83
104A:  MOVWF  FE9
104C:  MOVLW  06
104E:  ADDWFC 03,W
1050:  MOVWF  FEA
1052:  MOVFF  871,FEF
1056:  MOVLB  F
....................       } 
....................    } 
1058:  MOVLB  8
105A:  INCF   x70,F
105C:  BRA    0FCE
....................  
....................    /* 
....................    char b; 
....................    for(b=0; b<10; b++) 
....................    { 
....................       sms_phonenumber[b] = read_eeprom(0x32 + b); 
....................    } 
....................    sms_phonenumber[b] = '\0' ; // end string 
....................    */ 
....................  
....................     
....................    int16  i =3,j=0,k=0 , buff; 
105E:  MOVLB  8
1060:  CLRF   x73
1062:  MOVLW  03
1064:  MOVWF  x72
1066:  CLRF   x75
1068:  CLRF   x74
106A:  CLRF   x77
106C:  CLRF   x76
....................    for(; ; i++,j++) 
....................    { 
....................       restart_wdt(); 
106E:  CLRWDT
....................       buff = read_eeprom(0x5D+i); 
1070:  MOVLW  5D
1072:  ADDWF  x72,W
1074:  MOVWF  x7A
1076:  MOVLW  00
1078:  ADDWFC x73,W
107A:  MOVWF  x7B
107C:  MOVFF  FF2,87C
1080:  BCF    FF2.7
1082:  MOVFF  87B,FAA
1086:  MOVFF  87A,FA9
108A:  BCF    FA6.6
108C:  BCF    FA6.7
108E:  BSF    FA6.0
1090:  MOVF   FA8,W
1092:  BTFSC  x7C.7
1094:  BSF    FF2.7
1096:  CLRF   x79
1098:  MOVWF  x78
....................        
....................       if((buff == 0x0D)|| (j>41)) 
109A:  MOVF   x78,W
109C:  SUBLW  0D
109E:  BNZ   10A4
10A0:  MOVF   x79,F
10A2:  BZ    10AE
10A4:  MOVF   x75,F
10A6:  BNZ   10AE
10A8:  MOVF   x74,W
10AA:  SUBLW  29
10AC:  BC    10C0
....................       { 
....................          SMS_Massage1[j] = '\0' ; // end string 
10AE:  MOVLW  92
10B0:  ADDWF  x74,W
10B2:  MOVWF  FE9
10B4:  MOVLW  06
10B6:  ADDWFC x75,W
10B8:  MOVWF  FEA
10BA:  CLRF   FEF
....................          break; 
10BC:  BRA    10E4
....................       } 
....................       else 
10BE:  BRA    10D0
....................       { 
....................          SMS_Massage1[j] = buff; 
10C0:  MOVLW  92
10C2:  ADDWF  x74,W
10C4:  MOVWF  FE9
10C6:  MOVLW  06
10C8:  ADDWFC x75,W
10CA:  MOVWF  FEA
10CC:  MOVFF  878,FEF
....................           
....................       } 
....................    } 
10D0:  MOVFF  873,03
10D4:  MOVF   x72,W
10D6:  INCF   x72,F
10D8:  BTFSC  FD8.2
10DA:  INCF   x73,F
10DC:  INCF   x74,F
10DE:  BTFSC  FD8.2
10E0:  INCF   x75,F
10E2:  BRA    106E
....................     
....................    i++; 
10E4:  INCF   x72,F
10E6:  BTFSC  FD8.2
10E8:  INCF   x73,F
....................    j=0; 
10EA:  CLRF   x75
10EC:  CLRF   x74
....................     
....................    for(; ; i++,j++) 
....................    { 
....................       restart_wdt(); 
10EE:  CLRWDT
....................       buff = read_eeprom(0x5D+i); 
10F0:  MOVLW  5D
10F2:  ADDWF  x72,W
10F4:  MOVWF  x7A
10F6:  MOVLW  00
10F8:  ADDWFC x73,W
10FA:  MOVWF  x7B
10FC:  MOVFF  FF2,87C
1100:  BCF    FF2.7
1102:  MOVFF  87B,FAA
1106:  MOVFF  87A,FA9
110A:  BCF    FA6.6
110C:  BCF    FA6.7
110E:  BSF    FA6.0
1110:  MOVF   FA8,W
1112:  BTFSC  x7C.7
1114:  BSF    FF2.7
1116:  CLRF   x79
1118:  MOVWF  x78
....................        
....................       if((buff == 0x0D) || (j>41)) 
111A:  MOVF   x78,W
111C:  SUBLW  0D
111E:  BNZ   1124
1120:  MOVF   x79,F
1122:  BZ    112E
1124:  MOVF   x75,F
1126:  BNZ   112E
1128:  MOVF   x74,W
112A:  SUBLW  29
112C:  BC    1140
....................       { 
....................          SMS_Massage2[j] = '\0' ; // end string 
112E:  MOVLW  BB
1130:  ADDWF  x74,W
1132:  MOVWF  FE9
1134:  MOVLW  06
1136:  ADDWFC x75,W
1138:  MOVWF  FEA
113A:  CLRF   FEF
....................          break; 
113C:  BRA    1164
....................       } 
....................       else 
113E:  BRA    1150
....................       { 
....................          SMS_Massage2[j] = buff; 
1140:  MOVLW  BB
1142:  ADDWF  x74,W
1144:  MOVWF  FE9
1146:  MOVLW  06
1148:  ADDWFC x75,W
114A:  MOVWF  FEA
114C:  MOVFF  878,FEF
....................           
....................       } 
....................    } 
1150:  MOVFF  873,03
1154:  MOVF   x72,W
1156:  INCF   x72,F
1158:  BTFSC  FD8.2
115A:  INCF   x73,F
115C:  INCF   x74,F
115E:  BTFSC  FD8.2
1160:  INCF   x75,F
1162:  BRA    10EE
....................     
....................    i++; 
1164:  INCF   x72,F
1166:  BTFSC  FD8.2
1168:  INCF   x73,F
....................    j=0; 
116A:  CLRF   x75
116C:  CLRF   x74
....................     
....................    for(; ; i++,j++) 
....................    { 
....................       restart_wdt(); 
116E:  CLRWDT
....................       buff = read_eeprom(0x5D+i); 
1170:  MOVLW  5D
1172:  ADDWF  x72,W
1174:  MOVWF  x7A
1176:  MOVLW  00
1178:  ADDWFC x73,W
117A:  MOVWF  x7B
117C:  MOVFF  FF2,87C
1180:  BCF    FF2.7
1182:  MOVFF  87B,FAA
1186:  MOVFF  87A,FA9
118A:  BCF    FA6.6
118C:  BCF    FA6.7
118E:  BSF    FA6.0
1190:  MOVF   FA8,W
1192:  BTFSC  x7C.7
1194:  BSF    FF2.7
1196:  CLRF   x79
1198:  MOVWF  x78
....................        
....................       if((buff == 0x0D) || (j>41)) 
119A:  MOVF   x78,W
119C:  SUBLW  0D
119E:  BNZ   11A4
11A0:  MOVF   x79,F
11A2:  BZ    11AE
11A4:  MOVF   x75,F
11A6:  BNZ   11AE
11A8:  MOVF   x74,W
11AA:  SUBLW  29
11AC:  BC    11C0
....................       { 
....................          SMS_Massage3[j] = '\0' ; // end string 
11AE:  MOVLW  E4
11B0:  ADDWF  x74,W
11B2:  MOVWF  FE9
11B4:  MOVLW  06
11B6:  ADDWFC x75,W
11B8:  MOVWF  FEA
11BA:  CLRF   FEF
....................          break; 
11BC:  BRA    11E4
....................       } 
....................       else 
11BE:  BRA    11D0
....................       { 
....................          SMS_Massage3[j] = buff; 
11C0:  MOVLW  E4
11C2:  ADDWF  x74,W
11C4:  MOVWF  FE9
11C6:  MOVLW  06
11C8:  ADDWFC x75,W
11CA:  MOVWF  FEA
11CC:  MOVFF  878,FEF
....................           
....................       } 
....................    } 
11D0:  MOVFF  873,03
11D4:  MOVF   x72,W
11D6:  INCF   x72,F
11D8:  BTFSC  FD8.2
11DA:  INCF   x73,F
11DC:  INCF   x74,F
11DE:  BTFSC  FD8.2
11E0:  INCF   x75,F
11E2:  BRA    116E
....................     
....................    i++; 
11E4:  INCF   x72,F
11E6:  BTFSC  FD8.2
11E8:  INCF   x73,F
....................    j=0; 
11EA:  CLRF   x75
11EC:  CLRF   x74
....................     
....................    for(; ; i++,j++) 
....................    { 
....................       restart_wdt(); 
11EE:  CLRWDT
....................       buff = read_eeprom(0x5D+i); 
11F0:  MOVLW  5D
11F2:  ADDWF  x72,W
11F4:  MOVWF  x7A
11F6:  MOVLW  00
11F8:  ADDWFC x73,W
11FA:  MOVWF  x7B
11FC:  MOVFF  FF2,87C
1200:  BCF    FF2.7
1202:  MOVFF  87B,FAA
1206:  MOVFF  87A,FA9
120A:  BCF    FA6.6
120C:  BCF    FA6.7
120E:  BSF    FA6.0
1210:  MOVF   FA8,W
1212:  BTFSC  x7C.7
1214:  BSF    FF2.7
1216:  CLRF   x79
1218:  MOVWF  x78
....................        
....................       if((buff == 0x0D) || (j>41)) 
121A:  MOVF   x78,W
121C:  SUBLW  0D
121E:  BNZ   1224
1220:  MOVF   x79,F
1222:  BZ    122E
1224:  MOVF   x75,F
1226:  BNZ   122E
1228:  MOVF   x74,W
122A:  SUBLW  29
122C:  BC    1240
....................       { 
....................          SMS_Massage4[j] = '\0' ; // end string 
122E:  MOVLW  0D
1230:  ADDWF  x74,W
1232:  MOVWF  FE9
1234:  MOVLW  07
1236:  ADDWFC x75,W
1238:  MOVWF  FEA
123A:  CLRF   FEF
....................          break; 
123C:  BRA    1264
....................       } 
....................       else 
123E:  BRA    1250
....................       { 
....................          SMS_Massage4[j] = buff; 
1240:  MOVLW  0D
1242:  ADDWF  x74,W
1244:  MOVWF  FE9
1246:  MOVLW  07
1248:  ADDWFC x75,W
124A:  MOVWF  FEA
124C:  MOVFF  878,FEF
....................           
....................       } 
....................    } 
1250:  MOVFF  873,03
1254:  MOVF   x72,W
1256:  INCF   x72,F
1258:  BTFSC  FD8.2
125A:  INCF   x73,F
125C:  INCF   x74,F
125E:  BTFSC  FD8.2
1260:  INCF   x75,F
1262:  BRA    11EE
....................     
....................    i++; 
1264:  INCF   x72,F
1266:  BTFSC  FD8.2
1268:  INCF   x73,F
....................    j=0; 
126A:  CLRF   x75
126C:  CLRF   x74
....................     
....................    for(; ; i++,j++) 
....................    { 
....................       restart_wdt(); 
126E:  CLRWDT
....................       buff = read_eeprom(0x5D+i); 
1270:  MOVLW  5D
1272:  ADDWF  x72,W
1274:  MOVWF  x7A
1276:  MOVLW  00
1278:  ADDWFC x73,W
127A:  MOVWF  x7B
127C:  MOVFF  FF2,87C
1280:  BCF    FF2.7
1282:  MOVFF  87B,FAA
1286:  MOVFF  87A,FA9
128A:  BCF    FA6.6
128C:  BCF    FA6.7
128E:  BSF    FA6.0
1290:  MOVF   FA8,W
1292:  BTFSC  x7C.7
1294:  BSF    FF2.7
1296:  CLRF   x79
1298:  MOVWF  x78
....................        
....................       if((buff == 0x0D) || (j>41)) 
129A:  MOVF   x78,W
129C:  SUBLW  0D
129E:  BNZ   12A4
12A0:  MOVF   x79,F
12A2:  BZ    12AE
12A4:  MOVF   x75,F
12A6:  BNZ   12AE
12A8:  MOVF   x74,W
12AA:  SUBLW  29
12AC:  BC    12C0
....................       { 
....................          SMS_Massage5[j] = '\0' ; // end string 
12AE:  MOVLW  36
12B0:  ADDWF  x74,W
12B2:  MOVWF  FE9
12B4:  MOVLW  07
12B6:  ADDWFC x75,W
12B8:  MOVWF  FEA
12BA:  CLRF   FEF
....................          break; 
12BC:  BRA    12E4
....................       } 
....................       else 
12BE:  BRA    12D0
....................       { 
....................          SMS_Massage5[j] = buff; 
12C0:  MOVLW  36
12C2:  ADDWF  x74,W
12C4:  MOVWF  FE9
12C6:  MOVLW  07
12C8:  ADDWFC x75,W
12CA:  MOVWF  FEA
12CC:  MOVFF  878,FEF
....................           
....................       } 
....................    } 
12D0:  MOVFF  873,03
12D4:  MOVF   x72,W
12D6:  INCF   x72,F
12D8:  BTFSC  FD8.2
12DA:  INCF   x73,F
12DC:  INCF   x74,F
12DE:  BTFSC  FD8.2
12E0:  INCF   x75,F
12E2:  BRA    126E
....................     
....................    i++; 
12E4:  INCF   x72,F
12E6:  BTFSC  FD8.2
12E8:  INCF   x73,F
....................    j=0; 
12EA:  CLRF   x75
12EC:  CLRF   x74
....................     
....................    for(; ; i++,j++) 
....................    { 
....................       restart_wdt(); 
12EE:  CLRWDT
....................       buff = read_eeprom(0x5D+i); 
12F0:  MOVLW  5D
12F2:  ADDWF  x72,W
12F4:  MOVWF  x7A
12F6:  MOVLW  00
12F8:  ADDWFC x73,W
12FA:  MOVWF  x7B
12FC:  MOVFF  FF2,87C
1300:  BCF    FF2.7
1302:  MOVFF  87B,FAA
1306:  MOVFF  87A,FA9
130A:  BCF    FA6.6
130C:  BCF    FA6.7
130E:  BSF    FA6.0
1310:  MOVF   FA8,W
1312:  BTFSC  x7C.7
1314:  BSF    FF2.7
1316:  CLRF   x79
1318:  MOVWF  x78
....................        
....................       if((buff == 0x0D) || (j>41)) 
131A:  MOVF   x78,W
131C:  SUBLW  0D
131E:  BNZ   1324
1320:  MOVF   x79,F
1322:  BZ    132E
1324:  MOVF   x75,F
1326:  BNZ   132E
1328:  MOVF   x74,W
132A:  SUBLW  29
132C:  BC    1340
....................       { 
....................          SMS_Massage6[j] = '\0' ; // end string 
132E:  MOVLW  5F
1330:  ADDWF  x74,W
1332:  MOVWF  FE9
1334:  MOVLW  07
1336:  ADDWFC x75,W
1338:  MOVWF  FEA
133A:  CLRF   FEF
....................          break; 
133C:  BRA    1364
....................       } 
....................       else 
133E:  BRA    1350
....................       { 
....................          SMS_Massage6[j] = buff; 
1340:  MOVLW  5F
1342:  ADDWF  x74,W
1344:  MOVWF  FE9
1346:  MOVLW  07
1348:  ADDWFC x75,W
134A:  MOVWF  FEA
134C:  MOVFF  878,FEF
....................           
....................       } 
....................    } 
1350:  MOVFF  873,03
1354:  MOVF   x72,W
1356:  INCF   x72,F
1358:  BTFSC  FD8.2
135A:  INCF   x73,F
135C:  INCF   x74,F
135E:  BTFSC  FD8.2
1360:  INCF   x75,F
1362:  BRA    12EE
....................     
....................    i++; 
1364:  INCF   x72,F
1366:  BTFSC  FD8.2
1368:  INCF   x73,F
....................    j=0; 
136A:  CLRF   x75
136C:  CLRF   x74
....................     
....................    for(; ; i++,j++) 
....................    { 
....................       restart_wdt(); 
136E:  CLRWDT
....................       buff = read_eeprom(0x5D+i); 
1370:  MOVLW  5D
1372:  ADDWF  x72,W
1374:  MOVWF  x7A
1376:  MOVLW  00
1378:  ADDWFC x73,W
137A:  MOVWF  x7B
137C:  MOVFF  FF2,87C
1380:  BCF    FF2.7
1382:  MOVFF  87B,FAA
1386:  MOVFF  87A,FA9
138A:  BCF    FA6.6
138C:  BCF    FA6.7
138E:  BSF    FA6.0
1390:  MOVF   FA8,W
1392:  BTFSC  x7C.7
1394:  BSF    FF2.7
1396:  CLRF   x79
1398:  MOVWF  x78
....................        
....................       if((buff == 0x0D) || (j>41)) 
139A:  MOVF   x78,W
139C:  SUBLW  0D
139E:  BNZ   13A4
13A0:  MOVF   x79,F
13A2:  BZ    13AE
13A4:  MOVF   x75,F
13A6:  BNZ   13AE
13A8:  MOVF   x74,W
13AA:  SUBLW  29
13AC:  BC    13C0
....................       { 
....................          SMS_Massage7[j] = '\0' ; // end string 
13AE:  MOVLW  88
13B0:  ADDWF  x74,W
13B2:  MOVWF  FE9
13B4:  MOVLW  07
13B6:  ADDWFC x75,W
13B8:  MOVWF  FEA
13BA:  CLRF   FEF
....................          break; 
13BC:  BRA    13E4
....................       } 
....................       else 
13BE:  BRA    13D0
....................       { 
....................          SMS_Massage7[j] = buff; 
13C0:  MOVLW  88
13C2:  ADDWF  x74,W
13C4:  MOVWF  FE9
13C6:  MOVLW  07
13C8:  ADDWFC x75,W
13CA:  MOVWF  FEA
13CC:  MOVFF  878,FEF
....................           
....................       } 
....................    } 
13D0:  MOVFF  873,03
13D4:  MOVF   x72,W
13D6:  INCF   x72,F
13D8:  BTFSC  FD8.2
13DA:  INCF   x73,F
13DC:  INCF   x74,F
13DE:  BTFSC  FD8.2
13E0:  INCF   x75,F
13E2:  BRA    136E
....................     
....................    i++; 
13E4:  INCF   x72,F
13E6:  BTFSC  FD8.2
13E8:  INCF   x73,F
....................    j=0; 
13EA:  CLRF   x75
13EC:  CLRF   x74
....................     
....................    for(; ; i++,j++) 
....................    { 
....................       restart_wdt(); 
13EE:  CLRWDT
....................       buff = read_eeprom(0x5D+i); 
13F0:  MOVLW  5D
13F2:  ADDWF  x72,W
13F4:  MOVWF  x7A
13F6:  MOVLW  00
13F8:  ADDWFC x73,W
13FA:  MOVWF  x7B
13FC:  MOVFF  FF2,87C
1400:  BCF    FF2.7
1402:  MOVFF  87B,FAA
1406:  MOVFF  87A,FA9
140A:  BCF    FA6.6
140C:  BCF    FA6.7
140E:  BSF    FA6.0
1410:  MOVF   FA8,W
1412:  BTFSC  x7C.7
1414:  BSF    FF2.7
1416:  CLRF   x79
1418:  MOVWF  x78
....................        
....................       if((buff == 0x0D) || (j>41)) 
141A:  MOVF   x78,W
141C:  SUBLW  0D
141E:  BNZ   1424
1420:  MOVF   x79,F
1422:  BZ    142E
1424:  MOVF   x75,F
1426:  BNZ   142E
1428:  MOVF   x74,W
142A:  SUBLW  29
142C:  BC    1440
....................       { 
....................          SMS_Massage8[j] = '\0' ; // end string 
142E:  MOVLW  B1
1430:  ADDWF  x74,W
1432:  MOVWF  FE9
1434:  MOVLW  07
1436:  ADDWFC x75,W
1438:  MOVWF  FEA
143A:  CLRF   FEF
....................          break; 
143C:  BRA    1464
....................       } 
....................       else 
143E:  BRA    1450
....................       { 
....................          SMS_Massage8[j] = buff; 
1440:  MOVLW  B1
1442:  ADDWF  x74,W
1444:  MOVWF  FE9
1446:  MOVLW  07
1448:  ADDWFC x75,W
144A:  MOVWF  FEA
144C:  MOVFF  878,FEF
....................           
....................       } 
....................    }  
1450:  MOVFF  873,03
1454:  MOVF   x72,W
1456:  INCF   x72,F
1458:  BTFSC  FD8.2
145A:  INCF   x73,F
145C:  INCF   x74,F
145E:  BTFSC  FD8.2
1460:  INCF   x75,F
1462:  BRA    13EE
....................    
....................     
....................  
.................... } 
1464:  MOVLB  0
1466:  RETLW  00
.................... ////////////////////////////////////////////////////////////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... #int_RDA 
.................... void RDA_isr(void) 
.................... { 
....................  
....................    //Data = getc(); 
....................    //putc(Data); 
....................    SBUF = getc(); 
*
0530:  CLRWDT
0532:  BTFSS  F9E.5
0534:  BRA    0530
0536:  MOVFF  FAE,2B
....................    checkCommand(); 
053A:  BRA    02D6
.................... } 
....................  
053C:  BCF    F9E.5
053E:  GOTO   0060
.................... #int_TIMER2 
.................... void TIMER2_isr(void)      //10ms 
.................... { 
....................    StatusTime++; 
0542:  INCF   16,F
....................  
....................    if(T_timeout != 0) 
0544:  MOVLB  6
0546:  MOVF   x80,F
0548:  BZ    0558
....................    { 
....................       T_timeout--; 
054A:  DECF   x80,F
....................       if(T_timeout == 0) 
054C:  MOVF   x80,F
054E:  BNZ   0558
....................       { 
....................          //sequence = stop_sq;         //timeout 
....................          sequence = end_sq;         //timeout    
0550:  MOVFF  6C,74
....................          output_bit(P485ctrl,0); 
0554:  BCF    F8A.3
0556:  BCF    F93.3
....................       } 
....................    } 
....................    ////////// Time Base 1 Second ///////////// 
....................    if(TimeBase1s != 0x00) 
0558:  MOVF   19,F
055A:  BZ    0574
....................    { 
....................       TimeBase1s--; 
055C:  DECF   19,F
....................       if(TimeBase1s == 0x00)      // <====== code in time base 1 second 
055E:  MOVF   19,F
0560:  BNZ   0574
....................       { 
....................          if(AutoAckDelayTime != 0x00) 
0562:  MOVF   1A,F
0564:  BZ    056E
....................          { 
....................             AutoAckDelayTime--; 
0566:  DECF   1A,F
....................             if(AutoAckDelayTime == 0x00) 
0568:  MOVF   1A,F
056A:  BNZ   056E
....................             { 
....................                AutoAckFlag = 1 ; 
056C:  BSF    17.2
....................             } 
....................          } 
....................          ////////////////////////////// 
....................          RefreshConfigData = 1; 
056E:  BSF    2D.4
....................          TimeBase1s = 100; 
0570:  MOVLW  64
0572:  MOVWF  19
....................       } 
....................  
....................    } 
....................    ///////////// End Time base 1 Second /////// 
....................  
....................  
....................  
....................    if(StatusTime == 50)    //500mS 
0574:  MOVF   16,W
0576:  SUBLW  32
0578:  BNZ   05A4
....................    { 
....................       StatusTime = 0; 
057A:  CLRF   16
....................       if(HearthbeatInd == 0) 
057C:  BTFSC  17.0
057E:  BRA    0588
....................       { 
....................          HearthbeatInd = 1; 
0580:  BSF    17.0
....................          output_bit(Pled,1); 
0582:  BSF    F8A.5
0584:  BCF    F93.5
....................       } 
....................       else 
0586:  BRA    058E
....................       { 
....................          HearthbeatInd = 0; 
0588:  BCF    17.0
....................          output_bit(Pled,0); 
058A:  BCF    F8A.5
058C:  BCF    F93.5
....................       } 
....................       /////////////////////////////////////////// time base 500 ms 
....................       if(Test == 1)            //Test function 
058E:  BTFSS  17.6
0590:  BRA    05A2
....................       { 
....................              if(T_test > 0x00) T_test --; 
0592:  MOVF   2C,F
0594:  BTFSS  FD8.2
0596:  DECF   2C,F
....................              if(T_test == 0x00) 
0598:  MOVF   2C,F
059A:  BNZ   05A0
....................              { 
....................                Test_fault = 1; 
059C:  BSF    17.5
....................                functointest_f = 1; 
059E:  BSF    2D.1
....................              } 
....................        } 
....................        else 
05A0:  BRA    05A4
....................        { 
....................           //Test = 0; 
....................           T_test = 0x00; 
05A2:  CLRF   2C
....................        } 
....................    } 
....................    /////////////////////////////// 
....................    if(FlashingRateTime != 0) 
05A4:  MOVF   18,F
05A6:  BZ    05D0
....................    { 
....................       FlashingRateTime--; 
05A8:  DECF   18,F
....................       if(FlashingRateTime == 0) 
05AA:  MOVF   18,F
05AC:  BNZ   05C4
....................       { 
....................          outmcp23 = 0xff; 
05AE:  MOVLW  FF
05B0:  MOVWF  x82
....................           
....................          if(SyncStatus == 0) 
05B2:  BTFSC  2D.2
05B4:  BRA    05C0
....................          { 
....................             if(FlashingFlag == 1) 
05B6:  BTFSS  17.1
05B8:  BRA    05BE
....................             { 
....................                FlashingFlag = 0; 
05BA:  BCF    17.1
....................                //output_bit(PSyncS,0); 
....................             } 
....................             else 
05BC:  BRA    05C0
....................             { 
....................  
....................                FlashingFlag = 1; 
05BE:  BSF    17.1
....................                //output_bit(PSyncS,1); 
....................             } 
....................          } 
....................          //FlashingFlag = ~FlashingFlag; 
....................          FlashingRateTime = FlashingRate;      //reload value 
05C0:  MOVFF  69,18
....................       } 
....................  
....................       if(Synctimer != 0x00) 
05C4:  MOVF   2E,F
05C6:  BZ    05D0
....................       { 
....................          Synctimer--; 
05C8:  DECF   2E,F
....................          if(Synctimer == 0x00) 
05CA:  MOVF   2E,F
05CC:  BNZ   05D0
....................          { 
....................             SyncStatus = 0; 
05CE:  BCF    2D.2
....................          } 
....................       } 
....................  
....................    } 
....................     
.................... } 
....................  
.................... /////////////////////////////////////////////////////////////////////////////////////////// 
.................... /////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
05D0:  BCF    F9E.1
05D2:  MOVLB  0
05D4:  GOTO   0060
.................... void Anal_Function(void) 
.................... { 
....................    ///////////////////////////////////////////////////////////////////////////// 
....................    ////////////////////////////// MANUAL RESET ///////////////////////////////// 
....................    ///////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... //if(NoOfPoint >= 10) 
.................... //{ 
....................  
.................... //input1 
....................    if(AlarmIndicator.B1 == 1)    // Alarm Function 
*
499A:  MOVLB  7
499C:  BTFSS  xE0.0
499E:  BRA    4A8C
....................    { 
....................       if((((Input.B1 ^ InputType.B1) == 1) && (FaultType.B1 == 1))|| In.B1 == 1)    // alarm1 occure and "Lock type" 
49A0:  MOVLW  00
49A2:  BTFSC  xDA.0
49A4:  MOVLW  01
49A6:  MOVLB  8
49A8:  MOVWF  x78
49AA:  MOVLW  00
49AC:  MOVLB  7
49AE:  BTFSC  xDC.0
49B0:  MOVLW  01
49B2:  MOVLB  8
49B4:  XORWF  x78,W
49B6:  SUBLW  01
49B8:  BNZ   49C0
49BA:  MOVLB  7
49BC:  BTFSC  xDD.0
49BE:  BRA    49C6
49C0:  MOVLB  7
49C2:  BTFSS  xE2.0
49C4:  BRA    4A86
....................       //if(Input.B1 == 0) 
....................       { 
....................          if(Ack.B1 == 0) 
49C6:  BTFSC  xE1.0
49C8:  BRA    4A84
....................          { 
....................             if(In.B1 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
49CA:  BTFSC  xE2.0
49CC:  BRA    49DC
49CE:  MOVF   67,W
49D0:  SUBLW  0F
49D2:  BNZ   49DC
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
49D4:  MOVLW  64
49D6:  MOVWF  19
....................                AutoAckDelayTime = AutoAckTime ; 
49D8:  MOVFF  68,1A
....................             } 
....................  
....................             In.B1 = 1;                                 // setbit in1 
49DC:  BSF    xE2.0
....................             if(FlashingFlag == 0) 
49DE:  BTFSC  17.1
49E0:  BRA    49E6
....................             { 
....................                Output.B1 = 0;           //Flash output1 
49E2:  BCF    xDB.0
....................             } 
....................             else 
49E4:  BRA    49E8
....................             { 
....................                Output.B1 = 1; 
49E6:  BSF    xDB.0
....................             } 
....................  
....................             if (~AutoTestFlag) 
49E8:  BTFSC  17.4
49EA:  BRA    4A08
....................             { 
....................                 
....................                if(OutputBoth.B1 == 0)                  //Both output 
49EC:  BTFSC  xDF.0
49EE:  BRA    49FA
....................                { 
....................                   output_bit(Pbuzzer,0);   //Buzzer 
49F0:  BCF    F89.4
49F2:  BCF    F92.4
....................                   output_bit(Pbell,0);     //Bell 
49F4:  BCF    F89.3
49F6:  BCF    F92.3
....................                } 
....................                else 
49F8:  BRA    4A08
....................                { 
....................                   if(OutputType.B1 == 1) output_bit(Pbuzzer,0);     //Buzzer 
49FA:  BTFSS  xDE.0
49FC:  BRA    4A04
49FE:  BCF    F89.4
4A00:  BCF    F92.4
....................                   else output_bit(Pbell,0);                          //Bell 
4A02:  BRA    4A08
4A04:  BCF    F89.3
4A06:  BCF    F92.3
....................                } 
....................                 
....................             } 
....................              
....................             // SMS Sending    
....................             if((SendSMS.B1 ==0) && (functointest_f ==0) && (Ack.B1 ==0)) 
4A08:  BTFSC  xE8.0
4A0A:  BRA    4A84
4A0C:  BTFSC  2D.1
4A0E:  BRA    4A84
4A10:  BTFSC  xE1.0
4A12:  BRA    4A84
....................             { 
....................                printf("AT+CMGF=1");  
4A14:  MOVLW  D8
4A16:  MOVWF  FF6
4A18:  MOVLW  05
4A1A:  MOVWF  FF7
4A1C:  MOVLB  0
4A1E:  CALL   1F28
....................                putc('\n'); 
4A22:  MOVLW  0A
4A24:  CALL   1F4C
....................                delay_ms(10); 
4A28:  MOVLW  0A
4A2A:  MOVLB  8
4A2C:  MOVWF  x79
4A2E:  MOVLB  0
4A30:  CALL   0772
....................              
....................                SendSMS.B1 =1; 
4A34:  MOVLB  7
4A36:  BSF    xE8.0
....................                printf("AT+CMGS=\""); 
4A38:  MOVLW  E2
4A3A:  MOVWF  FF6
4A3C:  MOVLW  05
4A3E:  MOVWF  FF7
4A40:  MOVLB  0
4A42:  CALL   1F28
....................                printf(sms_phonenumber); 
4A46:  MOVLW  06
4A48:  MOVWF  FEA
4A4A:  MOVLW  83
4A4C:  MOVWF  FE9
4A4E:  RCALL  448A
....................                 
....................                printf("\""); 
4A50:  MOVLW  22
4A52:  CLRWDT
4A54:  BTFSS  F9E.4
4A56:  BRA    4A52
4A58:  MOVWF  FAD
....................                putc('\n'); 
4A5A:  MOVLW  0A
4A5C:  CALL   1F4C
....................                delay_ms(50); 
4A60:  MOVLW  32
4A62:  MOVLB  8
4A64:  MOVWF  x79
4A66:  MOVLB  0
4A68:  CALL   0772
....................                
....................               //printf("Fault No.1");  
....................               printf(SMS_Massage1); 
4A6C:  MOVLW  06
4A6E:  MOVWF  FEA
4A70:  MOVLW  92
4A72:  MOVWF  FE9
4A74:  RCALL  448A
....................               putc('\n'); 
4A76:  MOVLW  0A
4A78:  CALL   1F4C
....................               putc(26); 
4A7C:  MOVLW  1A
4A7E:  CALL   1F4C
4A82:  MOVLB  7
....................             } 
....................         } 
....................       } 
....................       else if(FaultType.B1 == 1) Ack.B1 = 0; 
4A84:  BRA    4A8A
4A86:  BTFSC  xDD.0
4A88:  BCF    xE1.0
....................    } 
....................    else  //Indicator Function 
4A8A:  BRA    4B32
....................    { 
....................       if((Input.B1 ^ InputType.B1) == 1) 
4A8C:  MOVLW  00
4A8E:  BTFSC  xDA.0
4A90:  MOVLW  01
4A92:  MOVLB  8
4A94:  MOVWF  x78
4A96:  MOVLW  00
4A98:  MOVLB  7
4A9A:  BTFSC  xDC.0
4A9C:  MOVLW  01
4A9E:  MOVLB  8
4AA0:  XORWF  x78,W
4AA2:  SUBLW  01
4AA4:  BNZ   4B2A
....................       { 
....................          Output.B1 = 0; 
4AA6:  MOVLB  7
4AA8:  BCF    xDB.0
....................           
....................          // SMS Sending    
....................          if((SendSMS.B1 ==0) && (functointest_f ==0) && (Ack.B1 ==0)) 
4AAA:  BTFSC  xE8.0
4AAC:  BRA    4B26
4AAE:  BTFSC  2D.1
4AB0:  BRA    4B26
4AB2:  BTFSC  xE1.0
4AB4:  BRA    4B26
....................          { 
....................             printf("AT+CMGF=1");  
4AB6:  MOVLW  EC
4AB8:  MOVWF  FF6
4ABA:  MOVLW  05
4ABC:  MOVWF  FF7
4ABE:  MOVLB  0
4AC0:  CALL   1F28
....................             putc('\n'); 
4AC4:  MOVLW  0A
4AC6:  CALL   1F4C
....................             delay_ms(10); 
4ACA:  MOVLW  0A
4ACC:  MOVLB  8
4ACE:  MOVWF  x79
4AD0:  MOVLB  0
4AD2:  CALL   0772
....................              
....................             SendSMS.B1 =1; 
4AD6:  MOVLB  7
4AD8:  BSF    xE8.0
....................             printf("AT+CMGS=\""); 
4ADA:  MOVLW  F6
4ADC:  MOVWF  FF6
4ADE:  MOVLW  05
4AE0:  MOVWF  FF7
4AE2:  MOVLB  0
4AE4:  CALL   1F28
....................             printf(sms_phonenumber); 
4AE8:  MOVLW  06
4AEA:  MOVWF  FEA
4AEC:  MOVLW  83
4AEE:  MOVWF  FE9
4AF0:  RCALL  448A
....................              
....................             printf("\""); 
4AF2:  MOVLW  22
4AF4:  CLRWDT
4AF6:  BTFSS  F9E.4
4AF8:  BRA    4AF4
4AFA:  MOVWF  FAD
....................             putc('\n'); 
4AFC:  MOVLW  0A
4AFE:  CALL   1F4C
....................             delay_ms(50); 
4B02:  MOVLW  32
4B04:  MOVLB  8
4B06:  MOVWF  x79
4B08:  MOVLB  0
4B0A:  CALL   0772
....................             
....................            //printf("Fault No.1"); 
....................            printf(SMS_Massage1); 
4B0E:  MOVLW  06
4B10:  MOVWF  FEA
4B12:  MOVLW  92
4B14:  MOVWF  FE9
4B16:  RCALL  448A
....................            putc('\n'); 
4B18:  MOVLW  0A
4B1A:  CALL   1F4C
....................            putc(26); 
4B1E:  MOVLW  1A
4B20:  CALL   1F4C
4B24:  MOVLB  7
....................          } 
....................       } 
....................       else 
4B26:  BRA    4B32
4B28:  MOVLB  8
....................       { 
....................          Output.B1 = 1; 
4B2A:  MOVLB  7
4B2C:  BSF    xDB.0
....................           
....................          SendSMS.B1 =0; 
4B2E:  BCF    xE8.0
....................          functointest_f =0; 
4B30:  BCF    2D.1
....................       } 
....................    } 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input2 
....................    if(AlarmIndicator.B2 == 1)    // Alarm Function 
4B32:  BTFSS  xE0.1
4B34:  BRA    4C22
....................    { 
....................       if((((Input.B2 ^ InputType.B2) == 1) && (FaultType.B2 == 1))|| In.B2 == 1)    // alarm1 occure and "Lock type" 
4B36:  MOVLW  00
4B38:  BTFSC  xDA.1
4B3A:  MOVLW  01
4B3C:  MOVLB  8
4B3E:  MOVWF  x78
4B40:  MOVLW  00
4B42:  MOVLB  7
4B44:  BTFSC  xDC.1
4B46:  MOVLW  01
4B48:  MOVLB  8
4B4A:  XORWF  x78,W
4B4C:  SUBLW  01
4B4E:  BNZ   4B56
4B50:  MOVLB  7
4B52:  BTFSC  xDD.1
4B54:  BRA    4B5C
4B56:  MOVLB  7
4B58:  BTFSS  xE2.1
4B5A:  BRA    4C1C
....................       //if(Input.B2 == 0) 
....................       { 
....................          if(Ack.B2 == 0) 
4B5C:  BTFSC  xE1.1
4B5E:  BRA    4B9E
....................          { 
....................             if(In.B2 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
4B60:  BTFSC  xE2.1
4B62:  BRA    4B72
4B64:  MOVF   67,W
4B66:  SUBLW  0F
4B68:  BNZ   4B72
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
4B6A:  MOVLW  64
4B6C:  MOVWF  19
....................                AutoAckDelayTime = AutoAckTime ; 
4B6E:  MOVFF  68,1A
....................             } 
....................  
....................             In.B2 = 1;                                 // setbit in1 
4B72:  BSF    xE2.1
....................             if(FlashingFlag == 0) 
4B74:  BTFSC  17.1
4B76:  BRA    4B7C
....................             { 
....................                Output.B2 = 0;           //Flash output1 
4B78:  BCF    xDB.1
....................             } 
....................             else 
4B7A:  BRA    4B7E
....................             { 
....................                Output.B2 = 1; 
4B7C:  BSF    xDB.1
....................             } 
....................  
....................             if (~AutoTestFlag) 
4B7E:  BTFSC  17.4
4B80:  BRA    4B9E
....................             { 
....................                 
....................                if(OutputBoth.B2 == 0)                  //Both output 
4B82:  BTFSC  xDF.1
4B84:  BRA    4B90
....................                { 
....................                   output_bit(Pbuzzer,0);   //Buzzer 
4B86:  BCF    F89.4
4B88:  BCF    F92.4
....................                   output_bit(Pbell,0);     //Bell 
4B8A:  BCF    F89.3
4B8C:  BCF    F92.3
....................                } 
....................                else 
4B8E:  BRA    4B9E
....................                { 
....................                   if(OutputType.B2 == 1) output_bit(Pbuzzer,0);     //Buzzer 
4B90:  BTFSS  xDE.1
4B92:  BRA    4B9A
4B94:  BCF    F89.4
4B96:  BCF    F92.4
....................                   else output_bit(Pbell,0);                          //Bell 
4B98:  BRA    4B9E
4B9A:  BCF    F89.3
4B9C:  BCF    F92.3
....................                } 
....................                 
....................             } 
....................           } 
....................           // SMS Sending    
....................             if((SendSMS.B2 ==0)&& (functointest_f ==0) && (Ack.B2 ==0)) 
4B9E:  BTFSC  xE8.1
4BA0:  BRA    4C1A
4BA2:  BTFSC  2D.1
4BA4:  BRA    4C1A
4BA6:  BTFSC  xE1.1
4BA8:  BRA    4C1A
....................             { 
....................                printf("AT+CMGF=1");  
4BAA:  MOVLW  00
4BAC:  MOVWF  FF6
4BAE:  MOVLW  06
4BB0:  MOVWF  FF7
4BB2:  MOVLB  0
4BB4:  CALL   1F28
....................                putc('\n'); 
4BB8:  MOVLW  0A
4BBA:  CALL   1F4C
....................                delay_ms(10); 
4BBE:  MOVLW  0A
4BC0:  MOVLB  8
4BC2:  MOVWF  x79
4BC4:  MOVLB  0
4BC6:  CALL   0772
....................                  
....................                SendSMS.B2 =1; 
4BCA:  MOVLB  7
4BCC:  BSF    xE8.1
....................                printf("AT+CMGS=\""); 
4BCE:  MOVLW  0A
4BD0:  MOVWF  FF6
4BD2:  MOVLW  06
4BD4:  MOVWF  FF7
4BD6:  MOVLB  0
4BD8:  CALL   1F28
....................                printf(sms_phonenumber); 
4BDC:  MOVLW  06
4BDE:  MOVWF  FEA
4BE0:  MOVLW  83
4BE2:  MOVWF  FE9
4BE4:  RCALL  448A
....................                 
....................                printf("\""); 
4BE6:  MOVLW  22
4BE8:  CLRWDT
4BEA:  BTFSS  F9E.4
4BEC:  BRA    4BE8
4BEE:  MOVWF  FAD
....................                putc('\n'); 
4BF0:  MOVLW  0A
4BF2:  CALL   1F4C
....................                delay_ms(50); 
4BF6:  MOVLW  32
4BF8:  MOVLB  8
4BFA:  MOVWF  x79
4BFC:  MOVLB  0
4BFE:  CALL   0772
....................                 
....................               printf(SMS_Massage2); 
4C02:  MOVLW  06
4C04:  MOVWF  FEA
4C06:  MOVLW  BB
4C08:  MOVWF  FE9
4C0A:  RCALL  448A
....................               putc('\n'); 
4C0C:  MOVLW  0A
4C0E:  CALL   1F4C
....................               putc(26); 
4C12:  MOVLW  1A
4C14:  CALL   1F4C
4C18:  MOVLB  7
....................             }   
....................  
....................       } 
....................       else if(FaultType.B2 == 1) Ack.B2 = 0; 
4C1A:  BRA    4C20
4C1C:  BTFSC  xDD.1
4C1E:  BCF    xE1.1
....................    } 
....................    else  //Indicator Function 
4C20:  BRA    4CCA
....................    { 
....................       if((Input.B2 ^ InputType.B2) == 1) 
4C22:  MOVLW  00
4C24:  BTFSC  xDA.1
4C26:  MOVLW  01
4C28:  MOVLB  8
4C2A:  MOVWF  x78
4C2C:  MOVLW  00
4C2E:  MOVLB  7
4C30:  BTFSC  xDC.1
4C32:  MOVLW  01
4C34:  MOVLB  8
4C36:  XORWF  x78,W
4C38:  SUBLW  01
4C3A:  BNZ   4CC2
....................       { 
....................          Output.B2 = 0; 
4C3C:  MOVLB  7
4C3E:  BCF    xDB.1
....................           // SMS Sending    
....................          if((SendSMS.B2 ==0)&& (functointest_f ==0) && (Ack.B2 ==0)) 
4C40:  BTFSC  xE8.1
4C42:  BRA    4CBE
4C44:  BTFSC  2D.1
4C46:  BRA    4CBE
4C48:  BTFSC  xE1.1
4C4A:  BRA    4CBE
....................          { 
....................             printf("AT+CMGF=1");  
4C4C:  MOVLW  14
4C4E:  MOVWF  FF6
4C50:  MOVLW  06
4C52:  MOVWF  FF7
4C54:  MOVLB  0
4C56:  CALL   1F28
....................             putc('\n'); 
4C5A:  MOVLW  0A
4C5C:  CALL   1F4C
....................             delay_ms(10); 
4C60:  MOVLW  0A
4C62:  MOVLB  8
4C64:  MOVWF  x79
4C66:  MOVLB  0
4C68:  CALL   0772
....................              
....................             SendSMS.B2 =1; 
4C6C:  MOVLB  7
4C6E:  BSF    xE8.1
....................             printf("AT+CMGS=\""); 
4C70:  MOVLW  1E
4C72:  MOVWF  FF6
4C74:  MOVLW  06
4C76:  MOVWF  FF7
4C78:  MOVLB  0
4C7A:  CALL   1F28
....................             printf(sms_phonenumber); 
4C7E:  MOVLW  06
4C80:  MOVWF  FEA
4C82:  MOVLW  83
4C84:  MOVWF  FE9
4C86:  RCALL  448A
....................              
....................             printf("\""); 
4C88:  MOVLW  22
4C8A:  CLRWDT
4C8C:  BTFSS  F9E.4
4C8E:  BRA    4C8A
4C90:  MOVWF  FAD
....................             putc('\n'); 
4C92:  MOVLW  0A
4C94:  CALL   1F4C
....................             delay_ms(50); 
4C98:  MOVLW  32
4C9A:  MOVLB  8
4C9C:  MOVWF  x79
4C9E:  MOVLB  0
4CA0:  CALL   0772
....................             
....................            printf(SMS_Massage1); 
4CA4:  MOVLW  06
4CA6:  MOVWF  FEA
4CA8:  MOVLW  92
4CAA:  MOVWF  FE9
4CAC:  CALL   448A
....................            putc('\n'); 
4CB0:  MOVLW  0A
4CB2:  CALL   1F4C
....................            putc(26); 
4CB6:  MOVLW  1A
4CB8:  CALL   1F4C
4CBC:  MOVLB  7
....................          }   
....................       } 
....................       else 
4CBE:  BRA    4CCA
4CC0:  MOVLB  8
....................       { 
....................          Output.B2 = 1; 
4CC2:  MOVLB  7
4CC4:  BSF    xDB.1
....................           
....................          SendSMS.B2 =0; 
4CC6:  BCF    xE8.1
....................          functointest_f =0; 
4CC8:  BCF    2D.1
....................       } 
....................    } 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input3 
....................    if(AlarmIndicator.B3 == 1)    // Alarm Function 
4CCA:  BTFSS  xE0.2
4CCC:  BRA    4DBE
....................    { 
....................       if((((Input.B3 ^ InputType.B3) == 1) && (FaultType.B3 == 1))|| In.B3 == 1)    // alarm1 occure and "Lock type" 
4CCE:  MOVLW  00
4CD0:  BTFSC  xDA.2
4CD2:  MOVLW  01
4CD4:  MOVLB  8
4CD6:  MOVWF  x78
4CD8:  MOVLW  00
4CDA:  MOVLB  7
4CDC:  BTFSC  xDC.2
4CDE:  MOVLW  01
4CE0:  MOVLB  8
4CE2:  XORWF  x78,W
4CE4:  SUBLW  01
4CE6:  BNZ   4CEE
4CE8:  MOVLB  7
4CEA:  BTFSC  xDD.2
4CEC:  BRA    4CF4
4CEE:  MOVLB  7
4CF0:  BTFSS  xE2.2
4CF2:  BRA    4DB8
....................       //if(Input.B3 == 0) 
....................       { 
....................          if(Ack.B3 == 0) 
4CF4:  BTFSC  xE1.2
4CF6:  BRA    4D36
....................          { 
....................             if(In.B3 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
4CF8:  BTFSC  xE2.2
4CFA:  BRA    4D0A
4CFC:  MOVF   67,W
4CFE:  SUBLW  0F
4D00:  BNZ   4D0A
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
4D02:  MOVLW  64
4D04:  MOVWF  19
....................                AutoAckDelayTime = AutoAckTime ; 
4D06:  MOVFF  68,1A
....................             } 
....................  
....................             In.B3 = 1;                                 // setbit in1 
4D0A:  BSF    xE2.2
....................             if(FlashingFlag == 0) 
4D0C:  BTFSC  17.1
4D0E:  BRA    4D14
....................             { 
....................                Output.B3 = 0;           //Flash output1 
4D10:  BCF    xDB.2
....................             } 
....................             else 
4D12:  BRA    4D16
....................             { 
....................                Output.B3 = 1; 
4D14:  BSF    xDB.2
....................             } 
....................  
....................             if (~AutoTestFlag) 
4D16:  BTFSC  17.4
4D18:  BRA    4D36
....................             { 
....................                 
....................                if(OutputBoth.B3 == 0)                  //Both output 
4D1A:  BTFSC  xDF.2
4D1C:  BRA    4D28
....................                { 
....................                   output_bit(Pbuzzer,0);   //Buzzer 
4D1E:  BCF    F89.4
4D20:  BCF    F92.4
....................                   output_bit(Pbell,0);     //Bell 
4D22:  BCF    F89.3
4D24:  BCF    F92.3
....................                } 
....................                else 
4D26:  BRA    4D36
....................                { 
....................                   if(OutputType.B3 == 1) output_bit(Pbuzzer,0);     //Buzzer 
4D28:  BTFSS  xDE.2
4D2A:  BRA    4D32
4D2C:  BCF    F89.4
4D2E:  BCF    F92.4
....................                   else output_bit(Pbell,0);                          //Bell 
4D30:  BRA    4D36
4D32:  BCF    F89.3
4D34:  BCF    F92.3
....................                } 
....................                 
....................             } 
....................           } 
....................           // SMS Sending    
....................             if((SendSMS.B3 ==0)&& (functointest_f ==0) && (Ack.B3 ==0)) 
4D36:  BTFSC  xE8.2
4D38:  BRA    4DB6
4D3A:  BTFSC  2D.1
4D3C:  BRA    4DB6
4D3E:  BTFSC  xE1.2
4D40:  BRA    4DB6
....................             { 
....................                printf("AT+CMGF=1");  
4D42:  MOVLW  28
4D44:  MOVWF  FF6
4D46:  MOVLW  06
4D48:  MOVWF  FF7
4D4A:  MOVLB  0
4D4C:  CALL   1F28
....................                putc('\n'); 
4D50:  MOVLW  0A
4D52:  CALL   1F4C
....................                delay_ms(10); 
4D56:  MOVLW  0A
4D58:  MOVLB  8
4D5A:  MOVWF  x79
4D5C:  MOVLB  0
4D5E:  CALL   0772
....................                 
....................                SendSMS.B3 =1; 
4D62:  MOVLB  7
4D64:  BSF    xE8.2
....................                printf("AT+CMGS=\""); 
4D66:  MOVLW  32
4D68:  MOVWF  FF6
4D6A:  MOVLW  06
4D6C:  MOVWF  FF7
4D6E:  MOVLB  0
4D70:  CALL   1F28
....................                printf(sms_phonenumber); 
4D74:  MOVLW  06
4D76:  MOVWF  FEA
4D78:  MOVLW  83
4D7A:  MOVWF  FE9
4D7C:  CALL   448A
....................                 
....................                printf("\""); 
4D80:  MOVLW  22
4D82:  CLRWDT
4D84:  BTFSS  F9E.4
4D86:  BRA    4D82
4D88:  MOVWF  FAD
....................                putc('\n'); 
4D8A:  MOVLW  0A
4D8C:  CALL   1F4C
....................                delay_ms(50); 
4D90:  MOVLW  32
4D92:  MOVLB  8
4D94:  MOVWF  x79
4D96:  MOVLB  0
4D98:  CALL   0772
....................                
....................               printf(SMS_Massage3); 
4D9C:  MOVLW  06
4D9E:  MOVWF  FEA
4DA0:  MOVLW  E4
4DA2:  MOVWF  FE9
4DA4:  CALL   448A
....................               putc('\n'); 
4DA8:  MOVLW  0A
4DAA:  CALL   1F4C
....................               putc(26); 
4DAE:  MOVLW  1A
4DB0:  CALL   1F4C
4DB4:  MOVLB  7
....................             } 
....................  
....................       } 
....................       else if(FaultType.B3 == 1) Ack.B3 = 0; 
4DB6:  BRA    4DBC
4DB8:  BTFSC  xDD.2
4DBA:  BCF    xE1.2
....................    } 
....................    else  //Indicator Function 
4DBC:  BRA    4E66
....................    { 
....................       if((Input.B3 ^ InputType.B3) == 1) 
4DBE:  MOVLW  00
4DC0:  BTFSC  xDA.2
4DC2:  MOVLW  01
4DC4:  MOVLB  8
4DC6:  MOVWF  x78
4DC8:  MOVLW  00
4DCA:  MOVLB  7
4DCC:  BTFSC  xDC.2
4DCE:  MOVLW  01
4DD0:  MOVLB  8
4DD2:  XORWF  x78,W
4DD4:  SUBLW  01
4DD6:  BNZ   4E60
....................       { 
....................          Output.B3 = 0; 
4DD8:  MOVLB  7
4DDA:  BCF    xDB.2
....................          // SMS Sending    
....................          if((SendSMS.B3 ==0)&& (functointest_f ==0) && (Ack.B3 ==0)) 
4DDC:  BTFSC  xE8.2
4DDE:  BRA    4E5C
4DE0:  BTFSC  2D.1
4DE2:  BRA    4E5C
4DE4:  BTFSC  xE1.2
4DE6:  BRA    4E5C
....................          { 
....................             printf("AT+CMGF=1");  
4DE8:  MOVLW  3C
4DEA:  MOVWF  FF6
4DEC:  MOVLW  06
4DEE:  MOVWF  FF7
4DF0:  MOVLB  0
4DF2:  CALL   1F28
....................             putc('\n'); 
4DF6:  MOVLW  0A
4DF8:  CALL   1F4C
....................             delay_ms(10); 
4DFC:  MOVLW  0A
4DFE:  MOVLB  8
4E00:  MOVWF  x79
4E02:  MOVLB  0
4E04:  CALL   0772
....................              
....................             SendSMS.B3 =1; 
4E08:  MOVLB  7
4E0A:  BSF    xE8.2
....................             printf("AT+CMGS=\""); 
4E0C:  MOVLW  46
4E0E:  MOVWF  FF6
4E10:  MOVLW  06
4E12:  MOVWF  FF7
4E14:  MOVLB  0
4E16:  CALL   1F28
....................             printf(sms_phonenumber); 
4E1A:  MOVLW  06
4E1C:  MOVWF  FEA
4E1E:  MOVLW  83
4E20:  MOVWF  FE9
4E22:  CALL   448A
....................              
....................             printf("\""); 
4E26:  MOVLW  22
4E28:  CLRWDT
4E2A:  BTFSS  F9E.4
4E2C:  BRA    4E28
4E2E:  MOVWF  FAD
....................             putc('\n'); 
4E30:  MOVLW  0A
4E32:  CALL   1F4C
....................             delay_ms(50); 
4E36:  MOVLW  32
4E38:  MOVLB  8
4E3A:  MOVWF  x79
4E3C:  MOVLB  0
4E3E:  CALL   0772
....................             
....................            printf(SMS_Massage3); 
4E42:  MOVLW  06
4E44:  MOVWF  FEA
4E46:  MOVLW  E4
4E48:  MOVWF  FE9
4E4A:  CALL   448A
....................            putc('\n'); 
4E4E:  MOVLW  0A
4E50:  CALL   1F4C
....................            putc(26); 
4E54:  MOVLW  1A
4E56:  CALL   1F4C
4E5A:  MOVLB  7
....................          } 
....................       } 
....................       else 
4E5C:  BRA    4E66
4E5E:  MOVLB  8
....................       { 
....................          Output.B3 = 1; 
4E60:  MOVLB  7
4E62:  BSF    xDB.2
....................          SendSMS.B3 =0; 
4E64:  BCF    xE8.2
....................       } 
....................    } 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input4 
....................    if(AlarmIndicator.B4 == 1)    // Alarm Function 
4E66:  BTFSS  xE0.3
4E68:  BRA    4F5A
....................    { 
....................       if((((Input.B4 ^ InputType.B4) == 1) && (FaultType.B4 == 1))|| In.B4 == 1)    // alarm1 occure and "Lock type" 
4E6A:  MOVLW  00
4E6C:  BTFSC  xDA.3
4E6E:  MOVLW  01
4E70:  MOVLB  8
4E72:  MOVWF  x78
4E74:  MOVLW  00
4E76:  MOVLB  7
4E78:  BTFSC  xDC.3
4E7A:  MOVLW  01
4E7C:  MOVLB  8
4E7E:  XORWF  x78,W
4E80:  SUBLW  01
4E82:  BNZ   4E8A
4E84:  MOVLB  7
4E86:  BTFSC  xDD.3
4E88:  BRA    4E90
4E8A:  MOVLB  7
4E8C:  BTFSS  xE2.3
4E8E:  BRA    4F54
....................       //if(Input.B4 == 0) 
....................       { 
....................          if(Ack.B4 == 0) 
4E90:  BTFSC  xE1.3
4E92:  BRA    4ED2
....................          { 
....................             if(In.B4 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
4E94:  BTFSC  xE2.3
4E96:  BRA    4EA6
4E98:  MOVF   67,W
4E9A:  SUBLW  0F
4E9C:  BNZ   4EA6
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
4E9E:  MOVLW  64
4EA0:  MOVWF  19
....................                AutoAckDelayTime = AutoAckTime ; 
4EA2:  MOVFF  68,1A
....................             } 
....................  
....................             In.B4 = 1;                                 // setbit in1 
4EA6:  BSF    xE2.3
....................             if(FlashingFlag == 0) 
4EA8:  BTFSC  17.1
4EAA:  BRA    4EB0
....................             { 
....................                Output.B4 = 0;           //Flash output1 
4EAC:  BCF    xDB.3
....................             } 
....................             else 
4EAE:  BRA    4EB2
....................             { 
....................                Output.B4 = 1; 
4EB0:  BSF    xDB.3
....................             } 
....................  
....................             if (~AutoTestFlag) 
4EB2:  BTFSC  17.4
4EB4:  BRA    4ED2
....................             { 
....................                 
....................                if(OutputBoth.B4 == 0)                  //Both output 
4EB6:  BTFSC  xDF.3
4EB8:  BRA    4EC4
....................                { 
....................                   output_bit(Pbuzzer,0);   //Buzzer 
4EBA:  BCF    F89.4
4EBC:  BCF    F92.4
....................                   output_bit(Pbell,0);     //Bell 
4EBE:  BCF    F89.3
4EC0:  BCF    F92.3
....................                } 
....................                else 
4EC2:  BRA    4ED2
....................                { 
....................                   if(OutputType.B4 == 1) output_bit(Pbuzzer,0);     //Buzzer 
4EC4:  BTFSS  xDE.3
4EC6:  BRA    4ECE
4EC8:  BCF    F89.4
4ECA:  BCF    F92.4
....................                   else output_bit(Pbell,0);                          //Bell 
4ECC:  BRA    4ED2
4ECE:  BCF    F89.3
4ED0:  BCF    F92.3
....................                } 
....................                 
....................             } 
....................           } 
....................           // SMS Sending    
....................             if((SendSMS.B4 ==0)&& (functointest_f ==0) && (Ack.B4 ==0)) 
4ED2:  BTFSC  xE8.3
4ED4:  BRA    4F52
4ED6:  BTFSC  2D.1
4ED8:  BRA    4F52
4EDA:  BTFSC  xE1.3
4EDC:  BRA    4F52
....................             { 
....................                printf("AT+CMGF=1");  
4EDE:  MOVLW  50
4EE0:  MOVWF  FF6
4EE2:  MOVLW  06
4EE4:  MOVWF  FF7
4EE6:  MOVLB  0
4EE8:  CALL   1F28
....................                putc('\n'); 
4EEC:  MOVLW  0A
4EEE:  CALL   1F4C
....................                delay_ms(10); 
4EF2:  MOVLW  0A
4EF4:  MOVLB  8
4EF6:  MOVWF  x79
4EF8:  MOVLB  0
4EFA:  CALL   0772
....................                 
....................                SendSMS.B4 =1; 
4EFE:  MOVLB  7
4F00:  BSF    xE8.3
....................                printf("AT+CMGS=\""); 
4F02:  MOVLW  5A
4F04:  MOVWF  FF6
4F06:  MOVLW  06
4F08:  MOVWF  FF7
4F0A:  MOVLB  0
4F0C:  CALL   1F28
....................                printf(sms_phonenumber); 
4F10:  MOVLW  06
4F12:  MOVWF  FEA
4F14:  MOVLW  83
4F16:  MOVWF  FE9
4F18:  CALL   448A
....................              
....................                printf("\""); 
4F1C:  MOVLW  22
4F1E:  CLRWDT
4F20:  BTFSS  F9E.4
4F22:  BRA    4F1E
4F24:  MOVWF  FAD
....................                putc('\n'); 
4F26:  MOVLW  0A
4F28:  CALL   1F4C
....................                delay_ms(50); 
4F2C:  MOVLW  32
4F2E:  MOVLB  8
4F30:  MOVWF  x79
4F32:  MOVLB  0
4F34:  CALL   0772
....................                
....................               printf(SMS_Massage4); 
4F38:  MOVLW  07
4F3A:  MOVWF  FEA
4F3C:  MOVLW  0D
4F3E:  MOVWF  FE9
4F40:  CALL   448A
....................               putc('\n'); 
4F44:  MOVLW  0A
4F46:  CALL   1F4C
....................               putc(26); 
4F4A:  MOVLW  1A
4F4C:  CALL   1F4C
4F50:  MOVLB  7
....................             } 
....................  
....................       } 
....................       else if(FaultType.B4 == 1) Ack.B4 = 0; 
4F52:  BRA    4F58
4F54:  BTFSC  xDD.3
4F56:  BCF    xE1.3
....................    } 
....................    else  //Indicator Function 
4F58:  BRA    5002
....................    { 
....................       if((Input.B4 ^ InputType.B4) == 1) 
4F5A:  MOVLW  00
4F5C:  BTFSC  xDA.3
4F5E:  MOVLW  01
4F60:  MOVLB  8
4F62:  MOVWF  x78
4F64:  MOVLW  00
4F66:  MOVLB  7
4F68:  BTFSC  xDC.3
4F6A:  MOVLW  01
4F6C:  MOVLB  8
4F6E:  XORWF  x78,W
4F70:  SUBLW  01
4F72:  BNZ   4FFC
....................       { 
....................          Output.B4 = 0; 
4F74:  MOVLB  7
4F76:  BCF    xDB.3
....................           
....................          // SMS Sending    
....................          if((SendSMS.B4 ==0)&& (functointest_f ==0) && (Ack.B4 ==0)) 
4F78:  BTFSC  xE8.3
4F7A:  BRA    4FF8
4F7C:  BTFSC  2D.1
4F7E:  BRA    4FF8
4F80:  BTFSC  xE1.3
4F82:  BRA    4FF8
....................          { 
....................             printf("AT+CMGF=1");  
4F84:  MOVLW  64
4F86:  MOVWF  FF6
4F88:  MOVLW  06
4F8A:  MOVWF  FF7
4F8C:  MOVLB  0
4F8E:  CALL   1F28
....................             putc('\n'); 
4F92:  MOVLW  0A
4F94:  CALL   1F4C
....................             delay_ms(10); 
4F98:  MOVLW  0A
4F9A:  MOVLB  8
4F9C:  MOVWF  x79
4F9E:  MOVLB  0
4FA0:  CALL   0772
....................              
....................             SendSMS.B4 =1; 
4FA4:  MOVLB  7
4FA6:  BSF    xE8.3
....................             printf("AT+CMGS=\""); 
4FA8:  MOVLW  6E
4FAA:  MOVWF  FF6
4FAC:  MOVLW  06
4FAE:  MOVWF  FF7
4FB0:  MOVLB  0
4FB2:  CALL   1F28
....................             printf(sms_phonenumber); 
4FB6:  MOVLW  06
4FB8:  MOVWF  FEA
4FBA:  MOVLW  83
4FBC:  MOVWF  FE9
4FBE:  CALL   448A
....................           
....................             printf("\""); 
4FC2:  MOVLW  22
4FC4:  CLRWDT
4FC6:  BTFSS  F9E.4
4FC8:  BRA    4FC4
4FCA:  MOVWF  FAD
....................             putc('\n'); 
4FCC:  MOVLW  0A
4FCE:  CALL   1F4C
....................             delay_ms(50); 
4FD2:  MOVLW  32
4FD4:  MOVLB  8
4FD6:  MOVWF  x79
4FD8:  MOVLB  0
4FDA:  CALL   0772
....................             
....................            printf(SMS_Massage4); 
4FDE:  MOVLW  07
4FE0:  MOVWF  FEA
4FE2:  MOVLW  0D
4FE4:  MOVWF  FE9
4FE6:  CALL   448A
....................            putc('\n'); 
4FEA:  MOVLW  0A
4FEC:  CALL   1F4C
....................            putc(26); 
4FF0:  MOVLW  1A
4FF2:  CALL   1F4C
4FF6:  MOVLB  7
....................          } 
....................       } 
....................       else 
4FF8:  BRA    5002
4FFA:  MOVLB  8
....................       { 
....................          Output.B4 = 1; 
4FFC:  MOVLB  7
4FFE:  BSF    xDB.3
....................          SendSMS.B4 =0; 
5000:  BCF    xE8.3
....................       } 
....................    } 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input5 
....................    if(AlarmIndicator.B5 == 1)    // Alarm Function 
5002:  BTFSS  xE0.4
5004:  BRA    50F6
....................    { 
....................       if((((Input.B5 ^ InputType.B5) == 1) && (FaultType.B5 == 1))|| In.B5 == 1)    // alarm1 occure and "Lock type" 
5006:  MOVLW  00
5008:  BTFSC  xDA.4
500A:  MOVLW  01
500C:  MOVLB  8
500E:  MOVWF  x78
5010:  MOVLW  00
5012:  MOVLB  7
5014:  BTFSC  xDC.4
5016:  MOVLW  01
5018:  MOVLB  8
501A:  XORWF  x78,W
501C:  SUBLW  01
501E:  BNZ   5026
5020:  MOVLB  7
5022:  BTFSC  xDD.4
5024:  BRA    502C
5026:  MOVLB  7
5028:  BTFSS  xE2.4
502A:  BRA    50F0
....................       //if(Input.B5 == 0) 
....................       { 
....................          if(Ack.B5 == 0) 
502C:  BTFSC  xE1.4
502E:  BRA    506E
....................          { 
....................             if(In.B5 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
5030:  BTFSC  xE2.4
5032:  BRA    5042
5034:  MOVF   67,W
5036:  SUBLW  0F
5038:  BNZ   5042
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
503A:  MOVLW  64
503C:  MOVWF  19
....................                AutoAckDelayTime = AutoAckTime ; 
503E:  MOVFF  68,1A
....................             } 
....................  
....................             In.B5 = 1;                                 // setbit in1 
5042:  BSF    xE2.4
....................             if(FlashingFlag == 0) 
5044:  BTFSC  17.1
5046:  BRA    504C
....................             { 
....................                Output.B5 = 0;           //Flash output1 
5048:  BCF    xDB.4
....................             } 
....................             else 
504A:  BRA    504E
....................             { 
....................                Output.B5 = 1; 
504C:  BSF    xDB.4
....................             } 
....................  
....................             if (~AutoTestFlag) 
504E:  BTFSC  17.4
5050:  BRA    506E
....................             { 
....................                 
....................                if(OutputBoth.B5 == 0)                  //Both output 
5052:  BTFSC  xDF.4
5054:  BRA    5060
....................                { 
....................                   output_bit(Pbuzzer,0);   //Buzzer 
5056:  BCF    F89.4
5058:  BCF    F92.4
....................                   output_bit(Pbell,0);     //Bell 
505A:  BCF    F89.3
505C:  BCF    F92.3
....................                } 
....................                else 
505E:  BRA    506E
....................                { 
....................                   if(OutputType.B5 == 1) output_bit(Pbuzzer,0);     //Buzzer 
5060:  BTFSS  xDE.4
5062:  BRA    506A
5064:  BCF    F89.4
5066:  BCF    F92.4
....................                   else output_bit(Pbell,0);                          //Bell 
5068:  BRA    506E
506A:  BCF    F89.3
506C:  BCF    F92.3
....................                } 
....................                 
....................             } 
....................           } 
....................            
....................           // SMS Sending    
....................             if((SendSMS.B5 ==0)&& (functointest_f ==0) && (Ack.B5 ==0)) 
506E:  BTFSC  xE8.4
5070:  BRA    50EE
5072:  BTFSC  2D.1
5074:  BRA    50EE
5076:  BTFSC  xE1.4
5078:  BRA    50EE
....................             { 
....................                printf("AT+CMGF=1");  
507A:  MOVLW  78
507C:  MOVWF  FF6
507E:  MOVLW  06
5080:  MOVWF  FF7
5082:  MOVLB  0
5084:  CALL   1F28
....................                putc('\n'); 
5088:  MOVLW  0A
508A:  CALL   1F4C
....................                delay_ms(10); 
508E:  MOVLW  0A
5090:  MOVLB  8
5092:  MOVWF  x79
5094:  MOVLB  0
5096:  CALL   0772
....................                 
....................                SendSMS.B5 =1; 
509A:  MOVLB  7
509C:  BSF    xE8.4
....................                printf("AT+CMGS=\""); 
509E:  MOVLW  82
50A0:  MOVWF  FF6
50A2:  MOVLW  06
50A4:  MOVWF  FF7
50A6:  MOVLB  0
50A8:  CALL   1F28
....................                printf(sms_phonenumber); 
50AC:  MOVLW  06
50AE:  MOVWF  FEA
50B0:  MOVLW  83
50B2:  MOVWF  FE9
50B4:  CALL   448A
....................                 
....................                printf("\""); 
50B8:  MOVLW  22
50BA:  CLRWDT
50BC:  BTFSS  F9E.4
50BE:  BRA    50BA
50C0:  MOVWF  FAD
....................                putc('\n'); 
50C2:  MOVLW  0A
50C4:  CALL   1F4C
....................                delay_ms(50); 
50C8:  MOVLW  32
50CA:  MOVLB  8
50CC:  MOVWF  x79
50CE:  MOVLB  0
50D0:  CALL   0772
....................                
....................               printf(SMS_Massage5); 
50D4:  MOVLW  07
50D6:  MOVWF  FEA
50D8:  MOVLW  36
50DA:  MOVWF  FE9
50DC:  CALL   448A
....................               putc('\n'); 
50E0:  MOVLW  0A
50E2:  CALL   1F4C
....................               putc(26); 
50E6:  MOVLW  1A
50E8:  CALL   1F4C
50EC:  MOVLB  7
....................             } 
....................  
....................       } 
....................       else if(FaultType.B5 == 1) Ack.B5 = 0; 
50EE:  BRA    50F4
50F0:  BTFSC  xDD.4
50F2:  BCF    xE1.4
....................    } 
....................    else  //Indicator Function 
50F4:  BRA    519E
....................    { 
....................       if((Input.B5 ^ InputType.B5) == 1) 
50F6:  MOVLW  00
50F8:  BTFSC  xDA.4
50FA:  MOVLW  01
50FC:  MOVLB  8
50FE:  MOVWF  x78
5100:  MOVLW  00
5102:  MOVLB  7
5104:  BTFSC  xDC.4
5106:  MOVLW  01
5108:  MOVLB  8
510A:  XORWF  x78,W
510C:  SUBLW  01
510E:  BNZ   5198
....................       { 
....................          Output.B5 = 0; 
5110:  MOVLB  7
5112:  BCF    xDB.4
....................          // SMS Sending    
....................          if((SendSMS.B5 ==0)&& (functointest_f ==0) && (Ack.B5 ==0)) 
5114:  BTFSC  xE8.4
5116:  BRA    5194
5118:  BTFSC  2D.1
511A:  BRA    5194
511C:  BTFSC  xE1.4
511E:  BRA    5194
....................          { 
....................             printf("AT+CMGF=1");  
5120:  MOVLW  8C
5122:  MOVWF  FF6
5124:  MOVLW  06
5126:  MOVWF  FF7
5128:  MOVLB  0
512A:  CALL   1F28
....................             putc('\n'); 
512E:  MOVLW  0A
5130:  CALL   1F4C
....................             delay_ms(10); 
5134:  MOVLW  0A
5136:  MOVLB  8
5138:  MOVWF  x79
513A:  MOVLB  0
513C:  CALL   0772
....................              
....................             SendSMS.B5 =1; 
5140:  MOVLB  7
5142:  BSF    xE8.4
....................             printf("AT+CMGS=\""); 
5144:  MOVLW  96
5146:  MOVWF  FF6
5148:  MOVLW  06
514A:  MOVWF  FF7
514C:  MOVLB  0
514E:  CALL   1F28
....................             printf(sms_phonenumber); 
5152:  MOVLW  06
5154:  MOVWF  FEA
5156:  MOVLW  83
5158:  MOVWF  FE9
515A:  CALL   448A
....................              
....................             printf("\""); 
515E:  MOVLW  22
5160:  CLRWDT
5162:  BTFSS  F9E.4
5164:  BRA    5160
5166:  MOVWF  FAD
....................             putc('\n'); 
5168:  MOVLW  0A
516A:  CALL   1F4C
....................             delay_ms(50); 
516E:  MOVLW  32
5170:  MOVLB  8
5172:  MOVWF  x79
5174:  MOVLB  0
5176:  CALL   0772
....................             
....................            printf(SMS_Massage5);   
517A:  MOVLW  07
517C:  MOVWF  FEA
517E:  MOVLW  36
5180:  MOVWF  FE9
5182:  CALL   448A
....................            putc('\n'); 
5186:  MOVLW  0A
5188:  CALL   1F4C
....................            putc(26); 
518C:  MOVLW  1A
518E:  CALL   1F4C
5192:  MOVLB  7
....................          } 
....................       } 
....................       else 
5194:  BRA    519E
5196:  MOVLB  8
....................       { 
....................          Output.B5 = 1; 
5198:  MOVLB  7
519A:  BSF    xDB.4
....................          SendSMS.B5 =0; 
519C:  BCF    xE8.4
....................       } 
....................    } 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input6 
....................    if(AlarmIndicator.B6 == 1)    // Alarm Function 
519E:  BTFSS  xE0.5
51A0:  BRA    5292
....................    { 
....................       if((((Input.B6 ^ InputType.B6) == 1) && (FaultType.B6 == 1))|| In.B6 == 1)    // alarm1 occure and "Lock type" 
51A2:  MOVLW  00
51A4:  BTFSC  xDA.5
51A6:  MOVLW  01
51A8:  MOVLB  8
51AA:  MOVWF  x78
51AC:  MOVLW  00
51AE:  MOVLB  7
51B0:  BTFSC  xDC.5
51B2:  MOVLW  01
51B4:  MOVLB  8
51B6:  XORWF  x78,W
51B8:  SUBLW  01
51BA:  BNZ   51C2
51BC:  MOVLB  7
51BE:  BTFSC  xDD.5
51C0:  BRA    51C8
51C2:  MOVLB  7
51C4:  BTFSS  xE2.5
51C6:  BRA    528C
....................       //if(Input.B6 == 0) 
....................       { 
....................          if(Ack.B6 == 0) 
51C8:  BTFSC  xE1.5
51CA:  BRA    520A
....................          { 
....................             if(In.B6 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
51CC:  BTFSC  xE2.5
51CE:  BRA    51DE
51D0:  MOVF   67,W
51D2:  SUBLW  0F
51D4:  BNZ   51DE
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
51D6:  MOVLW  64
51D8:  MOVWF  19
....................                AutoAckDelayTime = AutoAckTime ; 
51DA:  MOVFF  68,1A
....................             } 
....................  
....................             In.B6 = 1;                                 // setbit in1 
51DE:  BSF    xE2.5
....................             if(FlashingFlag == 0) 
51E0:  BTFSC  17.1
51E2:  BRA    51E8
....................             { 
....................                Output.B6 = 0;           //Flash output1 
51E4:  BCF    xDB.5
....................             } 
....................             else 
51E6:  BRA    51EA
....................             { 
....................                Output.B6 = 1; 
51E8:  BSF    xDB.5
....................             } 
....................  
....................             if (~AutoTestFlag) 
51EA:  BTFSC  17.4
51EC:  BRA    520A
....................             { 
....................                 
....................                if(OutputBoth.B6 == 0)                  //Both output 
51EE:  BTFSC  xDF.5
51F0:  BRA    51FC
....................                { 
....................                   output_bit(Pbuzzer,0);   //Buzzer 
51F2:  BCF    F89.4
51F4:  BCF    F92.4
....................                   output_bit(Pbell,0);     //Bell 
51F6:  BCF    F89.3
51F8:  BCF    F92.3
....................                } 
....................                else 
51FA:  BRA    520A
....................                { 
....................                   if(OutputType.B6 == 1) output_bit(Pbuzzer,0);     //Buzzer 
51FC:  BTFSS  xDE.5
51FE:  BRA    5206
5200:  BCF    F89.4
5202:  BCF    F92.4
....................                   else output_bit(Pbell,0);                          //Bell 
5204:  BRA    520A
5206:  BCF    F89.3
5208:  BCF    F92.3
....................                } 
....................                 
....................             } 
....................           } 
....................            
....................           // SMS Sending    
....................             if((SendSMS.B6 ==0)&& (functointest_f ==0) && (Ack.B6 ==0)) 
520A:  BTFSC  xE8.5
520C:  BRA    528A
520E:  BTFSC  2D.1
5210:  BRA    528A
5212:  BTFSC  xE1.5
5214:  BRA    528A
....................             { 
....................                printf("AT+CMGF=1");  
5216:  MOVLW  A0
5218:  MOVWF  FF6
521A:  MOVLW  06
521C:  MOVWF  FF7
521E:  MOVLB  0
5220:  CALL   1F28
....................                putc('\n'); 
5224:  MOVLW  0A
5226:  CALL   1F4C
....................                delay_ms(10); 
522A:  MOVLW  0A
522C:  MOVLB  8
522E:  MOVWF  x79
5230:  MOVLB  0
5232:  CALL   0772
....................                 
....................                SendSMS.B6 =1; 
5236:  MOVLB  7
5238:  BSF    xE8.5
....................                printf("AT+CMGS=\""); 
523A:  MOVLW  AA
523C:  MOVWF  FF6
523E:  MOVLW  06
5240:  MOVWF  FF7
5242:  MOVLB  0
5244:  CALL   1F28
....................                printf(sms_phonenumber); 
5248:  MOVLW  06
524A:  MOVWF  FEA
524C:  MOVLW  83
524E:  MOVWF  FE9
5250:  CALL   448A
....................                 
....................                printf("\""); 
5254:  MOVLW  22
5256:  CLRWDT
5258:  BTFSS  F9E.4
525A:  BRA    5256
525C:  MOVWF  FAD
....................                putc('\n'); 
525E:  MOVLW  0A
5260:  CALL   1F4C
....................                delay_ms(50); 
5264:  MOVLW  32
5266:  MOVLB  8
5268:  MOVWF  x79
526A:  MOVLB  0
526C:  CALL   0772
....................                
....................               printf(SMS_Massage6); 
5270:  MOVLW  07
5272:  MOVWF  FEA
5274:  MOVLW  5F
5276:  MOVWF  FE9
5278:  CALL   448A
....................               putc('\n'); 
527C:  MOVLW  0A
527E:  CALL   1F4C
....................               putc(26); 
5282:  MOVLW  1A
5284:  CALL   1F4C
5288:  MOVLB  7
....................             } 
....................  
....................       } 
....................       else if(FaultType.B6 == 1) Ack.B6 = 0; 
528A:  BRA    5290
528C:  BTFSC  xDD.5
528E:  BCF    xE1.5
....................    } 
....................    else  //Indicator Function 
5290:  BRA    533A
....................    { 
....................       if((Input.B6 ^ InputType.B6) == 1) 
5292:  MOVLW  00
5294:  BTFSC  xDA.5
5296:  MOVLW  01
5298:  MOVLB  8
529A:  MOVWF  x78
529C:  MOVLW  00
529E:  MOVLB  7
52A0:  BTFSC  xDC.5
52A2:  MOVLW  01
52A4:  MOVLB  8
52A6:  XORWF  x78,W
52A8:  SUBLW  01
52AA:  BNZ   5334
....................       { 
....................          Output.B6 = 0; 
52AC:  MOVLB  7
52AE:  BCF    xDB.5
....................          // SMS Sending    
....................          if((SendSMS.B6 ==0)&& (functointest_f ==0) && (Ack.B6 ==0)) 
52B0:  BTFSC  xE8.5
52B2:  BRA    5330
52B4:  BTFSC  2D.1
52B6:  BRA    5330
52B8:  BTFSC  xE1.5
52BA:  BRA    5330
....................          { 
....................             printf("AT+CMGF=1");  
52BC:  MOVLW  B4
52BE:  MOVWF  FF6
52C0:  MOVLW  06
52C2:  MOVWF  FF7
52C4:  MOVLB  0
52C6:  CALL   1F28
....................             putc('\n'); 
52CA:  MOVLW  0A
52CC:  CALL   1F4C
....................             delay_ms(10); 
52D0:  MOVLW  0A
52D2:  MOVLB  8
52D4:  MOVWF  x79
52D6:  MOVLB  0
52D8:  CALL   0772
....................              
....................             SendSMS.B6 =1; 
52DC:  MOVLB  7
52DE:  BSF    xE8.5
....................             printf("AT+CMGS=\""); 
52E0:  MOVLW  BE
52E2:  MOVWF  FF6
52E4:  MOVLW  06
52E6:  MOVWF  FF7
52E8:  MOVLB  0
52EA:  CALL   1F28
....................             printf(sms_phonenumber); 
52EE:  MOVLW  06
52F0:  MOVWF  FEA
52F2:  MOVLW  83
52F4:  MOVWF  FE9
52F6:  CALL   448A
....................              
....................             printf("\""); 
52FA:  MOVLW  22
52FC:  CLRWDT
52FE:  BTFSS  F9E.4
5300:  BRA    52FC
5302:  MOVWF  FAD
....................             putc('\n'); 
5304:  MOVLW  0A
5306:  CALL   1F4C
....................             delay_ms(50); 
530A:  MOVLW  32
530C:  MOVLB  8
530E:  MOVWF  x79
5310:  MOVLB  0
5312:  CALL   0772
....................             
....................            printf(SMS_Massage6);   
5316:  MOVLW  07
5318:  MOVWF  FEA
531A:  MOVLW  5F
531C:  MOVWF  FE9
531E:  CALL   448A
....................            putc('\n'); 
5322:  MOVLW  0A
5324:  CALL   1F4C
....................            putc(26); 
5328:  MOVLW  1A
532A:  CALL   1F4C
532E:  MOVLB  7
....................          } 
....................       } 
....................       else 
5330:  BRA    533A
5332:  MOVLB  8
....................       { 
....................          Output.B6 = 1; 
5334:  MOVLB  7
5336:  BSF    xDB.5
....................          SendSMS.B6 =0; 
5338:  BCF    xE8.5
....................       } 
....................    } 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input7 
....................    if(AlarmIndicator.B7 == 1)    // Alarm Function 
533A:  BTFSS  xE0.6
533C:  BRA    542E
....................    { 
....................       if((((Input.B7 ^ InputType.B7) == 1) && (FaultType.B7 == 1))|| In.B7 == 1)    // alarm1 occure and "Lock type" 
533E:  MOVLW  00
5340:  BTFSC  xDA.6
5342:  MOVLW  01
5344:  MOVLB  8
5346:  MOVWF  x78
5348:  MOVLW  00
534A:  MOVLB  7
534C:  BTFSC  xDC.6
534E:  MOVLW  01
5350:  MOVLB  8
5352:  XORWF  x78,W
5354:  SUBLW  01
5356:  BNZ   535E
5358:  MOVLB  7
535A:  BTFSC  xDD.6
535C:  BRA    5364
535E:  MOVLB  7
5360:  BTFSS  xE2.6
5362:  BRA    5428
....................       //if(Input.B7 == 0) 
....................       { 
....................          if(Ack.B7 == 0) 
5364:  BTFSC  xE1.6
5366:  BRA    53A6
....................          { 
....................             if(In.B7 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
5368:  BTFSC  xE2.6
536A:  BRA    537A
536C:  MOVF   67,W
536E:  SUBLW  0F
5370:  BNZ   537A
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
5372:  MOVLW  64
5374:  MOVWF  19
....................                AutoAckDelayTime = AutoAckTime ; 
5376:  MOVFF  68,1A
....................             } 
....................  
....................             In.B7 = 1;                                 // setbit in1 
537A:  BSF    xE2.6
....................             if(FlashingFlag == 0) 
537C:  BTFSC  17.1
537E:  BRA    5384
....................             { 
....................                Output.B7 = 0;           //Flash output1 
5380:  BCF    xDB.6
....................             } 
....................             else 
5382:  BRA    5386
....................             { 
....................                Output.B7 = 1; 
5384:  BSF    xDB.6
....................             } 
....................  
....................             if (~AutoTestFlag) 
5386:  BTFSC  17.4
5388:  BRA    53A6
....................             { 
....................                 
....................                if(OutputBoth.B7 == 0)                  //Both output 
538A:  BTFSC  xDF.6
538C:  BRA    5398
....................                { 
....................                   output_bit(Pbuzzer,0);   //Buzzer 
538E:  BCF    F89.4
5390:  BCF    F92.4
....................                   output_bit(Pbell,0);     //Bell 
5392:  BCF    F89.3
5394:  BCF    F92.3
....................                } 
....................                else 
5396:  BRA    53A6
....................                { 
....................                   if(OutputType.B7 == 1) output_bit(Pbuzzer,0);     //Buzzer 
5398:  BTFSS  xDE.6
539A:  BRA    53A2
539C:  BCF    F89.4
539E:  BCF    F92.4
....................                   else output_bit(Pbell,0);                          //Bell 
53A0:  BRA    53A6
53A2:  BCF    F89.3
53A4:  BCF    F92.3
....................                } 
....................                 
....................             } 
....................           } 
....................            
....................           // SMS Sending    
....................             if((SendSMS.B7 ==0)&& (functointest_f ==0) && (Ack.B7 ==0)) 
53A6:  BTFSC  xE8.6
53A8:  BRA    5426
53AA:  BTFSC  2D.1
53AC:  BRA    5426
53AE:  BTFSC  xE1.6
53B0:  BRA    5426
....................             { 
....................                printf("AT+CMGF=1");  
53B2:  MOVLW  C8
53B4:  MOVWF  FF6
53B6:  MOVLW  06
53B8:  MOVWF  FF7
53BA:  MOVLB  0
53BC:  CALL   1F28
....................                putc('\n'); 
53C0:  MOVLW  0A
53C2:  CALL   1F4C
....................                delay_ms(10); 
53C6:  MOVLW  0A
53C8:  MOVLB  8
53CA:  MOVWF  x79
53CC:  MOVLB  0
53CE:  CALL   0772
....................                 
....................                SendSMS.B7 =1; 
53D2:  MOVLB  7
53D4:  BSF    xE8.6
....................                printf("AT+CMGS=\""); 
53D6:  MOVLW  D2
53D8:  MOVWF  FF6
53DA:  MOVLW  06
53DC:  MOVWF  FF7
53DE:  MOVLB  0
53E0:  CALL   1F28
....................                printf(sms_phonenumber); 
53E4:  MOVLW  06
53E6:  MOVWF  FEA
53E8:  MOVLW  83
53EA:  MOVWF  FE9
53EC:  CALL   448A
....................                 
....................                printf("\""); 
53F0:  MOVLW  22
53F2:  CLRWDT
53F4:  BTFSS  F9E.4
53F6:  BRA    53F2
53F8:  MOVWF  FAD
....................                putc('\n'); 
53FA:  MOVLW  0A
53FC:  CALL   1F4C
....................                delay_ms(50); 
5400:  MOVLW  32
5402:  MOVLB  8
5404:  MOVWF  x79
5406:  MOVLB  0
5408:  CALL   0772
....................                
....................               printf(SMS_Massage7);   
540C:  MOVLW  07
540E:  MOVWF  FEA
5410:  MOVLW  88
5412:  MOVWF  FE9
5414:  CALL   448A
....................               putc('\n'); 
5418:  MOVLW  0A
541A:  CALL   1F4C
....................               putc(26); 
541E:  MOVLW  1A
5420:  CALL   1F4C
5424:  MOVLB  7
....................             } 
....................  
....................       } 
....................       else if(FaultType.B7 == 1) Ack.B7 = 0; 
5426:  BRA    542C
5428:  BTFSC  xDD.6
542A:  BCF    xE1.6
....................    } 
....................    else  //Indicator Function 
542C:  BRA    54D6
....................    { 
....................       if((Input.B7 ^ InputType.B7) == 1) 
542E:  MOVLW  00
5430:  BTFSC  xDA.6
5432:  MOVLW  01
5434:  MOVLB  8
5436:  MOVWF  x78
5438:  MOVLW  00
543A:  MOVLB  7
543C:  BTFSC  xDC.6
543E:  MOVLW  01
5440:  MOVLB  8
5442:  XORWF  x78,W
5444:  SUBLW  01
5446:  BNZ   54D0
....................       { 
....................          Output.B7 = 0; 
5448:  MOVLB  7
544A:  BCF    xDB.6
....................          // SMS Sending    
....................          if((SendSMS.B7 ==0)&& (functointest_f ==0) && (Ack.B7 ==0)) 
544C:  BTFSC  xE8.6
544E:  BRA    54CC
5450:  BTFSC  2D.1
5452:  BRA    54CC
5454:  BTFSC  xE1.6
5456:  BRA    54CC
....................          { 
....................             printf("AT+CMGF=1");  
5458:  MOVLW  DC
545A:  MOVWF  FF6
545C:  MOVLW  06
545E:  MOVWF  FF7
5460:  MOVLB  0
5462:  CALL   1F28
....................             putc('\n'); 
5466:  MOVLW  0A
5468:  CALL   1F4C
....................             delay_ms(10); 
546C:  MOVLW  0A
546E:  MOVLB  8
5470:  MOVWF  x79
5472:  MOVLB  0
5474:  CALL   0772
....................              
....................             SendSMS.B7 =1; 
5478:  MOVLB  7
547A:  BSF    xE8.6
....................             printf("AT+CMGS=\""); 
547C:  MOVLW  E6
547E:  MOVWF  FF6
5480:  MOVLW  06
5482:  MOVWF  FF7
5484:  MOVLB  0
5486:  CALL   1F28
....................             printf(sms_phonenumber); 
548A:  MOVLW  06
548C:  MOVWF  FEA
548E:  MOVLW  83
5490:  MOVWF  FE9
5492:  CALL   448A
....................              
....................             printf("\""); 
5496:  MOVLW  22
5498:  CLRWDT
549A:  BTFSS  F9E.4
549C:  BRA    5498
549E:  MOVWF  FAD
....................             putc('\n'); 
54A0:  MOVLW  0A
54A2:  CALL   1F4C
....................             delay_ms(50); 
54A6:  MOVLW  32
54A8:  MOVLB  8
54AA:  MOVWF  x79
54AC:  MOVLB  0
54AE:  CALL   0772
....................             
....................            printf(SMS_Massage7);  
54B2:  MOVLW  07
54B4:  MOVWF  FEA
54B6:  MOVLW  88
54B8:  MOVWF  FE9
54BA:  CALL   448A
....................            putc('\n'); 
54BE:  MOVLW  0A
54C0:  CALL   1F4C
....................            putc(26); 
54C4:  MOVLW  1A
54C6:  CALL   1F4C
54CA:  MOVLB  7
....................          } 
....................       } 
....................       else 
54CC:  BRA    54D6
54CE:  MOVLB  8
....................       { 
....................          Output.B7 = 1; 
54D0:  MOVLB  7
54D2:  BSF    xDB.6
....................          SendSMS.B7 =0; 
54D4:  BCF    xE8.6
....................       } 
....................    } 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... //input8 
....................    if(AlarmIndicator.B8 == 1)    // Alarm Function 
54D6:  BTFSS  xE0.7
54D8:  BRA    55CA
....................    { 
....................       if((((Input.B8 ^ InputType.B8) == 1) && (FaultType.B8 == 1))|| In.B8 == 1)    // alarm1 occure and "Lock type" 
54DA:  MOVLW  00
54DC:  BTFSC  xDA.7
54DE:  MOVLW  01
54E0:  MOVLB  8
54E2:  MOVWF  x78
54E4:  MOVLW  00
54E6:  MOVLB  7
54E8:  BTFSC  xDC.7
54EA:  MOVLW  01
54EC:  MOVLB  8
54EE:  XORWF  x78,W
54F0:  SUBLW  01
54F2:  BNZ   54FA
54F4:  MOVLB  7
54F6:  BTFSC  xDD.7
54F8:  BRA    5500
54FA:  MOVLB  7
54FC:  BTFSS  xE2.7
54FE:  BRA    55C4
....................       //if(Input.B8 == 0) 
....................       { 
....................          if(Ack.B8 == 0) 
5500:  BTFSC  xE1.7
5502:  BRA    5542
....................          { 
....................             if(In.B8 == 0 && AutoAck == 0x0F)   //use auto acknowlegde 
5504:  BTFSC  xE2.7
5506:  BRA    5516
5508:  MOVF   67,W
550A:  SUBLW  0F
550C:  BNZ   5516
....................             { 
....................                TimeBase1s = 100 ;            //reload again 
550E:  MOVLW  64
5510:  MOVWF  19
....................                AutoAckDelayTime = AutoAckTime ; 
5512:  MOVFF  68,1A
....................             } 
....................  
....................             In.B8 = 1;                                 // setbit in1 
5516:  BSF    xE2.7
....................             if(FlashingFlag == 0) 
5518:  BTFSC  17.1
551A:  BRA    5520
....................             { 
....................                Output.B8 = 0;           //Flash output1 
551C:  BCF    xDB.7
....................             } 
....................             else 
551E:  BRA    5522
....................             { 
....................                Output.B8 = 1; 
5520:  BSF    xDB.7
....................             } 
....................  
....................             if (~AutoTestFlag) 
5522:  BTFSC  17.4
5524:  BRA    5542
....................             { 
....................                 
....................                if(OutputBoth.B8 == 0)                  //Both output 
5526:  BTFSC  xDF.7
5528:  BRA    5534
....................                { 
....................                   output_bit(Pbuzzer,0);   //Buzzer 
552A:  BCF    F89.4
552C:  BCF    F92.4
....................                   output_bit(Pbell,0);     //Bell 
552E:  BCF    F89.3
5530:  BCF    F92.3
....................                } 
....................                else 
5532:  BRA    5542
....................                { 
....................                   if(OutputType.B8 == 1) output_bit(Pbuzzer,0);     //Buzzer 
5534:  BTFSS  xDE.7
5536:  BRA    553E
5538:  BCF    F89.4
553A:  BCF    F92.4
....................                   else output_bit(Pbell,0);                          //Bell 
553C:  BRA    5542
553E:  BCF    F89.3
5540:  BCF    F92.3
....................                } 
....................                 
....................             } 
....................        } 
....................         
....................        // SMS Sending    
....................             if((SendSMS.B8 ==0)&& (functointest_f ==0) && (Ack.B8 ==0)) 
5542:  BTFSC  xE8.7
5544:  BRA    55C2
5546:  BTFSC  2D.1
5548:  BRA    55C2
554A:  BTFSC  xE1.7
554C:  BRA    55C2
....................             { 
....................                printf("AT+CMGF=1");  
554E:  MOVLW  F0
5550:  MOVWF  FF6
5552:  MOVLW  06
5554:  MOVWF  FF7
5556:  MOVLB  0
5558:  CALL   1F28
....................                putc('\n'); 
555C:  MOVLW  0A
555E:  CALL   1F4C
....................                delay_ms(10); 
5562:  MOVLW  0A
5564:  MOVLB  8
5566:  MOVWF  x79
5568:  MOVLB  0
556A:  CALL   0772
....................                 
....................                SendSMS.B8 =1; 
556E:  MOVLB  7
5570:  BSF    xE8.7
....................                printf("AT+CMGS=\""); 
5572:  MOVLW  FA
5574:  MOVWF  FF6
5576:  MOVLW  06
5578:  MOVWF  FF7
557A:  MOVLB  0
557C:  CALL   1F28
....................                printf(sms_phonenumber); 
5580:  MOVLW  06
5582:  MOVWF  FEA
5584:  MOVLW  83
5586:  MOVWF  FE9
5588:  CALL   448A
....................                 
....................                printf("\""); 
558C:  MOVLW  22
558E:  CLRWDT
5590:  BTFSS  F9E.4
5592:  BRA    558E
5594:  MOVWF  FAD
....................                putc('\n'); 
5596:  MOVLW  0A
5598:  CALL   1F4C
....................                delay_ms(50); 
559C:  MOVLW  32
559E:  MOVLB  8
55A0:  MOVWF  x79
55A2:  MOVLB  0
55A4:  CALL   0772
....................                
....................               printf(SMS_Massage8);   
55A8:  MOVLW  07
55AA:  MOVWF  FEA
55AC:  MOVLW  B1
55AE:  MOVWF  FE9
55B0:  CALL   448A
....................               putc('\n'); 
55B4:  MOVLW  0A
55B6:  CALL   1F4C
....................               putc(26); 
55BA:  MOVLW  1A
55BC:  CALL   1F4C
55C0:  MOVLB  7
....................             } 
....................  
....................       } 
....................       else if(FaultType.B8 == 1) Ack.B8 = 0; 
55C2:  BRA    55C8
55C4:  BTFSC  xDD.7
55C6:  BCF    xE1.7
....................    } 
....................    else  //Indicator Function 
55C8:  BRA    5672
....................    { 
....................       if((Input.B8 ^ InputType.B8) == 1) 
55CA:  MOVLW  00
55CC:  BTFSC  xDA.7
55CE:  MOVLW  01
55D0:  MOVLB  8
55D2:  MOVWF  x78
55D4:  MOVLW  00
55D6:  MOVLB  7
55D8:  BTFSC  xDC.7
55DA:  MOVLW  01
55DC:  MOVLB  8
55DE:  XORWF  x78,W
55E0:  SUBLW  01
55E2:  BNZ   566C
....................       { 
....................          Output.B8 = 0; 
55E4:  MOVLB  7
55E6:  BCF    xDB.7
....................          // SMS Sending    
....................          if((SendSMS.B8 ==0)&& (functointest_f ==0) && (Ack.B8 ==0)) 
55E8:  BTFSC  xE8.7
55EA:  BRA    5668
55EC:  BTFSC  2D.1
55EE:  BRA    5668
55F0:  BTFSC  xE1.7
55F2:  BRA    5668
....................          { 
....................             printf("AT+CMGF=1");  
55F4:  MOVLW  04
55F6:  MOVWF  FF6
55F8:  MOVLW  07
55FA:  MOVWF  FF7
55FC:  MOVLB  0
55FE:  CALL   1F28
....................             putc('\n'); 
5602:  MOVLW  0A
5604:  CALL   1F4C
....................             delay_ms(10); 
5608:  MOVLW  0A
560A:  MOVLB  8
560C:  MOVWF  x79
560E:  MOVLB  0
5610:  CALL   0772
....................              
....................             SendSMS.B8 =1; 
5614:  MOVLB  7
5616:  BSF    xE8.7
....................             printf("AT+CMGS=\""); 
5618:  MOVLW  0E
561A:  MOVWF  FF6
561C:  MOVLW  07
561E:  MOVWF  FF7
5620:  MOVLB  0
5622:  CALL   1F28
....................             printf(sms_phonenumber); 
5626:  MOVLW  06
5628:  MOVWF  FEA
562A:  MOVLW  83
562C:  MOVWF  FE9
562E:  CALL   448A
....................              
....................             printf("\""); 
5632:  MOVLW  22
5634:  CLRWDT
5636:  BTFSS  F9E.4
5638:  BRA    5634
563A:  MOVWF  FAD
....................             putc('\n'); 
563C:  MOVLW  0A
563E:  CALL   1F4C
....................             delay_ms(50); 
5642:  MOVLW  32
5644:  MOVLB  8
5646:  MOVWF  x79
5648:  MOVLB  0
564A:  CALL   0772
....................             
....................            printf(SMS_Massage8);   
564E:  MOVLW  07
5650:  MOVWF  FEA
5652:  MOVLW  B1
5654:  MOVWF  FE9
5656:  CALL   448A
....................            putc('\n'); 
565A:  MOVLW  0A
565C:  CALL   1F4C
....................            putc(26); 
5660:  MOVLW  1A
5662:  CALL   1F4C
5666:  MOVLB  7
....................          } 
....................       } 
....................       else 
5668:  BRA    5672
566A:  MOVLB  8
....................       { 
....................          Output.B8 = 1; 
566C:  MOVLB  7
566E:  BSF    xDB.7
....................          SendSMS.B8 =0; 
5670:  BCF    xE8.7
....................       } 
....................    } 
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////////////// 
.................... /////////////////////////// END MANUAL RESET ////////////////////////////////////////// 
....................  
....................  
....................    ///////////////////////////////////////////////////////////////////////////// 
....................    ////////////////////////////// AUTO RESET /////////////////////////////////// 
....................    ///////////////////////////////////////////////////////////////////////////// 
....................  
.................... //if(NoOfPoint >= 10) 
.................... //{ 
....................  
....................  
.................... static unsigned char inputflag = 0; 
....................  
.................... //input1 
....................    if((((Input.B1 ^ InputType.B1) == 1) && (FaultType.B1 == 0)) ||Test_fault==1)   // alarm1 occure and " Non Lock type" 
5672:  MOVLW  00
5674:  BTFSC  xDA.0
5676:  MOVLW  01
5678:  MOVLB  8
567A:  MOVWF  x78
567C:  MOVLW  00
567E:  MOVLB  7
5680:  BTFSC  xDC.0
5682:  MOVLW  01
5684:  MOVLB  8
5686:  XORWF  x78,W
5688:  SUBLW  01
568A:  BNZ   5694
568C:  MOVLB  7
568E:  BTFSS  xDD.0
5690:  BRA    569A
5692:  MOVLB  8
5694:  BTFSS  17.5
5696:  BRA    574C
5698:  MOVLB  7
....................    { 
....................       if(In2.B1 == 0 && AutoAck == 0x0F && Ack.B1 == 0)   //use auto acknowlegde 
569A:  BTFSC  xE3.0
569C:  BRA    56B0
569E:  MOVF   67,W
56A0:  SUBLW  0F
56A2:  BNZ   56B0
56A4:  BTFSC  xE1.0
56A6:  BRA    56B0
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
56A8:  MOVLW  64
56AA:  MOVWF  19
....................             AutoAckDelayTime = AutoAckTime ; 
56AC:  MOVFF  68,1A
....................       } 
....................  
....................       In2.B1 = 1; 
56B0:  BSF    xE3.0
....................       if(Ack.B1 == 0) 
56B2:  BTFSC  xE1.0
56B4:  BRA    56E4
....................       { 
....................          if(FlashingFlag == 0) 
56B6:  BTFSC  17.1
56B8:  BRA    56BE
....................             { 
....................                Output.B1 = 0;           //Flash output1 
56BA:  BCF    xDB.0
....................             } 
....................             else 
56BC:  BRA    56C0
....................             { 
....................                Output.B1 = 1; 
56BE:  BSF    xDB.0
....................             } 
....................          if(~AutoTestFlag) 
56C0:  BTFSC  17.4
56C2:  BRA    56E4
....................          { 
....................             if(AlarmIndicator.B1 == 1){ 
56C4:  BTFSS  xE0.0
56C6:  BRA    56E4
....................                 if(OutputBoth.B1 == 0)        //Both output 
56C8:  BTFSC  xDF.0
56CA:  BRA    56D6
....................                 { 
....................                   output_bit(Pbuzzer,0);   //Buzzer 
56CC:  BCF    F89.4
56CE:  BCF    F92.4
....................                   output_bit(Pbell,0);     //Bell 
56D0:  BCF    F89.3
56D2:  BCF    F92.3
....................                 } 
....................                 else 
56D4:  BRA    56E4
....................                 { 
....................                   if(OutputType.B1 == 1) output_bit(Pbuzzer,0);     //Buzzer 
56D6:  BTFSS  xDE.0
56D8:  BRA    56E0
56DA:  BCF    F89.4
56DC:  BCF    F92.4
....................                   else output_bit(Pbell,0);                          //Bell 
56DE:  BRA    56E4
56E0:  BCF    F89.3
56E2:  BCF    F92.3
....................                 } 
....................             } 
....................          } 
....................        } 
....................       inputflag =1; 
56E4:  MOVLW  01
56E6:  MOVLB  8
56E8:  MOVWF  x6C
....................        
....................       // SMS Sending    
....................       if((SendSMS.B1 ==0) && (functointest_f ==0) && (Ack.B1 ==0)) 
56EA:  MOVLB  7
56EC:  BTFSC  xE8.0
56EE:  BRA    574A
56F0:  BTFSC  2D.1
56F2:  BRA    574A
56F4:  BTFSC  xE1.0
56F6:  BRA    574A
....................       { 
....................          SendSMS.B1 =1; 
56F8:  BSF    xE8.0
....................          printf("AT+CMGS=\""); 
56FA:  MOVLW  18
56FC:  MOVWF  FF6
56FE:  MOVLW  07
5700:  MOVWF  FF7
5702:  MOVLB  0
5704:  CALL   1F28
....................          printf(sms_phonenumber); 
5708:  MOVLW  06
570A:  MOVWF  FEA
570C:  MOVLW  83
570E:  MOVWF  FE9
5710:  CALL   448A
....................           
....................          printf("\""); 
5714:  MOVLW  22
5716:  CLRWDT
5718:  BTFSS  F9E.4
571A:  BRA    5716
571C:  MOVWF  FAD
....................          putc('\n'); 
571E:  MOVLW  0A
5720:  CALL   1F4C
....................          delay_ms(50); 
5724:  MOVLW  32
5726:  MOVLB  8
5728:  MOVWF  x79
572A:  MOVLB  0
572C:  CALL   0772
....................          
....................         printf(SMS_Massage1);    
5730:  MOVLW  06
5732:  MOVWF  FEA
5734:  MOVLW  92
5736:  MOVWF  FE9
5738:  CALL   448A
....................         putc('\n'); 
573C:  MOVLW  0A
573E:  CALL   1F4C
....................         putc(26); 
5742:  MOVLW  1A
5744:  CALL   1F4C
5748:  MOVLB  7
....................       } 
....................    } 
....................    else if(FaultType.B1 == 0) 
574A:  BRA    57D6
574C:  MOVLB  7
574E:  BTFSC  xDD.0
5750:  BRA    57D6
....................    { 
....................       In2.B1 = 0; 
5752:  BCF    xE3.0
....................       Ack.B1 = 0; 
5754:  BCF    xE1.0
....................       Output.B1 = 1;      //Off LED 
5756:  BSF    xDB.0
....................        
....................       SendSMS.B1 =0;// Clear SMS 
5758:  BCF    xE8.0
....................  
....................       if((OutputType.B1 == 1 || OutputBoth.B1 == 0)&& inputflag ==0)      //If Buzzer or Both 
575A:  BTFSC  xDE.0
575C:  BRA    5762
575E:  BTFSC  xDF.0
5760:  BRA    5784
5762:  MOVLB  8
5764:  MOVF   x6C,F
5766:  BTFSC  FD8.2
5768:  BRA    576E
576A:  MOVLB  7
576C:  BRA    5784
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing 
576E:  MOVLW  01
5770:  MOVWF  x78
5772:  MOVLB  0
5774:  CALL   44B2
5778:  DECFSZ 01,W
577A:  BRA    577E
....................          else 
577C:  BRA    5782
....................          { 
....................             output_bit(Pbuzzer,1);   //Clear Buzzer 
577E:  BSF    F89.4
5780:  BCF    F92.4
5782:  MOVLB  7
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B1 == 0 || OutputBoth.B1 == 0)&& inputflag ==0)  //If Bell or Both 
5784:  BTFSS  xDE.0
5786:  BRA    578C
5788:  BTFSC  xDF.0
578A:  BRA    57AE
578C:  MOVLB  8
578E:  MOVF   x6C,F
5790:  BTFSC  FD8.2
5792:  BRA    5798
5794:  MOVLB  7
5796:  BRA    57AE
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
5798:  MOVLW  02
579A:  MOVWF  x78
579C:  MOVLB  0
579E:  CALL   44B2
57A2:  DECFSZ 01,W
57A4:  BRA    57A8
....................          else 
57A6:  BRA    57AC
....................          { 
....................             output_bit(Pbell,1);      //Clear Bell 
57A8:  BSF    F89.3
57AA:  BCF    F92.3
57AC:  MOVLB  7
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 ) 
57AE:  BTFSC  xE3.0
57B0:  BRA    57D6
57B2:  BTFSC  xE3.1
57B4:  BRA    57D6
57B6:  BTFSC  xE3.2
57B8:  BRA    57D6
57BA:  BTFSC  xE3.3
57BC:  BRA    57D6
57BE:  BTFSC  xE3.4
57C0:  BRA    57D6
57C2:  BTFSC  xE3.5
57C4:  BRA    57D6
57C6:  BTFSC  xE3.6
57C8:  BRA    57D6
57CA:  BTFSC  xE3.7
57CC:  BRA    57D6
....................       { 
....................          output_bit(Pbell,1);      //Clear Bell 
57CE:  BSF    F89.3
57D0:  BCF    F92.3
....................          output_bit(Pbuzzer,1);   //Clear Buzzer 
57D2:  BSF    F89.4
57D4:  BCF    F92.4
....................       } 
....................    } 
....................    //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //input2 
....................    if((((Input.B2 ^ InputType.B2) == 1) && (FaultType.B2 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type" 
57D6:  MOVLW  00
57D8:  BTFSC  xDA.1
57DA:  MOVLW  01
57DC:  MOVLB  8
57DE:  MOVWF  x78
57E0:  MOVLW  00
57E2:  MOVLB  7
57E4:  BTFSC  xDC.1
57E6:  MOVLW  01
57E8:  MOVLB  8
57EA:  XORWF  x78,W
57EC:  SUBLW  01
57EE:  BNZ   57F8
57F0:  MOVLB  7
57F2:  BTFSS  xDD.1
57F4:  BRA    57FE
57F6:  MOVLB  8
57F8:  BTFSS  17.5
57FA:  BRA    58B0
57FC:  MOVLB  7
....................    { 
....................       if(In2.B2 == 0 && AutoAck == 0x0F && Ack.B2 == 0)   //use auto acknowlegde 
57FE:  BTFSC  xE3.1
5800:  BRA    5814
5802:  MOVF   67,W
5804:  SUBLW  0F
5806:  BNZ   5814
5808:  BTFSC  xE1.1
580A:  BRA    5814
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
580C:  MOVLW  64
580E:  MOVWF  19
....................             AutoAckDelayTime = AutoAckTime ; 
5810:  MOVFF  68,1A
....................       } 
....................  
....................       In2.B2 = 1; 
5814:  BSF    xE3.1
....................       if(Ack.B2 == 0) 
5816:  BTFSC  xE1.1
5818:  BRA    5848
....................       { 
....................          if(FlashingFlag == 0) 
581A:  BTFSC  17.1
581C:  BRA    5822
....................             { 
....................                Output.B2 = 0;           //Flash output1 
581E:  BCF    xDB.1
....................             } 
....................             else 
5820:  BRA    5824
....................             { 
....................                Output.B2 = 1; 
5822:  BSF    xDB.1
....................             } 
....................          if (~AutoTestFlag) 
5824:  BTFSC  17.4
5826:  BRA    5848
....................          { 
....................            if(AlarmIndicator.B2 == 1){ 
5828:  BTFSS  xE0.1
582A:  BRA    5848
....................              if(OutputBoth.B2 == 0)        //Both output 
582C:  BTFSC  xDF.1
582E:  BRA    583A
....................              { 
....................                output_bit(Pbuzzer,0);   //Buzzer 
5830:  BCF    F89.4
5832:  BCF    F92.4
....................                output_bit(Pbell,0);     //Bell 
5834:  BCF    F89.3
5836:  BCF    F92.3
....................              } 
....................              else 
5838:  BRA    5848
....................              { 
....................                if(OutputType.B2 == 1) output_bit(Pbuzzer,0);     //Buzzer 
583A:  BTFSS  xDE.1
583C:  BRA    5844
583E:  BCF    F89.4
5840:  BCF    F92.4
....................                else output_bit(Pbell,0);                          //Bell 
5842:  BRA    5848
5844:  BCF    F89.3
5846:  BCF    F92.3
....................              } 
....................            } 
....................          } 
....................        } 
....................       inputflag =1; 
5848:  MOVLW  01
584A:  MOVLB  8
584C:  MOVWF  x6C
....................        
....................       // SMS Sending    
....................       if((SendSMS.B2 ==0)&& (functointest_f ==0) && (Ack.B2 ==0)) 
584E:  MOVLB  7
5850:  BTFSC  xE8.1
5852:  BRA    58AE
5854:  BTFSC  2D.1
5856:  BRA    58AE
5858:  BTFSC  xE1.1
585A:  BRA    58AE
....................       { 
....................          SendSMS.B2 =1; 
585C:  BSF    xE8.1
....................          printf("AT+CMGS=\""); 
585E:  MOVLW  22
5860:  MOVWF  FF6
5862:  MOVLW  07
5864:  MOVWF  FF7
5866:  MOVLB  0
5868:  CALL   1F28
....................          printf(sms_phonenumber); 
586C:  MOVLW  06
586E:  MOVWF  FEA
5870:  MOVLW  83
5872:  MOVWF  FE9
5874:  CALL   448A
....................           
....................          printf("\""); 
5878:  MOVLW  22
587A:  CLRWDT
587C:  BTFSS  F9E.4
587E:  BRA    587A
5880:  MOVWF  FAD
....................          putc('\n'); 
5882:  MOVLW  0A
5884:  CALL   1F4C
....................          delay_ms(50); 
5888:  MOVLW  32
588A:  MOVLB  8
588C:  MOVWF  x79
588E:  MOVLB  0
5890:  CALL   0772
....................          
....................         printf(SMS_Massage2);  
5894:  MOVLW  06
5896:  MOVWF  FEA
5898:  MOVLW  BB
589A:  MOVWF  FE9
589C:  CALL   448A
....................         putc('\n'); 
58A0:  MOVLW  0A
58A2:  CALL   1F4C
....................         putc(26); 
58A6:  MOVLW  1A
58A8:  CALL   1F4C
58AC:  MOVLB  7
....................       } 
....................    } 
....................    else if(FaultType.B2 == 0) 
58AE:  BRA    593A
58B0:  MOVLB  7
58B2:  BTFSC  xDD.1
58B4:  BRA    593A
....................    { 
....................       In2.B2 = 0x00; 
58B6:  BCF    xE3.1
....................       Ack.B2 = 0; 
58B8:  BCF    xE1.1
....................       Output.B2 = 1;      //Off LED 
58BA:  BSF    xDB.1
....................        
....................       SendSMS.B2 =0;// Clear SMS 
58BC:  BCF    xE8.1
....................  
....................       if((OutputType.B2 == 1 || OutputBoth.B2 == 0)&& inputflag ==0)      //If Buzzer or Both 
58BE:  BTFSC  xDE.1
58C0:  BRA    58C6
58C2:  BTFSC  xDF.1
58C4:  BRA    58E8
58C6:  MOVLB  8
58C8:  MOVF   x6C,F
58CA:  BTFSC  FD8.2
58CC:  BRA    58D2
58CE:  MOVLB  7
58D0:  BRA    58E8
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing 
58D2:  MOVLW  01
58D4:  MOVWF  x78
58D6:  MOVLB  0
58D8:  CALL   44B2
58DC:  DECFSZ 01,W
58DE:  BRA    58E2
....................          else 
58E0:  BRA    58E6
....................          { 
....................             output_bit(Pbuzzer,1);   //Clear Buzzer 
58E2:  BSF    F89.4
58E4:  BCF    F92.4
58E6:  MOVLB  7
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B2 == 0 || OutputBoth.B2 == 0)&& inputflag ==0)  //If Bell or Both 
58E8:  BTFSS  xDE.1
58EA:  BRA    58F0
58EC:  BTFSC  xDF.1
58EE:  BRA    5912
58F0:  MOVLB  8
58F2:  MOVF   x6C,F
58F4:  BTFSC  FD8.2
58F6:  BRA    58FC
58F8:  MOVLB  7
58FA:  BRA    5912
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
58FC:  MOVLW  02
58FE:  MOVWF  x78
5900:  MOVLB  0
5902:  CALL   44B2
5906:  DECFSZ 01,W
5908:  BRA    590C
....................          else 
590A:  BRA    5910
....................          { 
....................             output_bit(Pbell,1);      //Clear Bell 
590C:  BSF    F89.3
590E:  BCF    F92.3
5910:  MOVLB  7
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 ) 
5912:  BTFSC  xE3.0
5914:  BRA    593A
5916:  BTFSC  xE3.1
5918:  BRA    593A
591A:  BTFSC  xE3.2
591C:  BRA    593A
591E:  BTFSC  xE3.3
5920:  BRA    593A
5922:  BTFSC  xE3.4
5924:  BRA    593A
5926:  BTFSC  xE3.5
5928:  BRA    593A
592A:  BTFSC  xE3.6
592C:  BRA    593A
592E:  BTFSC  xE3.7
5930:  BRA    593A
....................       { 
....................          output_bit(Pbell,1);      //Clear Bell 
5932:  BSF    F89.3
5934:  BCF    F92.3
....................          output_bit(Pbuzzer,1);   //Clear Buzzer 
5936:  BSF    F89.4
5938:  BCF    F92.4
....................       } 
....................    } 
....................    //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //input3 
....................    if((((Input.B3 ^ InputType.B3) == 1) && (FaultType.B3 == 0)) ||Test_fault==1)   // alarm1 occure and " Non Lock type" 
593A:  MOVLW  00
593C:  BTFSC  xDA.2
593E:  MOVLW  01
5940:  MOVLB  8
5942:  MOVWF  x78
5944:  MOVLW  00
5946:  MOVLB  7
5948:  BTFSC  xDC.2
594A:  MOVLW  01
594C:  MOVLB  8
594E:  XORWF  x78,W
5950:  SUBLW  01
5952:  BNZ   595C
5954:  MOVLB  7
5956:  BTFSS  xDD.2
5958:  BRA    5962
595A:  MOVLB  8
595C:  BTFSS  17.5
595E:  BRA    5A14
5960:  MOVLB  7
....................    { 
....................       if(In2.B3 == 0 && AutoAck == 0x0F && Ack.B3 == 0)   //use auto acknowlegde 
5962:  BTFSC  xE3.2
5964:  BRA    5978
5966:  MOVF   67,W
5968:  SUBLW  0F
596A:  BNZ   5978
596C:  BTFSC  xE1.2
596E:  BRA    5978
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
5970:  MOVLW  64
5972:  MOVWF  19
....................             AutoAckDelayTime = AutoAckTime ; 
5974:  MOVFF  68,1A
....................       } 
....................  
....................       In2.B3 = 1; 
5978:  BSF    xE3.2
....................       if(Ack.B3 == 0) 
597A:  BTFSC  xE1.2
597C:  BRA    59AC
....................       { 
....................          if(FlashingFlag == 0) 
597E:  BTFSC  17.1
5980:  BRA    5986
....................             { 
....................                Output.B3 = 0;           //Flash output1 
5982:  BCF    xDB.2
....................             } 
....................             else 
5984:  BRA    5988
....................             { 
....................                Output.B3 = 1; 
5986:  BSF    xDB.2
....................             } 
....................          if (~AutoTestFlag) 
5988:  BTFSC  17.4
598A:  BRA    59AC
....................          { 
....................             if(AlarmIndicator.B3 == 1){ 
598C:  BTFSS  xE0.2
598E:  BRA    59AC
....................                 if(OutputBoth.B3 == 0)        //Both output 
5990:  BTFSC  xDF.2
5992:  BRA    599E
....................                 { 
....................                   output_bit(Pbuzzer,0);   //Buzzer 
5994:  BCF    F89.4
5996:  BCF    F92.4
....................                   output_bit(Pbell,0);     //Bell 
5998:  BCF    F89.3
599A:  BCF    F92.3
....................                 } 
....................                 else 
599C:  BRA    59AC
....................                 { 
....................                   if(OutputType.B3 == 1) output_bit(Pbuzzer,0);     //Buzzer 
599E:  BTFSS  xDE.2
59A0:  BRA    59A8
59A2:  BCF    F89.4
59A4:  BCF    F92.4
....................                   else output_bit(Pbell,0);                          //Bell 
59A6:  BRA    59AC
59A8:  BCF    F89.3
59AA:  BCF    F92.3
....................                 } 
....................             } 
....................          } 
....................        } 
....................       inputflag =1; 
59AC:  MOVLW  01
59AE:  MOVLB  8
59B0:  MOVWF  x6C
....................        
....................       // SMS Sending    
....................       if((SendSMS.B3 ==0)&& (functointest_f ==0) && (Ack.B3 ==0)) 
59B2:  MOVLB  7
59B4:  BTFSC  xE8.2
59B6:  BRA    5A12
59B8:  BTFSC  2D.1
59BA:  BRA    5A12
59BC:  BTFSC  xE1.2
59BE:  BRA    5A12
....................       { 
....................          SendSMS.B3 =1; 
59C0:  BSF    xE8.2
....................          printf("AT+CMGS=\""); 
59C2:  MOVLW  2C
59C4:  MOVWF  FF6
59C6:  MOVLW  07
59C8:  MOVWF  FF7
59CA:  MOVLB  0
59CC:  CALL   1F28
....................          printf(sms_phonenumber); 
59D0:  MOVLW  06
59D2:  MOVWF  FEA
59D4:  MOVLW  83
59D6:  MOVWF  FE9
59D8:  CALL   448A
....................           
....................          printf("\""); 
59DC:  MOVLW  22
59DE:  CLRWDT
59E0:  BTFSS  F9E.4
59E2:  BRA    59DE
59E4:  MOVWF  FAD
....................          putc('\n'); 
59E6:  MOVLW  0A
59E8:  CALL   1F4C
....................          delay_ms(50); 
59EC:  MOVLW  32
59EE:  MOVLB  8
59F0:  MOVWF  x79
59F2:  MOVLB  0
59F4:  CALL   0772
....................          
....................         printf(SMS_Massage3);  
59F8:  MOVLW  06
59FA:  MOVWF  FEA
59FC:  MOVLW  E4
59FE:  MOVWF  FE9
5A00:  CALL   448A
....................         putc('\n'); 
5A04:  MOVLW  0A
5A06:  CALL   1F4C
....................         putc(26); 
5A0A:  MOVLW  1A
5A0C:  CALL   1F4C
5A10:  MOVLB  7
....................       } 
....................    } 
....................    else if(FaultType.B3 == 0) 
5A12:  BRA    5A9E
5A14:  MOVLB  7
5A16:  BTFSC  xDD.2
5A18:  BRA    5A9E
....................    { 
....................       In2.B3 = 0x00; 
5A1A:  BCF    xE3.2
....................       Ack.B3 = 0; 
5A1C:  BCF    xE1.2
....................       Output.B3 = 1;      //Off LED 
5A1E:  BSF    xDB.2
....................        
....................       SendSMS.B3 =0;// Clear SMS 
5A20:  BCF    xE8.2
....................  
....................       if((OutputType.B3 == 1 || OutputBoth.B3 == 0)&& inputflag ==0)      //If Buzzer or Both 
5A22:  BTFSC  xDE.2
5A24:  BRA    5A2A
5A26:  BTFSC  xDF.2
5A28:  BRA    5A4C
5A2A:  MOVLB  8
5A2C:  MOVF   x6C,F
5A2E:  BTFSC  FD8.2
5A30:  BRA    5A36
5A32:  MOVLB  7
5A34:  BRA    5A4C
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing 
5A36:  MOVLW  01
5A38:  MOVWF  x78
5A3A:  MOVLB  0
5A3C:  CALL   44B2
5A40:  DECFSZ 01,W
5A42:  BRA    5A46
....................          else 
5A44:  BRA    5A4A
....................          { 
....................             output_bit(Pbuzzer,1);   //Clear Buzzer 
5A46:  BSF    F89.4
5A48:  BCF    F92.4
5A4A:  MOVLB  7
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B3 == 0 || OutputBoth.B3 == 0)&& inputflag ==0)  //If Bell or Both 
5A4C:  BTFSS  xDE.2
5A4E:  BRA    5A54
5A50:  BTFSC  xDF.2
5A52:  BRA    5A76
5A54:  MOVLB  8
5A56:  MOVF   x6C,F
5A58:  BTFSC  FD8.2
5A5A:  BRA    5A60
5A5C:  MOVLB  7
5A5E:  BRA    5A76
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
5A60:  MOVLW  02
5A62:  MOVWF  x78
5A64:  MOVLB  0
5A66:  CALL   44B2
5A6A:  DECFSZ 01,W
5A6C:  BRA    5A70
....................          else 
5A6E:  BRA    5A74
....................          { 
....................             output_bit(Pbell,1);      //Clear Bell 
5A70:  BSF    F89.3
5A72:  BCF    F92.3
5A74:  MOVLB  7
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 ) 
5A76:  BTFSC  xE3.0
5A78:  BRA    5A9E
5A7A:  BTFSC  xE3.1
5A7C:  BRA    5A9E
5A7E:  BTFSC  xE3.2
5A80:  BRA    5A9E
5A82:  BTFSC  xE3.3
5A84:  BRA    5A9E
5A86:  BTFSC  xE3.4
5A88:  BRA    5A9E
5A8A:  BTFSC  xE3.5
5A8C:  BRA    5A9E
5A8E:  BTFSC  xE3.6
5A90:  BRA    5A9E
5A92:  BTFSC  xE3.7
5A94:  BRA    5A9E
....................       { 
....................          output_bit(Pbell,1);      //Clear Bell 
5A96:  BSF    F89.3
5A98:  BCF    F92.3
....................          output_bit(Pbuzzer,1);   //Clear Buzzer 
5A9A:  BSF    F89.4
5A9C:  BCF    F92.4
....................       } 
....................    } 
....................    //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //input4 
....................    if((((Input.B4 ^ InputType.B4) == 1) && (FaultType.B4 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type" 
5A9E:  MOVLW  00
5AA0:  BTFSC  xDA.3
5AA2:  MOVLW  01
5AA4:  MOVLB  8
5AA6:  MOVWF  x78
5AA8:  MOVLW  00
5AAA:  MOVLB  7
5AAC:  BTFSC  xDC.3
5AAE:  MOVLW  01
5AB0:  MOVLB  8
5AB2:  XORWF  x78,W
5AB4:  SUBLW  01
5AB6:  BNZ   5AC0
5AB8:  MOVLB  7
5ABA:  BTFSS  xDD.3
5ABC:  BRA    5AC6
5ABE:  MOVLB  8
5AC0:  BTFSS  17.5
5AC2:  BRA    5B78
5AC4:  MOVLB  7
....................    { 
....................       if(In2.B4 == 0 && AutoAck == 0x0F && Ack.B4 == 0)   //use auto acknowlegde 
5AC6:  BTFSC  xE3.3
5AC8:  BRA    5ADC
5ACA:  MOVF   67,W
5ACC:  SUBLW  0F
5ACE:  BNZ   5ADC
5AD0:  BTFSC  xE1.3
5AD2:  BRA    5ADC
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
5AD4:  MOVLW  64
5AD6:  MOVWF  19
....................             AutoAckDelayTime = AutoAckTime ; 
5AD8:  MOVFF  68,1A
....................       } 
....................  
....................       In2.B4 = 1; 
5ADC:  BSF    xE3.3
....................       if(Ack.B4 == 0) 
5ADE:  BTFSC  xE1.3
5AE0:  BRA    5B10
....................       { 
....................          if(FlashingFlag == 0) 
5AE2:  BTFSC  17.1
5AE4:  BRA    5AEA
....................             { 
....................                Output.B4 = 0;           //Flash output1 
5AE6:  BCF    xDB.3
....................             } 
....................             else 
5AE8:  BRA    5AEC
....................             { 
....................                Output.B4 = 1; 
5AEA:  BSF    xDB.3
....................             } 
....................          if (~AutoTestFlag) 
5AEC:  BTFSC  17.4
5AEE:  BRA    5B10
....................          { 
....................             if(AlarmIndicator.B4 == 1){ 
5AF0:  BTFSS  xE0.3
5AF2:  BRA    5B10
....................                 if(OutputBoth.B4 == 0)        //Both output 
5AF4:  BTFSC  xDF.3
5AF6:  BRA    5B02
....................                 { 
....................                   output_bit(Pbuzzer,0);   //Buzzer 
5AF8:  BCF    F89.4
5AFA:  BCF    F92.4
....................                   output_bit(Pbell,0);     //Bell 
5AFC:  BCF    F89.3
5AFE:  BCF    F92.3
....................                 } 
....................                 else 
5B00:  BRA    5B10
....................                 { 
....................                   if(OutputType.B4 == 1) output_bit(Pbuzzer,0);     //Buzzer 
5B02:  BTFSS  xDE.3
5B04:  BRA    5B0C
5B06:  BCF    F89.4
5B08:  BCF    F92.4
....................                   else output_bit(Pbell,0);                          //Bell 
5B0A:  BRA    5B10
5B0C:  BCF    F89.3
5B0E:  BCF    F92.3
....................                 } 
....................             } 
....................          } 
....................        } 
....................       inputflag =1; 
5B10:  MOVLW  01
5B12:  MOVLB  8
5B14:  MOVWF  x6C
....................        
....................       // SMS Sending    
....................       if((SendSMS.B4 ==0)&& (functointest_f ==0) && (Ack.B4 ==0)) 
5B16:  MOVLB  7
5B18:  BTFSC  xE8.3
5B1A:  BRA    5B76
5B1C:  BTFSC  2D.1
5B1E:  BRA    5B76
5B20:  BTFSC  xE1.3
5B22:  BRA    5B76
....................       { 
....................          SendSMS.B4 =1; 
5B24:  BSF    xE8.3
....................          printf("AT+CMGS=\""); 
5B26:  MOVLW  36
5B28:  MOVWF  FF6
5B2A:  MOVLW  07
5B2C:  MOVWF  FF7
5B2E:  MOVLB  0
5B30:  CALL   1F28
....................          printf(sms_phonenumber); 
5B34:  MOVLW  06
5B36:  MOVWF  FEA
5B38:  MOVLW  83
5B3A:  MOVWF  FE9
5B3C:  CALL   448A
....................           
....................          printf("\""); 
5B40:  MOVLW  22
5B42:  CLRWDT
5B44:  BTFSS  F9E.4
5B46:  BRA    5B42
5B48:  MOVWF  FAD
....................          putc('\n'); 
5B4A:  MOVLW  0A
5B4C:  CALL   1F4C
....................          delay_ms(50); 
5B50:  MOVLW  32
5B52:  MOVLB  8
5B54:  MOVWF  x79
5B56:  MOVLB  0
5B58:  CALL   0772
....................          
....................         printf(SMS_Massage4);  
5B5C:  MOVLW  07
5B5E:  MOVWF  FEA
5B60:  MOVLW  0D
5B62:  MOVWF  FE9
5B64:  CALL   448A
....................         putc('\n'); 
5B68:  MOVLW  0A
5B6A:  CALL   1F4C
....................         putc(26); 
5B6E:  MOVLW  1A
5B70:  CALL   1F4C
5B74:  MOVLB  7
....................       } 
....................    } 
....................    else if(FaultType.B4 == 0) 
5B76:  BRA    5C02
5B78:  MOVLB  7
5B7A:  BTFSC  xDD.3
5B7C:  BRA    5C02
....................    { 
....................       In2.B4 = 0x00; 
5B7E:  BCF    xE3.3
....................       Ack.B4 = 0; 
5B80:  BCF    xE1.3
....................       Output.B4 = 1;      //Off LED 
5B82:  BSF    xDB.3
....................        
....................       SendSMS.B4 =0;// Clear SMS 
5B84:  BCF    xE8.3
....................  
....................       if((OutputType.B4 == 1 || OutputBoth.B4 == 0)&& inputflag ==0)      //If Buzzer or Both 
5B86:  BTFSC  xDE.3
5B88:  BRA    5B8E
5B8A:  BTFSC  xDF.3
5B8C:  BRA    5BB0
5B8E:  MOVLB  8
5B90:  MOVF   x6C,F
5B92:  BTFSC  FD8.2
5B94:  BRA    5B9A
5B96:  MOVLB  7
5B98:  BRA    5BB0
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing 
5B9A:  MOVLW  01
5B9C:  MOVWF  x78
5B9E:  MOVLB  0
5BA0:  CALL   44B2
5BA4:  DECFSZ 01,W
5BA6:  BRA    5BAA
....................          else 
5BA8:  BRA    5BAE
....................          { 
....................             output_bit(Pbuzzer,1);   //Clear Buzzer 
5BAA:  BSF    F89.4
5BAC:  BCF    F92.4
5BAE:  MOVLB  7
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B4 == 0 || OutputBoth.B4 == 0)&& inputflag ==0)  //If Bell or Both 
5BB0:  BTFSS  xDE.3
5BB2:  BRA    5BB8
5BB4:  BTFSC  xDF.3
5BB6:  BRA    5BDA
5BB8:  MOVLB  8
5BBA:  MOVF   x6C,F
5BBC:  BTFSC  FD8.2
5BBE:  BRA    5BC4
5BC0:  MOVLB  7
5BC2:  BRA    5BDA
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
5BC4:  MOVLW  02
5BC6:  MOVWF  x78
5BC8:  MOVLB  0
5BCA:  CALL   44B2
5BCE:  DECFSZ 01,W
5BD0:  BRA    5BD4
....................          else 
5BD2:  BRA    5BD8
....................          { 
....................             output_bit(Pbell,1);      //Clear Bell 
5BD4:  BSF    F89.3
5BD6:  BCF    F92.3
5BD8:  MOVLB  7
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0) 
5BDA:  BTFSC  xE3.0
5BDC:  BRA    5C02
5BDE:  BTFSC  xE3.1
5BE0:  BRA    5C02
5BE2:  BTFSC  xE3.2
5BE4:  BRA    5C02
5BE6:  BTFSC  xE3.3
5BE8:  BRA    5C02
5BEA:  BTFSC  xE3.4
5BEC:  BRA    5C02
5BEE:  BTFSC  xE3.5
5BF0:  BRA    5C02
5BF2:  BTFSC  xE3.6
5BF4:  BRA    5C02
5BF6:  BTFSC  xE3.7
5BF8:  BRA    5C02
....................       { 
....................          output_bit(Pbell,1);      //Clear Bell 
5BFA:  BSF    F89.3
5BFC:  BCF    F92.3
....................          output_bit(Pbuzzer,1);   //Clear Buzzer 
5BFE:  BSF    F89.4
5C00:  BCF    F92.4
....................       } 
....................    } 
....................    //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //input5 
....................    if((((Input.B5 ^ InputType.B5) == 1) && (FaultType.B5 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type" 
5C02:  MOVLW  00
5C04:  BTFSC  xDA.4
5C06:  MOVLW  01
5C08:  MOVLB  8
5C0A:  MOVWF  x78
5C0C:  MOVLW  00
5C0E:  MOVLB  7
5C10:  BTFSC  xDC.4
5C12:  MOVLW  01
5C14:  MOVLB  8
5C16:  XORWF  x78,W
5C18:  SUBLW  01
5C1A:  BNZ   5C24
5C1C:  MOVLB  7
5C1E:  BTFSS  xDD.4
5C20:  BRA    5C2A
5C22:  MOVLB  8
5C24:  BTFSS  17.5
5C26:  BRA    5CDC
5C28:  MOVLB  7
....................    { 
....................       if(In2.B5 == 0 && AutoAck == 0x0F && Ack.B5 == 0)   //use auto acknowlegde 
5C2A:  BTFSC  xE3.4
5C2C:  BRA    5C40
5C2E:  MOVF   67,W
5C30:  SUBLW  0F
5C32:  BNZ   5C40
5C34:  BTFSC  xE1.4
5C36:  BRA    5C40
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
5C38:  MOVLW  64
5C3A:  MOVWF  19
....................             AutoAckDelayTime = AutoAckTime ; 
5C3C:  MOVFF  68,1A
....................       } 
....................  
....................       In2.B5 = 1; 
5C40:  BSF    xE3.4
....................       if(Ack.B5 == 0) 
5C42:  BTFSC  xE1.4
5C44:  BRA    5C74
....................       { 
....................          if(FlashingFlag == 0) 
5C46:  BTFSC  17.1
5C48:  BRA    5C4E
....................             { 
....................                Output.B5 = 0;           //Flash output1 
5C4A:  BCF    xDB.4
....................             } 
....................             else 
5C4C:  BRA    5C50
....................             { 
....................                Output.B5 = 1; 
5C4E:  BSF    xDB.4
....................             } 
....................          if (~AutoTestFlag) 
5C50:  BTFSC  17.4
5C52:  BRA    5C74
....................          { 
....................             if(AlarmIndicator.B5 == 1){ 
5C54:  BTFSS  xE0.4
5C56:  BRA    5C74
....................                 if(OutputBoth.B5 == 0)        //Both output 
5C58:  BTFSC  xDF.4
5C5A:  BRA    5C66
....................                 { 
....................                   output_bit(Pbuzzer,0);   //Buzzer 
5C5C:  BCF    F89.4
5C5E:  BCF    F92.4
....................                   output_bit(Pbell,0);     //Bell 
5C60:  BCF    F89.3
5C62:  BCF    F92.3
....................                 } 
....................                 else 
5C64:  BRA    5C74
....................                 { 
....................                   if(OutputType.B5 == 1) output_bit(Pbuzzer,0);     //Buzzer 
5C66:  BTFSS  xDE.4
5C68:  BRA    5C70
5C6A:  BCF    F89.4
5C6C:  BCF    F92.4
....................                   else output_bit(Pbell,0);                          //Bell 
5C6E:  BRA    5C74
5C70:  BCF    F89.3
5C72:  BCF    F92.3
....................                 } 
....................             } 
....................          } 
....................        } 
....................       inputflag =1; 
5C74:  MOVLW  01
5C76:  MOVLB  8
5C78:  MOVWF  x6C
....................        
....................       // SMS Sending    
....................       if((SendSMS.B5 ==0)&& (functointest_f ==0) && (Ack.B5 ==0)) 
5C7A:  MOVLB  7
5C7C:  BTFSC  xE8.4
5C7E:  BRA    5CDA
5C80:  BTFSC  2D.1
5C82:  BRA    5CDA
5C84:  BTFSC  xE1.4
5C86:  BRA    5CDA
....................       { 
....................          SendSMS.B5 =1; 
5C88:  BSF    xE8.4
....................          printf("AT+CMGS=\""); 
5C8A:  MOVLW  40
5C8C:  MOVWF  FF6
5C8E:  MOVLW  07
5C90:  MOVWF  FF7
5C92:  MOVLB  0
5C94:  CALL   1F28
....................          printf(sms_phonenumber); 
5C98:  MOVLW  06
5C9A:  MOVWF  FEA
5C9C:  MOVLW  83
5C9E:  MOVWF  FE9
5CA0:  CALL   448A
....................           
....................          printf("\""); 
5CA4:  MOVLW  22
5CA6:  CLRWDT
5CA8:  BTFSS  F9E.4
5CAA:  BRA    5CA6
5CAC:  MOVWF  FAD
....................          putc('\n'); 
5CAE:  MOVLW  0A
5CB0:  CALL   1F4C
....................          delay_ms(50); 
5CB4:  MOVLW  32
5CB6:  MOVLB  8
5CB8:  MOVWF  x79
5CBA:  MOVLB  0
5CBC:  CALL   0772
....................          
....................         printf(SMS_Massage5);  
5CC0:  MOVLW  07
5CC2:  MOVWF  FEA
5CC4:  MOVLW  36
5CC6:  MOVWF  FE9
5CC8:  CALL   448A
....................         putc('\n'); 
5CCC:  MOVLW  0A
5CCE:  CALL   1F4C
....................         putc(26); 
5CD2:  MOVLW  1A
5CD4:  CALL   1F4C
5CD8:  MOVLB  7
....................       } 
....................    } 
....................    else if(FaultType.B5 == 0) 
5CDA:  BRA    5D66
5CDC:  MOVLB  7
5CDE:  BTFSC  xDD.4
5CE0:  BRA    5D66
....................    { 
....................       In2.B5 = 0x00; 
5CE2:  BCF    xE3.4
....................       Ack.B5 = 0; 
5CE4:  BCF    xE1.4
....................       Output.B5 = 1;      //Off LED 
5CE6:  BSF    xDB.4
....................        
....................       SendSMS.B5 =0;// Clear SMS 
5CE8:  BCF    xE8.4
....................  
....................       if((OutputType.B5 == 1 || OutputBoth.B5 == 0)&& inputflag ==0)      //If Buzzer or Both 
5CEA:  BTFSC  xDE.4
5CEC:  BRA    5CF2
5CEE:  BTFSC  xDF.4
5CF0:  BRA    5D14
5CF2:  MOVLB  8
5CF4:  MOVF   x6C,F
5CF6:  BTFSC  FD8.2
5CF8:  BRA    5CFE
5CFA:  MOVLB  7
5CFC:  BRA    5D14
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing 
5CFE:  MOVLW  01
5D00:  MOVWF  x78
5D02:  MOVLB  0
5D04:  CALL   44B2
5D08:  DECFSZ 01,W
5D0A:  BRA    5D0E
....................          else 
5D0C:  BRA    5D12
....................          { 
....................             output_bit(Pbuzzer,1);   //Clear Buzzer 
5D0E:  BSF    F89.4
5D10:  BCF    F92.4
5D12:  MOVLB  7
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B5 == 0 || OutputBoth.B5 == 0)&& inputflag ==0)  //If Bell or Both 
5D14:  BTFSS  xDE.4
5D16:  BRA    5D1C
5D18:  BTFSC  xDF.4
5D1A:  BRA    5D3E
5D1C:  MOVLB  8
5D1E:  MOVF   x6C,F
5D20:  BTFSC  FD8.2
5D22:  BRA    5D28
5D24:  MOVLB  7
5D26:  BRA    5D3E
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
5D28:  MOVLW  02
5D2A:  MOVWF  x78
5D2C:  MOVLB  0
5D2E:  CALL   44B2
5D32:  DECFSZ 01,W
5D34:  BRA    5D38
....................          else 
5D36:  BRA    5D3C
....................          { 
....................             output_bit(Pbell,1);      //Clear Bell 
5D38:  BSF    F89.3
5D3A:  BCF    F92.3
5D3C:  MOVLB  7
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0) 
5D3E:  BTFSC  xE3.0
5D40:  BRA    5D66
5D42:  BTFSC  xE3.1
5D44:  BRA    5D66
5D46:  BTFSC  xE3.2
5D48:  BRA    5D66
5D4A:  BTFSC  xE3.3
5D4C:  BRA    5D66
5D4E:  BTFSC  xE3.4
5D50:  BRA    5D66
5D52:  BTFSC  xE3.5
5D54:  BRA    5D66
5D56:  BTFSC  xE3.6
5D58:  BRA    5D66
5D5A:  BTFSC  xE3.7
5D5C:  BRA    5D66
....................       { 
....................          output_bit(Pbell,1);      //Clear Bell 
5D5E:  BSF    F89.3
5D60:  BCF    F92.3
....................          output_bit(Pbuzzer,1);   //Clear Buzzer 
5D62:  BSF    F89.4
5D64:  BCF    F92.4
....................       } 
....................    } 
....................    //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //input6 
....................    if((((Input.B6 ^ InputType.B6) == 1) && (FaultType.B6 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type" 
5D66:  MOVLW  00
5D68:  BTFSC  xDA.5
5D6A:  MOVLW  01
5D6C:  MOVLB  8
5D6E:  MOVWF  x78
5D70:  MOVLW  00
5D72:  MOVLB  7
5D74:  BTFSC  xDC.5
5D76:  MOVLW  01
5D78:  MOVLB  8
5D7A:  XORWF  x78,W
5D7C:  SUBLW  01
5D7E:  BNZ   5D88
5D80:  MOVLB  7
5D82:  BTFSS  xDD.5
5D84:  BRA    5D8E
5D86:  MOVLB  8
5D88:  BTFSS  17.5
5D8A:  BRA    5E40
5D8C:  MOVLB  7
....................    { 
....................       if(In2.B6 == 0 && AutoAck == 0x0F && Ack.B6 == 0)   //use auto acknowlegde 
5D8E:  BTFSC  xE3.5
5D90:  BRA    5DA4
5D92:  MOVF   67,W
5D94:  SUBLW  0F
5D96:  BNZ   5DA4
5D98:  BTFSC  xE1.5
5D9A:  BRA    5DA4
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
5D9C:  MOVLW  64
5D9E:  MOVWF  19
....................             AutoAckDelayTime = AutoAckTime ; 
5DA0:  MOVFF  68,1A
....................       } 
....................  
....................       In2.B6 = 1; 
5DA4:  BSF    xE3.5
....................       if(Ack.B6 == 0) 
5DA6:  BTFSC  xE1.5
5DA8:  BRA    5DD8
....................       { 
....................          if(FlashingFlag == 0) 
5DAA:  BTFSC  17.1
5DAC:  BRA    5DB2
....................             { 
....................                Output.B6 = 0;           //Flash output1 
5DAE:  BCF    xDB.5
....................             } 
....................             else 
5DB0:  BRA    5DB4
....................             { 
....................                Output.B6 = 1; 
5DB2:  BSF    xDB.5
....................             } 
....................          if (~AutoTestFlag) 
5DB4:  BTFSC  17.4
5DB6:  BRA    5DD8
....................          { 
....................             if(AlarmIndicator.B6 == 1){ 
5DB8:  BTFSS  xE0.5
5DBA:  BRA    5DD8
....................                 if(OutputBoth.B6 == 0)        //Both output 
5DBC:  BTFSC  xDF.5
5DBE:  BRA    5DCA
....................                 { 
....................                   output_bit(Pbuzzer,0);   //Buzzer 
5DC0:  BCF    F89.4
5DC2:  BCF    F92.4
....................                   output_bit(Pbell,0);     //Bell 
5DC4:  BCF    F89.3
5DC6:  BCF    F92.3
....................                 } 
....................                 else 
5DC8:  BRA    5DD8
....................                 { 
....................                   if(OutputType.B6 == 1) output_bit(Pbuzzer,0);     //Buzzer 
5DCA:  BTFSS  xDE.5
5DCC:  BRA    5DD4
5DCE:  BCF    F89.4
5DD0:  BCF    F92.4
....................                   else output_bit(Pbell,0);                          //Bell 
5DD2:  BRA    5DD8
5DD4:  BCF    F89.3
5DD6:  BCF    F92.3
....................                 } 
....................             } 
....................          } 
....................        } 
....................       inputflag =1; 
5DD8:  MOVLW  01
5DDA:  MOVLB  8
5DDC:  MOVWF  x6C
....................        
....................       // SMS Sending    
....................       if((SendSMS.B6 ==0)&& (functointest_f ==0) && (Ack.B6 ==0)) 
5DDE:  MOVLB  7
5DE0:  BTFSC  xE8.5
5DE2:  BRA    5E3E
5DE4:  BTFSC  2D.1
5DE6:  BRA    5E3E
5DE8:  BTFSC  xE1.5
5DEA:  BRA    5E3E
....................       { 
....................          SendSMS.B6 =1; 
5DEC:  BSF    xE8.5
....................          printf("AT+CMGS=\""); 
5DEE:  MOVLW  4A
5DF0:  MOVWF  FF6
5DF2:  MOVLW  07
5DF4:  MOVWF  FF7
5DF6:  MOVLB  0
5DF8:  CALL   1F28
....................          printf(sms_phonenumber); 
5DFC:  MOVLW  06
5DFE:  MOVWF  FEA
5E00:  MOVLW  83
5E02:  MOVWF  FE9
5E04:  CALL   448A
....................           
....................          printf("\""); 
5E08:  MOVLW  22
5E0A:  CLRWDT
5E0C:  BTFSS  F9E.4
5E0E:  BRA    5E0A
5E10:  MOVWF  FAD
....................          putc('\n'); 
5E12:  MOVLW  0A
5E14:  CALL   1F4C
....................          delay_ms(50); 
5E18:  MOVLW  32
5E1A:  MOVLB  8
5E1C:  MOVWF  x79
5E1E:  MOVLB  0
5E20:  CALL   0772
....................          
....................         printf(SMS_Massage6);   
5E24:  MOVLW  07
5E26:  MOVWF  FEA
5E28:  MOVLW  5F
5E2A:  MOVWF  FE9
5E2C:  CALL   448A
....................         putc('\n'); 
5E30:  MOVLW  0A
5E32:  CALL   1F4C
....................         putc(26); 
5E36:  MOVLW  1A
5E38:  CALL   1F4C
5E3C:  MOVLB  7
....................       } 
....................    } 
....................    else if(FaultType.B6 == 0) 
5E3E:  BRA    5ECA
5E40:  MOVLB  7
5E42:  BTFSC  xDD.5
5E44:  BRA    5ECA
....................    { 
....................       In2.B6 = 0x00; 
5E46:  BCF    xE3.5
....................       Ack.B6 = 0; 
5E48:  BCF    xE1.5
....................       Output.B6 = 1;      //Off LED 
5E4A:  BSF    xDB.5
....................        
....................       SendSMS.B6 =0;// Clear SMS 
5E4C:  BCF    xE8.5
....................  
....................       if((OutputType.B6 == 1 || OutputBoth.B6 == 0)&& inputflag ==0)      //If Buzzer or Both 
5E4E:  BTFSC  xDE.5
5E50:  BRA    5E56
5E52:  BTFSC  xDF.5
5E54:  BRA    5E78
5E56:  MOVLB  8
5E58:  MOVF   x6C,F
5E5A:  BTFSC  FD8.2
5E5C:  BRA    5E62
5E5E:  MOVLB  7
5E60:  BRA    5E78
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing 
5E62:  MOVLW  01
5E64:  MOVWF  x78
5E66:  MOVLB  0
5E68:  CALL   44B2
5E6C:  DECFSZ 01,W
5E6E:  BRA    5E72
....................          else 
5E70:  BRA    5E76
....................          { 
....................             output_bit(Pbuzzer,1);   //Clear Buzzer 
5E72:  BSF    F89.4
5E74:  BCF    F92.4
5E76:  MOVLB  7
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B6 == 0 || OutputBoth.B6 == 0)&& inputflag ==0)  //If Bell or Both 
5E78:  BTFSS  xDE.5
5E7A:  BRA    5E80
5E7C:  BTFSC  xDF.5
5E7E:  BRA    5EA2
5E80:  MOVLB  8
5E82:  MOVF   x6C,F
5E84:  BTFSC  FD8.2
5E86:  BRA    5E8C
5E88:  MOVLB  7
5E8A:  BRA    5EA2
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
5E8C:  MOVLW  02
5E8E:  MOVWF  x78
5E90:  MOVLB  0
5E92:  CALL   44B2
5E96:  DECFSZ 01,W
5E98:  BRA    5E9C
....................          else 
5E9A:  BRA    5EA0
....................          { 
....................             output_bit(Pbell,1);      //Clear Bell 
5E9C:  BSF    F89.3
5E9E:  BCF    F92.3
5EA0:  MOVLB  7
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0) 
5EA2:  BTFSC  xE3.0
5EA4:  BRA    5ECA
5EA6:  BTFSC  xE3.1
5EA8:  BRA    5ECA
5EAA:  BTFSC  xE3.2
5EAC:  BRA    5ECA
5EAE:  BTFSC  xE3.3
5EB0:  BRA    5ECA
5EB2:  BTFSC  xE3.4
5EB4:  BRA    5ECA
5EB6:  BTFSC  xE3.5
5EB8:  BRA    5ECA
5EBA:  BTFSC  xE3.6
5EBC:  BRA    5ECA
5EBE:  BTFSC  xE3.7
5EC0:  BRA    5ECA
....................       { 
....................          output_bit(Pbell,1);      //Clear Bell 
5EC2:  BSF    F89.3
5EC4:  BCF    F92.3
....................          output_bit(Pbuzzer,1);   //Clear Buzzer 
5EC6:  BSF    F89.4
5EC8:  BCF    F92.4
....................       } 
....................    } 
....................    //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //input7 
....................    if((((Input.B7 ^ InputType.B7) == 1) && (FaultType.B7 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type" 
5ECA:  MOVLW  00
5ECC:  BTFSC  xDA.6
5ECE:  MOVLW  01
5ED0:  MOVLB  8
5ED2:  MOVWF  x78
5ED4:  MOVLW  00
5ED6:  MOVLB  7
5ED8:  BTFSC  xDC.6
5EDA:  MOVLW  01
5EDC:  MOVLB  8
5EDE:  XORWF  x78,W
5EE0:  SUBLW  01
5EE2:  BNZ   5EEC
5EE4:  MOVLB  7
5EE6:  BTFSS  xDD.6
5EE8:  BRA    5EF2
5EEA:  MOVLB  8
5EEC:  BTFSS  17.5
5EEE:  BRA    5FA4
5EF0:  MOVLB  7
....................    { 
....................       if(In2.B7 == 0 && AutoAck == 0x0F && Ack.B7 == 0)   //use auto acknowlegde 
5EF2:  BTFSC  xE3.6
5EF4:  BRA    5F08
5EF6:  MOVF   67,W
5EF8:  SUBLW  0F
5EFA:  BNZ   5F08
5EFC:  BTFSC  xE1.6
5EFE:  BRA    5F08
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
5F00:  MOVLW  64
5F02:  MOVWF  19
....................             AutoAckDelayTime = AutoAckTime ; 
5F04:  MOVFF  68,1A
....................       } 
....................  
....................       In2.B7 = 1; 
5F08:  BSF    xE3.6
....................       if(Ack.B7 == 0) 
5F0A:  BTFSC  xE1.6
5F0C:  BRA    5F3C
....................       { 
....................          if(FlashingFlag == 0) 
5F0E:  BTFSC  17.1
5F10:  BRA    5F16
....................             { 
....................                Output.B7 = 0;           //Flash output1 
5F12:  BCF    xDB.6
....................             } 
....................             else 
5F14:  BRA    5F18
....................             { 
....................                Output.B7 = 1; 
5F16:  BSF    xDB.6
....................             } 
....................          if (~AutoTestFlag) 
5F18:  BTFSC  17.4
5F1A:  BRA    5F3C
....................          { 
....................             if(AlarmIndicator.B7 == 1){ 
5F1C:  BTFSS  xE0.6
5F1E:  BRA    5F3C
....................                 if(OutputBoth.B7 == 0)        //Both output 
5F20:  BTFSC  xDF.6
5F22:  BRA    5F2E
....................                 { 
....................                   output_bit(Pbuzzer,0);   //Buzzer 
5F24:  BCF    F89.4
5F26:  BCF    F92.4
....................                   output_bit(Pbell,0);     //Bell 
5F28:  BCF    F89.3
5F2A:  BCF    F92.3
....................                 } 
....................                 else 
5F2C:  BRA    5F3C
....................                 { 
....................                   if(OutputType.B7 == 1) output_bit(Pbuzzer,0);     //Buzzer 
5F2E:  BTFSS  xDE.6
5F30:  BRA    5F38
5F32:  BCF    F89.4
5F34:  BCF    F92.4
....................                   else output_bit(Pbell,0);                          //Bell 
5F36:  BRA    5F3C
5F38:  BCF    F89.3
5F3A:  BCF    F92.3
....................                 } 
....................             } 
....................          } 
....................        } 
....................       inputflag =1; 
5F3C:  MOVLW  01
5F3E:  MOVLB  8
5F40:  MOVWF  x6C
....................        
....................       // SMS Sending    
....................       if((SendSMS.B7 ==0)&& (functointest_f ==0) && (Ack.B7 ==0)) 
5F42:  MOVLB  7
5F44:  BTFSC  xE8.6
5F46:  BRA    5FA2
5F48:  BTFSC  2D.1
5F4A:  BRA    5FA2
5F4C:  BTFSC  xE1.6
5F4E:  BRA    5FA2
....................       { 
....................          SendSMS.B7 =1; 
5F50:  BSF    xE8.6
....................          printf("AT+CMGS=\""); 
5F52:  MOVLW  54
5F54:  MOVWF  FF6
5F56:  MOVLW  07
5F58:  MOVWF  FF7
5F5A:  MOVLB  0
5F5C:  CALL   1F28
....................          printf(sms_phonenumber); 
5F60:  MOVLW  06
5F62:  MOVWF  FEA
5F64:  MOVLW  83
5F66:  MOVWF  FE9
5F68:  CALL   448A
....................           
....................          printf("\""); 
5F6C:  MOVLW  22
5F6E:  CLRWDT
5F70:  BTFSS  F9E.4
5F72:  BRA    5F6E
5F74:  MOVWF  FAD
....................          putc('\n'); 
5F76:  MOVLW  0A
5F78:  CALL   1F4C
....................          delay_ms(50); 
5F7C:  MOVLW  32
5F7E:  MOVLB  8
5F80:  MOVWF  x79
5F82:  MOVLB  0
5F84:  CALL   0772
....................          
....................         printf(SMS_Massage7);   
5F88:  MOVLW  07
5F8A:  MOVWF  FEA
5F8C:  MOVLW  88
5F8E:  MOVWF  FE9
5F90:  CALL   448A
....................         putc('\n'); 
5F94:  MOVLW  0A
5F96:  CALL   1F4C
....................         putc(26); 
5F9A:  MOVLW  1A
5F9C:  CALL   1F4C
5FA0:  MOVLB  7
....................       } 
....................    } 
....................    else if(FaultType.B7 == 0) 
5FA2:  BRA    602E
5FA4:  MOVLB  7
5FA6:  BTFSC  xDD.6
5FA8:  BRA    602E
....................    { 
....................       In2.B7 = 0x00; 
5FAA:  BCF    xE3.6
....................       Ack.B7 = 0; 
5FAC:  BCF    xE1.6
....................       Output.B7 = 1;      //Off LED 
5FAE:  BSF    xDB.6
....................        
....................       SendSMS.B7 =0;// Clear SMS 
5FB0:  BCF    xE8.6
....................  
....................       if((OutputType.B7 == 1 || OutputBoth.B7 == 0)&& inputflag ==0)      //If Buzzer or Both 
5FB2:  BTFSC  xDE.6
5FB4:  BRA    5FBA
5FB6:  BTFSC  xDF.6
5FB8:  BRA    5FDC
5FBA:  MOVLB  8
5FBC:  MOVF   x6C,F
5FBE:  BTFSC  FD8.2
5FC0:  BRA    5FC6
5FC2:  MOVLB  7
5FC4:  BRA    5FDC
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing 
5FC6:  MOVLW  01
5FC8:  MOVWF  x78
5FCA:  MOVLB  0
5FCC:  CALL   44B2
5FD0:  DECFSZ 01,W
5FD2:  BRA    5FD6
....................          else 
5FD4:  BRA    5FDA
....................          { 
....................             output_bit(Pbuzzer,1);   //Clear Buzzer 
5FD6:  BSF    F89.4
5FD8:  BCF    F92.4
5FDA:  MOVLB  7
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B7 == 0 || OutputBoth.B7 == 0)&& inputflag ==0)  //If Bell or Both 
5FDC:  BTFSS  xDE.6
5FDE:  BRA    5FE4
5FE0:  BTFSC  xDF.6
5FE2:  BRA    6006
5FE4:  MOVLB  8
5FE6:  MOVF   x6C,F
5FE8:  BTFSC  FD8.2
5FEA:  BRA    5FF0
5FEC:  MOVLB  7
5FEE:  BRA    6006
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
5FF0:  MOVLW  02
5FF2:  MOVWF  x78
5FF4:  MOVLB  0
5FF6:  CALL   44B2
5FFA:  DECFSZ 01,W
5FFC:  BRA    6000
....................          else 
5FFE:  BRA    6004
....................          { 
....................             output_bit(Pbell,1);      //Clear Bell 
6000:  BSF    F89.3
6002:  BCF    F92.3
6004:  MOVLB  7
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0) 
6006:  BTFSC  xE3.0
6008:  BRA    602E
600A:  BTFSC  xE3.1
600C:  BRA    602E
600E:  BTFSC  xE3.2
6010:  BRA    602E
6012:  BTFSC  xE3.3
6014:  BRA    602E
6016:  BTFSC  xE3.4
6018:  BRA    602E
601A:  BTFSC  xE3.5
601C:  BRA    602E
601E:  BTFSC  xE3.6
6020:  BRA    602E
6022:  BTFSC  xE3.7
6024:  BRA    602E
....................       { 
....................          output_bit(Pbell,1);      //Clear Bell 
6026:  BSF    F89.3
6028:  BCF    F92.3
....................          output_bit(Pbuzzer,1);   //Clear Buzzer 
602A:  BSF    F89.4
602C:  BCF    F92.4
....................       } 
....................    } 
....................    //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //input8 
....................    if((((Input.B8 ^ InputType.B8) == 1) && (FaultType.B8 == 0)) ||Test_fault==1)   // alarm1 occure and " Non Lock type" 
602E:  MOVLW  00
6030:  BTFSC  xDA.7
6032:  MOVLW  01
6034:  MOVLB  8
6036:  MOVWF  x78
6038:  MOVLW  00
603A:  MOVLB  7
603C:  BTFSC  xDC.7
603E:  MOVLW  01
6040:  MOVLB  8
6042:  XORWF  x78,W
6044:  SUBLW  01
6046:  BNZ   6050
6048:  MOVLB  7
604A:  BTFSS  xDD.7
604C:  BRA    6056
604E:  MOVLB  8
6050:  BTFSS  17.5
6052:  BRA    6108
6054:  MOVLB  7
....................    { 
....................       if(In2.B8 == 0 && AutoAck == 0x0F && Ack.B8 == 0)   //use auto acknowlegde 
6056:  BTFSC  xE3.7
6058:  BRA    606C
605A:  MOVF   67,W
605C:  SUBLW  0F
605E:  BNZ   606C
6060:  BTFSC  xE1.7
6062:  BRA    606C
....................       { 
....................             TimeBase1s = 100 ;            //reload again 
6064:  MOVLW  64
6066:  MOVWF  19
....................             AutoAckDelayTime = AutoAckTime ; 
6068:  MOVFF  68,1A
....................       } 
....................  
....................       In2.B8 = 1; 
606C:  BSF    xE3.7
....................       if(Ack.B8 == 0) 
606E:  BTFSC  xE1.7
6070:  BRA    60A0
....................       { 
....................          if(FlashingFlag == 0) 
6072:  BTFSC  17.1
6074:  BRA    607A
....................             { 
....................                Output.B8 = 0;           //Flash output1 
6076:  BCF    xDB.7
....................             } 
....................             else 
6078:  BRA    607C
....................             { 
....................                Output.B8 = 1; 
607A:  BSF    xDB.7
....................             } 
....................          if (~AutoTestFlag) 
607C:  BTFSC  17.4
607E:  BRA    60A0
....................          { 
....................             if(AlarmIndicator.B8 == 1){ 
6080:  BTFSS  xE0.7
6082:  BRA    60A0
....................                 if(OutputBoth.B8 == 0)        //Both output 
6084:  BTFSC  xDF.7
6086:  BRA    6092
....................                 { 
....................                   output_bit(Pbuzzer,0);   //Buzzer 
6088:  BCF    F89.4
608A:  BCF    F92.4
....................                   output_bit(Pbell,0);     //Bell 
608C:  BCF    F89.3
608E:  BCF    F92.3
....................                 } 
....................                 else 
6090:  BRA    60A0
....................                 { 
....................                   if(OutputType.B8 == 1) output_bit(Pbuzzer,0);     //Buzzer 
6092:  BTFSS  xDE.7
6094:  BRA    609C
6096:  BCF    F89.4
6098:  BCF    F92.4
....................                   else output_bit(Pbell,0);                          //Bell 
609A:  BRA    60A0
609C:  BCF    F89.3
609E:  BCF    F92.3
....................                 } 
....................             } 
....................          } 
....................        } 
....................       inputflag =1; 
60A0:  MOVLW  01
60A2:  MOVLB  8
60A4:  MOVWF  x6C
....................        
....................       // SMS Sending    
....................       if((SendSMS.B8 ==0) && (functointest_f ==0) && (Ack.B8 ==0)) 
60A6:  MOVLB  7
60A8:  BTFSC  xE8.7
60AA:  BRA    6106
60AC:  BTFSC  2D.1
60AE:  BRA    6106
60B0:  BTFSC  xE1.7
60B2:  BRA    6106
....................       { 
....................          SendSMS.B8 =1; 
60B4:  BSF    xE8.7
....................          printf("AT+CMGS=\""); 
60B6:  MOVLW  5E
60B8:  MOVWF  FF6
60BA:  MOVLW  07
60BC:  MOVWF  FF7
60BE:  MOVLB  0
60C0:  CALL   1F28
....................          printf(sms_phonenumber); 
60C4:  MOVLW  06
60C6:  MOVWF  FEA
60C8:  MOVLW  83
60CA:  MOVWF  FE9
60CC:  CALL   448A
....................           
....................          printf("\""); 
60D0:  MOVLW  22
60D2:  CLRWDT
60D4:  BTFSS  F9E.4
60D6:  BRA    60D2
60D8:  MOVWF  FAD
....................          putc('\n'); 
60DA:  MOVLW  0A
60DC:  CALL   1F4C
....................          delay_ms(50); 
60E0:  MOVLW  32
60E2:  MOVLB  8
60E4:  MOVWF  x79
60E6:  MOVLB  0
60E8:  CALL   0772
....................          
....................         printf(SMS_Massage8);    
60EC:  MOVLW  07
60EE:  MOVWF  FEA
60F0:  MOVLW  B1
60F2:  MOVWF  FE9
60F4:  CALL   448A
....................         putc('\n'); 
60F8:  MOVLW  0A
60FA:  CALL   1F4C
....................         putc(26); 
60FE:  MOVLW  1A
6100:  CALL   1F4C
6104:  MOVLB  7
....................       } 
....................    } 
....................    else if(FaultType.B8 == 0) 
6106:  BRA    6192
6108:  MOVLB  7
610A:  BTFSC  xDD.7
610C:  BRA    6192
....................    { 
....................       In2.B8 = 0x00; 
610E:  BCF    xE3.7
....................       Ack.B8 = 0; 
6110:  BCF    xE1.7
....................       Output.B8 = 1;      //Off LED 
6112:  BSF    xDB.7
....................        
....................       SendSMS.B8 =0;// Clear SMS 
6114:  BCF    xE8.7
....................  
....................       if((OutputType.B8 == 1 || OutputBoth.B8 == 0)&& inputflag ==0)      //If Buzzer or Both 
6116:  BTFSC  xDE.7
6118:  BRA    611E
611A:  BTFSC  xDF.7
611C:  BRA    6140
611E:  MOVLB  8
6120:  MOVF   x6C,F
6122:  BTFSC  FD8.2
6124:  BRA    612A
6126:  MOVLB  7
6128:  BRA    6140
....................       { 
....................          if(CheckAutoReset(0x01) == 1);   //Check other Input "Ack" or not if not,do nothing 
612A:  MOVLW  01
612C:  MOVWF  x78
612E:  MOVLB  0
6130:  CALL   44B2
6134:  DECFSZ 01,W
6136:  BRA    613A
....................          else 
6138:  BRA    613E
....................          { 
....................             output_bit(Pbuzzer,1);   //Clear Buzzer 
613A:  BSF    F89.4
613C:  BCF    F92.4
613E:  MOVLB  7
....................          } 
....................       } 
....................  
....................  
....................       if((OutputType.B8 == 0 || OutputBoth.B8 == 0)&& inputflag ==0)  //If Bell or Both 
6140:  BTFSS  xDE.7
6142:  BRA    6148
6144:  BTFSC  xDF.7
6146:  BRA    616A
6148:  MOVLB  8
614A:  MOVF   x6C,F
614C:  BTFSC  FD8.2
614E:  BRA    6154
6150:  MOVLB  7
6152:  BRA    616A
....................       { 
....................          if(CheckAutoReset(0x02) == 1); 
6154:  MOVLW  02
6156:  MOVWF  x78
6158:  MOVLB  0
615A:  CALL   44B2
615E:  DECFSZ 01,W
6160:  BRA    6164
....................          else 
6162:  BRA    6168
....................          { 
....................             output_bit(Pbell,1);      //Clear Bell 
6164:  BSF    F89.3
6166:  BCF    F92.3
6168:  MOVLB  7
....................          } 
....................       } 
....................       // jj modify 
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0) 
616A:  BTFSC  xE3.0
616C:  BRA    6192
616E:  BTFSC  xE3.1
6170:  BRA    6192
6172:  BTFSC  xE3.2
6174:  BRA    6192
6176:  BTFSC  xE3.3
6178:  BRA    6192
617A:  BTFSC  xE3.4
617C:  BRA    6192
617E:  BTFSC  xE3.5
6180:  BRA    6192
6182:  BTFSC  xE3.6
6184:  BRA    6192
6186:  BTFSC  xE3.7
6188:  BRA    6192
....................       { 
....................          output_bit(Pbell,1);      //Clear Bell 
618A:  BSF    F89.3
618C:  BCF    F92.3
....................          output_bit(Pbuzzer,1);   //Clear Buzzer 
618E:  BSF    F89.4
6190:  BCF    F92.4
....................       } 
....................    } 
....................    ////////////////////////////////////////////////////////////////////////////////////////////////////    
....................     
....................  
.................... } 
6192:  MOVLB  0
6194:  RETLW  00
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void Send_Ouput(void) 
.................... { 
....................     Red1_7 = 0; 
*
1D4E:  CLRF   4B
....................     Red8_8 = 0; 
1D50:  CLRF   4C
....................     //Red9_15 = 0; 
....................     //Red16_16 = 0; 
....................  
....................     Green1_7 = 0; 
1D52:  CLRF   4F
....................     Green8_8 = 0; 
1D54:  CLRF   50
....................     //Green9_15 = 0; 
....................     //Green16_16 = 0; 
....................  
....................    if(T_test == 0x00) 
1D56:  MOVF   2C,F
1D58:  BTFSS  FD8.2
1D5A:  BRA    1F26
....................    { 
....................       //if(NoOfPoint >= 10) 
....................       //{ 
....................        
....................       
....................            if(Output.B1)//++++++++++++B1+++++++++++++++++++++ 
1D5C:  MOVLB  7
1D5E:  BTFSS  xDB.0
1D60:  BRA    1D68
....................            { 
....................              bit_clear(Red1_7,1); bit_clear(Green1_7,1); 
1D62:  BCF    4B.1
1D64:  BCF    4F.1
....................            } 
....................            else 
1D66:  BRA    1D90
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B1 )&&(GREEN_Colour.B1 ==0 ))//Red 
1D68:  BTFSS  xE6.0
1D6A:  BRA    1D76
1D6C:  BTFSC  xE7.0
1D6E:  BRA    1D76
....................              { 
....................                bit_set(Red1_7,1); bit_clear(Green1_7,1); 
1D70:  BSF    4B.1
1D72:  BCF    4F.1
....................              } 
....................              else if((RED_Colour.B1==0 )&&(GREEN_Colour.B1))//Green 
1D74:  BRA    1D90
1D76:  BTFSC  xE6.0
1D78:  BRA    1D84
1D7A:  BTFSS  xE7.0
1D7C:  BRA    1D84
....................              { 
....................                bit_clear(Red1_7,1); bit_set(Green1_7,1);  
1D7E:  BCF    4B.1
1D80:  BSF    4F.1
....................              } 
....................              else if((RED_Colour.B1)&&(GREEN_Colour.B1))//Ambian 
1D82:  BRA    1D90
1D84:  BTFSS  xE6.0
1D86:  BRA    1D90
1D88:  BTFSS  xE7.0
1D8A:  BRA    1D90
....................              { 
....................                bit_set(Red1_7,1); bit_set(Green1_7,1) ;  
1D8C:  BSF    4B.1
1D8E:  BSF    4F.1
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B2)//++++++++++++B2+++++++++++++++++++++ 
1D90:  BTFSS  xDB.1
1D92:  BRA    1D9A
....................            { 
....................              bit_clear(Red1_7,2); bit_clear(Green1_7,2); 
1D94:  BCF    4B.2
1D96:  BCF    4F.2
....................            } 
....................            else 
1D98:  BRA    1DC2
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B2 )&&(GREEN_Colour.B2 ==0 ))//Red 
1D9A:  BTFSS  xE6.1
1D9C:  BRA    1DA8
1D9E:  BTFSC  xE7.1
1DA0:  BRA    1DA8
....................              { 
....................                bit_set(Red1_7,2); bit_clear(Green1_7,2); 
1DA2:  BSF    4B.2
1DA4:  BCF    4F.2
....................              } 
....................              else if((RED_Colour.B2==0 )&&(GREEN_Colour.B2))//Green 
1DA6:  BRA    1DC2
1DA8:  BTFSC  xE6.1
1DAA:  BRA    1DB6
1DAC:  BTFSS  xE7.1
1DAE:  BRA    1DB6
....................              { 
....................                bit_clear(Red1_7,2); bit_set(Green1_7,2);  
1DB0:  BCF    4B.2
1DB2:  BSF    4F.2
....................              } 
....................              else if((RED_Colour.B2)&&(GREEN_Colour.B2))//Ambian 
1DB4:  BRA    1DC2
1DB6:  BTFSS  xE6.1
1DB8:  BRA    1DC2
1DBA:  BTFSS  xE7.1
1DBC:  BRA    1DC2
....................              { 
....................                bit_set(Red1_7,2); bit_set(Green1_7,2) ;  
1DBE:  BSF    4B.2
1DC0:  BSF    4F.2
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B3)//++++++++++++B3+++++++++++++++++++++ 
1DC2:  BTFSS  xDB.2
1DC4:  BRA    1DCC
....................            { 
....................              bit_clear(Red1_7,3); bit_clear(Green1_7,3); 
1DC6:  BCF    4B.3
1DC8:  BCF    4F.3
....................            } 
....................            else 
1DCA:  BRA    1DF4
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B3 )&&(GREEN_Colour.B3 ==0 ))//Red 
1DCC:  BTFSS  xE6.2
1DCE:  BRA    1DDA
1DD0:  BTFSC  xE7.2
1DD2:  BRA    1DDA
....................              { 
....................                bit_set(Red1_7,3); bit_clear(Green1_7,3); 
1DD4:  BSF    4B.3
1DD6:  BCF    4F.3
....................              } 
....................              else if((RED_Colour.B3==0 )&&(GREEN_Colour.B3))//Green 
1DD8:  BRA    1DF4
1DDA:  BTFSC  xE6.2
1DDC:  BRA    1DE8
1DDE:  BTFSS  xE7.2
1DE0:  BRA    1DE8
....................              { 
....................                bit_clear(Red1_7,3); bit_set(Green1_7,3);  
1DE2:  BCF    4B.3
1DE4:  BSF    4F.3
....................              } 
....................              else if((RED_Colour.B3)&&(GREEN_Colour.B3))//Ambian 
1DE6:  BRA    1DF4
1DE8:  BTFSS  xE6.2
1DEA:  BRA    1DF4
1DEC:  BTFSS  xE7.2
1DEE:  BRA    1DF4
....................              { 
....................                bit_set(Red1_7,3); bit_set(Green1_7,3) ;  
1DF0:  BSF    4B.3
1DF2:  BSF    4F.3
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B4)//++++++++++++B4+++++++++++++++++++++ 
1DF4:  BTFSS  xDB.3
1DF6:  BRA    1DFE
....................            { 
....................              bit_clear(Red1_7,4); bit_clear(Green1_7,4); 
1DF8:  BCF    4B.4
1DFA:  BCF    4F.4
....................            } 
....................            else 
1DFC:  BRA    1E26
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B4 )&&(GREEN_Colour.B4 ==0 ))//Red 
1DFE:  BTFSS  xE6.3
1E00:  BRA    1E0C
1E02:  BTFSC  xE7.3
1E04:  BRA    1E0C
....................              { 
....................                bit_set(Red1_7,4); bit_clear(Green1_7,4); 
1E06:  BSF    4B.4
1E08:  BCF    4F.4
....................              } 
....................              else if((RED_Colour.B4==0 )&&(GREEN_Colour.B4))//Green 
1E0A:  BRA    1E26
1E0C:  BTFSC  xE6.3
1E0E:  BRA    1E1A
1E10:  BTFSS  xE7.3
1E12:  BRA    1E1A
....................              { 
....................                bit_clear(Red1_7,4); bit_set(Green1_7,4);  
1E14:  BCF    4B.4
1E16:  BSF    4F.4
....................              } 
....................              else if((RED_Colour.B4)&&(GREEN_Colour.B4))//Ambian 
1E18:  BRA    1E26
1E1A:  BTFSS  xE6.3
1E1C:  BRA    1E26
1E1E:  BTFSS  xE7.3
1E20:  BRA    1E26
....................              { 
....................                bit_set(Red1_7,4); bit_set(Green1_7,4) ;  
1E22:  BSF    4B.4
1E24:  BSF    4F.4
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B5)//++++++++++++B5+++++++++++++++++++++ 
1E26:  BTFSS  xDB.4
1E28:  BRA    1E30
....................            { 
....................              bit_clear(Red1_7,5); bit_clear(Green1_7,5); 
1E2A:  BCF    4B.5
1E2C:  BCF    4F.5
....................            } 
....................            else 
1E2E:  BRA    1E58
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B5 )&&(GREEN_Colour.B5 ==0 ))//Red 
1E30:  BTFSS  xE6.4
1E32:  BRA    1E3E
1E34:  BTFSC  xE7.4
1E36:  BRA    1E3E
....................              { 
....................                bit_set(Red1_7,5); bit_clear(Green1_7,5); 
1E38:  BSF    4B.5
1E3A:  BCF    4F.5
....................              } 
....................              else if((RED_Colour.B5==0 )&&(GREEN_Colour.B5))//Green 
1E3C:  BRA    1E58
1E3E:  BTFSC  xE6.4
1E40:  BRA    1E4C
1E42:  BTFSS  xE7.4
1E44:  BRA    1E4C
....................              { 
....................                bit_clear(Red1_7,5); bit_set(Green1_7,5);  
1E46:  BCF    4B.5
1E48:  BSF    4F.5
....................              } 
....................              else if((RED_Colour.B5)&&(GREEN_Colour.B5))//Ambian 
1E4A:  BRA    1E58
1E4C:  BTFSS  xE6.4
1E4E:  BRA    1E58
1E50:  BTFSS  xE7.4
1E52:  BRA    1E58
....................              { 
....................                bit_set(Red1_7,5); bit_set(Green1_7,5) ;  
1E54:  BSF    4B.5
1E56:  BSF    4F.5
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B6)//++++++++++++B6+++++++++++++++++++++ 
1E58:  BTFSS  xDB.5
1E5A:  BRA    1E62
....................            { 
....................              bit_clear(Red1_7,6); bit_clear(Green1_7,6); 
1E5C:  BCF    4B.6
1E5E:  BCF    4F.6
....................            } 
....................            else 
1E60:  BRA    1E8A
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B6 )&&(GREEN_Colour.B6 ==0 ))//Red 
1E62:  BTFSS  xE6.5
1E64:  BRA    1E70
1E66:  BTFSC  xE7.5
1E68:  BRA    1E70
....................              { 
....................                bit_set(Red1_7,6); bit_clear(Green1_7,6); 
1E6A:  BSF    4B.6
1E6C:  BCF    4F.6
....................              } 
....................              else if((RED_Colour.B6==0 )&&(GREEN_Colour.B6))//Green 
1E6E:  BRA    1E8A
1E70:  BTFSC  xE6.5
1E72:  BRA    1E7E
1E74:  BTFSS  xE7.5
1E76:  BRA    1E7E
....................              { 
....................                bit_clear(Red1_7,6); bit_set(Green1_7,6);  
1E78:  BCF    4B.6
1E7A:  BSF    4F.6
....................              } 
....................              else if((RED_Colour.B6)&&(GREEN_Colour.B6))//Ambian 
1E7C:  BRA    1E8A
1E7E:  BTFSS  xE6.5
1E80:  BRA    1E8A
1E82:  BTFSS  xE7.5
1E84:  BRA    1E8A
....................              { 
....................                bit_set(Red1_7,6); bit_set(Green1_7,6) ;  
1E86:  BSF    4B.6
1E88:  BSF    4F.6
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B7)//++++++++++++B7+++++++++++++++++++++ 
1E8A:  BTFSS  xDB.6
1E8C:  BRA    1E94
....................            { 
....................              bit_clear(Red1_7,7); bit_clear(Green1_7,7); 
1E8E:  BCF    4B.7
1E90:  BCF    4F.7
....................            } 
....................            else 
1E92:  BRA    1EBC
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B7 )&&(GREEN_Colour.B7 ==0 ))//Red 
1E94:  BTFSS  xE6.6
1E96:  BRA    1EA2
1E98:  BTFSC  xE7.6
1E9A:  BRA    1EA2
....................              { 
....................                bit_set(Red1_7,7); bit_clear(Green1_7,7); 
1E9C:  BSF    4B.7
1E9E:  BCF    4F.7
....................              } 
....................              else if((RED_Colour.B7==0 )&&(GREEN_Colour.B7))//Green 
1EA0:  BRA    1EBC
1EA2:  BTFSC  xE6.6
1EA4:  BRA    1EB0
1EA6:  BTFSS  xE7.6
1EA8:  BRA    1EB0
....................              { 
....................                bit_clear(Red1_7,7); bit_set(Green1_7,7);  
1EAA:  BCF    4B.7
1EAC:  BSF    4F.7
....................              } 
....................              else if((RED_Colour.B7)&&(GREEN_Colour.B7))//Ambian 
1EAE:  BRA    1EBC
1EB0:  BTFSS  xE6.6
1EB2:  BRA    1EBC
1EB4:  BTFSS  xE7.6
1EB6:  BRA    1EBC
....................              { 
....................                bit_set(Red1_7,7); bit_set(Green1_7,7) ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
1EB8:  BSF    4B.7
1EBA:  BSF    4F.7
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................            if(Output.B8)//++++++++++++B8+++++++++++++++++++++ 
1EBC:  BTFSS  xDB.7
1EBE:  BRA    1EC6
....................            { 
....................              bit_clear(Red8_8,0); bit_clear(Green8_8,0); 
1EC0:  BCF    4C.0
1EC2:  BCF    50.0
....................            } 
....................            else 
1EC4:  BRA    1EEE
....................            { 
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0); 
....................              if((RED_Colour.B8 )&&(GREEN_Colour.B8 ==0 ))//Red 
1EC6:  BTFSS  xE6.7
1EC8:  BRA    1ED4
1ECA:  BTFSC  xE7.7
1ECC:  BRA    1ED4
....................              { 
....................                bit_set(Red8_8,0); bit_clear(Green8_8,0); 
1ECE:  BSF    4C.0
1ED0:  BCF    50.0
....................              } 
....................              else if((RED_Colour.B8==0 )&&(GREEN_Colour.B8))//Green 
1ED2:  BRA    1EEE
1ED4:  BTFSC  xE6.7
1ED6:  BRA    1EE2
1ED8:  BTFSS  xE7.7
1EDA:  BRA    1EE2
....................              { 
....................                bit_clear(Red8_8,0); bit_set(Green8_8,0);  
1EDC:  BCF    4C.0
1EDE:  BSF    50.0
....................              } 
....................              else if((RED_Colour.B8)&&(GREEN_Colour.B8))//Ambian 
1EE0:  BRA    1EEE
1EE2:  BTFSS  xE6.7
1EE4:  BRA    1EEE
1EE6:  BTFSS  xE7.7
1EE8:  BRA    1EEE
....................              { 
....................                bit_set(Red8_8,0); bit_set(Green8_8,0) ;  
1EEA:  BSF    4C.0
1EEC:  BSF    50.0
....................              }   
....................            } 
....................            //////////////////////////////////////////////////////// 
....................  
....................          
....................            IO_OUTPUT_A(IO_DEVICE_2, Red1_7); 
1EEE:  MOVLW  04
1EF0:  MOVLB  8
1EF2:  MOVWF  x78
1EF4:  MOVFF  4B,879
1EF8:  MOVLB  0
1EFA:  RCALL  1D22
....................            IO_OUTPUT_B(IO_DEVICE_2, Red8_8); 
1EFC:  MOVLW  04
1EFE:  MOVLB  8
1F00:  MOVWF  x78
1F02:  MOVFF  4C,879
1F06:  MOVLB  0
1F08:  RCALL  1D38
....................                        
....................            IO_OUTPUT_A(IO_DEVICE_3, Green1_7); 
1F0A:  MOVLW  06
1F0C:  MOVLB  8
1F0E:  MOVWF  x78
1F10:  MOVFF  4F,879
1F14:  MOVLB  0
1F16:  RCALL  1D22
....................            IO_OUTPUT_B(IO_DEVICE_3, Green8_8); 
1F18:  MOVLW  06
1F1A:  MOVLB  8
1F1C:  MOVWF  x78
1F1E:  MOVFF  50,879
1F22:  MOVLB  0
1F24:  RCALL  1D38
....................             
....................  
....................                                             
....................             
....................    } 
....................  
.................... } 
1F26:  RETLW  00
.................... ////////////////////////////////////////////////////////////////// 
.................... void ForceAllAlarm(void) 
.................... { 
....................    In.B1 = 1; 
*
4472:  MOVLB  7
4474:  BSF    xE2.0
....................    In.B2 = 1; 
4476:  BSF    xE2.1
....................    In.B3 = 1; 
4478:  BSF    xE2.2
....................    In.B4 = 1; 
447A:  BSF    xE2.3
....................    In.B5 = 1; 
447C:  BSF    xE2.4
....................    In.B6 = 1; 
447E:  BSF    xE2.5
....................    In.B7 = 1; 
4480:  BSF    xE2.6
....................    In.B8 = 1; 
4482:  BSF    xE2.7
....................       /* 
....................       Input.B1 = ~InputType.B1; 
....................       Input.B2 = ~InputType.B2; 
....................       Input.B3 = ~InputType.B3; 
....................       Input.B4 = ~InputType.B4; 
....................       Input.B5 = ~InputType.B5; 
....................       Input.B6 = ~InputType.B6; 
....................       Input.B7 = ~InputType.B7; 
....................       Input.B8 = ~InputType.B8; 
....................       Ack.B1 = 0; 
....................       Ack.B2 = 0; 
....................       Ack.B3 = 0; 
....................       Ack.B4 = 0; 
....................       Ack.B5 = 0; 
....................       Ack.B6 = 0; 
....................       Ack.B7 = 0; 
....................       Ack.B8 = 0; 
....................       */ 
....................    
.................... } 
4484:  MOVLB  0
4486:  GOTO   627C (RETURN)
....................  
....................  
....................  //////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  //////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... ///////////// Check Test //////////////// 
.................... void check_test(void) 
.................... { 
....................    int8 output_temp[8]; 
....................     
....................    output_temp[0] = Output1_8; 
*
6196:  MOVFF  2F,870
....................    output_temp[1] = output9_16; 
619A:  MOVFF  30,871
....................  
....................        if((input(Ptest) == 0 && Test == 0)|| AutoTestFlag == 1) delay_ms(50); 
619E:  BSF    F94.2
61A0:  BTFSC  F82.2
61A2:  BRA    61A8
61A4:  BTFSS  17.6
61A6:  BRA    61AC
61A8:  BTFSS  17.4
61AA:  BRA    61B8
61AC:  MOVLW  32
61AE:  MOVLB  8
61B0:  MOVWF  x79
61B2:  MOVLB  0
61B4:  CALL   0772
....................        if((input(Ptest) == 0 && Test == 0)|| AutoTestFlag == 1) 
61B8:  BSF    F94.2
61BA:  BTFSC  F82.2
61BC:  BRA    61C2
61BE:  BTFSS  17.6
61C0:  BRA    61C6
61C2:  BTFSS  17.4
61C4:  BRA    6262
....................        { 
....................            if((input(Ptest) == 0 && Test == 0)|| AutoTestFlag ==1) 
61C6:  BSF    F94.2
61C8:  BTFSC  F82.2
61CA:  BRA    61D0
61CC:  BTFSS  17.6
61CE:  BRA    61D4
61D0:  BTFSS  17.4
61D2:  BRA    6260
....................            { 
....................              restart_wdt(); 
61D4:  CLRWDT
....................              if(T_test == 0) T_test = 0x06;    //3 second for time base 500 ms 
61D6:  MOVF   2C,F
61D8:  BNZ   61DE
61DA:  MOVLW  06
61DC:  MOVWF  2C
....................               Test = 1; 
61DE:  BSF    17.6
....................               //if(NoOfPoint >= 16) 
....................              // { 
....................               
....................                  IO_OUTPUT_A(IO_DEVICE_2, 0xFF); 
61E0:  MOVLW  04
61E2:  MOVLB  8
61E4:  MOVWF  x78
61E6:  MOVLW  FF
61E8:  MOVWF  x79
61EA:  MOVLB  0
61EC:  CALL   1D22
....................                  IO_OUTPUT_B(IO_DEVICE_2, 0xFF); 
61F0:  MOVLW  04
61F2:  MOVLB  8
61F4:  MOVWF  x78
61F6:  MOVLW  FF
61F8:  MOVWF  x79
61FA:  MOVLB  0
61FC:  CALL   1D38
....................                              
....................                  IO_OUTPUT_A(IO_DEVICE_3, 0xFF); 
6200:  MOVLW  06
6202:  MOVLB  8
6204:  MOVWF  x78
6206:  MOVLW  FF
6208:  MOVWF  x79
620A:  MOVLB  0
620C:  CALL   1D22
....................                  IO_OUTPUT_B(IO_DEVICE_3, 0xFF); 
6210:  MOVLW  06
6212:  MOVLB  8
6214:  MOVWF  x78
6216:  MOVLW  FF
6218:  MOVWF  x79
621A:  MOVLB  0
621C:  CALL   1D38
....................                   
....................                  IO_OUTPUT_A(IO_DEVICE_4, 0xFF); 
6220:  MOVLW  08
6222:  MOVLB  8
6224:  MOVWF  x78
6226:  MOVLW  FF
6228:  MOVWF  x79
622A:  MOVLB  0
622C:  CALL   1D22
....................                  IO_OUTPUT_B(IO_DEVICE_4, 0xFF); 
6230:  MOVLW  08
6232:  MOVLB  8
6234:  MOVWF  x78
6236:  MOVLW  FF
6238:  MOVWF  x79
623A:  MOVLB  0
623C:  CALL   1D38
....................                             
....................                  IO_OUTPUT_A(IO_DEVICE_5, 0xFF); 
6240:  MOVLW  0A
6242:  MOVLB  8
6244:  MOVWF  x78
6246:  MOVLW  FF
6248:  MOVWF  x79
624A:  MOVLB  0
624C:  CALL   1D22
....................                  IO_OUTPUT_B(IO_DEVICE_5, 0xFF); 
6250:  MOVLW  0A
6252:  MOVLB  8
6254:  MOVWF  x78
6256:  MOVLW  FF
6258:  MOVWF  x79
625A:  MOVLB  0
625C:  CALL   1D38
....................  
....................               
....................            } 
....................           
....................        } 
....................        else if(input(Ptest) == 1 && Test == 1) 
6260:  BRA    6272
6262:  BSF    F94.2
6264:  BTFSS  F82.2
6266:  BRA    6272
6268:  BTFSS  17.6
626A:  BRA    6272
....................        { 
....................            T_test = 0x00; 
626C:  CLRF   2C
....................            Test = 0; 
626E:  BCF    17.6
....................            Test_fault = 0; 
6270:  BCF    17.5
....................        } 
....................        if(Test_fault == 1) 
6272:  BTFSS  17.5
6274:  BRA    628A
....................        { 
....................           functointest_f = 1; 
6276:  BSF    2D.1
....................           ForceAllAlarm(); 
6278:  GOTO   4472
....................           Anal_Function(); 
627C:  CALL   499A
....................           if(Input(Ptest) == 1) 
6280:  BSF    F94.2
6282:  BTFSS  F82.2
6284:  BRA    6288
....................           { 
....................             Test_fault = 0; 
6286:  BCF    17.5
....................           } 
....................        } 
....................        else if(input(Ptest) == 1 && Test == 1) 
6288:  BRA    62A0
628A:  BSF    F94.2
628C:  BTFSS  F82.2
628E:  BRA    62A0
6290:  BTFSS  17.6
6292:  BRA    62A0
....................        { 
....................           if(NoOfPoint >= 16) 
6294:  MOVF   6A,W
6296:  SUBLW  0F
6298:  BC    629A
....................           { 
....................  
....................           } 
....................            
....................  
....................           T_test = 0x00; 
629A:  CLRF   2C
....................           Test = 0; 
629C:  BCF    17.6
....................           Test_fault = 0; 
629E:  BCF    17.5
....................        } 
.................... } 
62A0:  GOTO   6AC2 (RETURN)
....................  
....................  
.................... /////////////// Check acknowledge //////////////////////////// 
....................  
.................... void check_ack(void) 
.................... { 
....................  
....................    if((input(Pack) == 0 && Ack_F == 0) || AutoAckFlag == 1) delay_ms(50); //Acknowledge function 
*
2170:  BSF    F94.0
2172:  BTFSC  F82.0
2174:  BRA    217A
2176:  BTFSS  17.7
2178:  BRA    217E
217A:  BTFSS  17.2
217C:  BRA    218A
217E:  MOVLW  32
2180:  MOVLB  8
2182:  MOVWF  x79
2184:  MOVLB  0
2186:  CALL   0772
....................    if((input(Pack) == 0 && Ack_F == 0) || AutoAckFlag == 1) 
218A:  BSF    F94.0
218C:  BTFSC  F82.0
218E:  BRA    2194
2190:  BTFSS  17.7
2192:  BRA    2198
2194:  BTFSS  17.2
2196:  BRA    2242
....................    { 
....................             AutoAckFlag = 0; 
2198:  BCF    17.2
....................             AutoAckDelayTime = 0x00; 
219A:  CLRF   1A
....................  
....................            if((In.B1 == 1 )||(In2.B1 == 1 )) 
219C:  MOVLB  7
219E:  BTFSC  xE2.0
21A0:  BRA    21A6
21A2:  BTFSS  xE3.0
21A4:  BRA    21B0
....................            { 
....................              Ack.B1 = 1; 
21A6:  BSF    xE1.0
....................              In.B1 = 0; 
21A8:  BCF    xE2.0
....................              In2.B1 = 0;      //for auto reset 
21AA:  BCF    xE3.0
....................              Output.B1 = 0; 
21AC:  BCF    xDB.0
....................              SendSMS.B1 =0; 
21AE:  BCF    xE8.0
....................            } 
....................  
....................            if((In.B2 == 1)||(In2.B2 == 1)) 
21B0:  BTFSC  xE2.1
21B2:  BRA    21B8
21B4:  BTFSS  xE3.1
21B6:  BRA    21C2
....................            { 
....................              Ack.B2 = 1; 
21B8:  BSF    xE1.1
....................              In.B2 = 0; 
21BA:  BCF    xE2.1
....................              In2.B2 = 0;      //for auto reset 
21BC:  BCF    xE3.1
....................              Output.B2 = 0; 
21BE:  BCF    xDB.1
....................              SendSMS.B2 =0; 
21C0:  BCF    xE8.1
....................            } 
....................  
....................            if((In.B3 == 1)||(In2.B3 == 1)) 
21C2:  BTFSC  xE2.2
21C4:  BRA    21CA
21C6:  BTFSS  xE3.2
21C8:  BRA    21D4
....................            { 
....................              Ack.B3 = 1; 
21CA:  BSF    xE1.2
....................              In.B3 = 0; 
21CC:  BCF    xE2.2
....................              In2.B3 = 0;      //for auto reset 
21CE:  BCF    xE3.2
....................              Output.B3 = 0; 
21D0:  BCF    xDB.2
....................              SendSMS.B3 =0; 
21D2:  BCF    xE8.2
....................            } 
....................  
....................            if((In.B4 == 1)||(In2.B4 == 1)) 
21D4:  BTFSC  xE2.3
21D6:  BRA    21DC
21D8:  BTFSS  xE3.3
21DA:  BRA    21E6
....................            { 
....................              Ack.B4 = 1; 
21DC:  BSF    xE1.3
....................              In.B4 = 0; 
21DE:  BCF    xE2.3
....................              In2.B4 = 0;      //for auto reset 
21E0:  BCF    xE3.3
....................              Output.B4 = 0; 
21E2:  BCF    xDB.3
....................              SendSMS.B4 =0; 
21E4:  BCF    xE8.3
....................            } 
....................  
....................            if((In.B5 == 1)||(In2.B5 == 1)) 
21E6:  BTFSC  xE2.4
21E8:  BRA    21EE
21EA:  BTFSS  xE3.4
21EC:  BRA    21F8
....................            { 
....................              Ack.B5 = 1; 
21EE:  BSF    xE1.4
....................              In.B5 = 0; 
21F0:  BCF    xE2.4
....................              In2.B5 = 0;      //for auto reset 
21F2:  BCF    xE3.4
....................              Output.B5 = 0; 
21F4:  BCF    xDB.4
....................              SendSMS.B5 =0; 
21F6:  BCF    xE8.4
....................            } 
....................  
....................            if((In.B6 == 1 )||(In2.B6 == 1 )) 
21F8:  BTFSC  xE2.5
21FA:  BRA    2200
21FC:  BTFSS  xE3.5
21FE:  BRA    220A
....................            { 
....................              Ack.B6 = 1; 
2200:  BSF    xE1.5
....................              In.B6 = 0; 
2202:  BCF    xE2.5
....................              In2.B6 = 0;      //for auto reset 
2204:  BCF    xE3.5
....................              Output.B6 = 0; 
2206:  BCF    xDB.5
....................              SendSMS.B6 =0; 
2208:  BCF    xE8.5
....................            } 
....................  
....................            if((In.B7 == 1 )||(In2.B7 == 1 )) 
220A:  BTFSC  xE2.6
220C:  BRA    2212
220E:  BTFSS  xE3.6
2210:  BRA    221C
....................            { 
....................              Ack.B7 = 1; 
2212:  BSF    xE1.6
....................              In.B7 = 0; 
2214:  BCF    xE2.6
....................              In2.B7 = 0;      //for auto reset 
2216:  BCF    xE3.6
....................              Output.B7 = 0; 
2218:  BCF    xDB.6
....................              SendSMS.B7 =0; 
221A:  BCF    xE8.6
....................            } 
....................  
....................            if((In.B8 == 1 )||(In2.B8 == 1 )) 
221C:  BTFSC  xE2.7
221E:  BRA    2224
2220:  BTFSS  xE3.7
2222:  BRA    222E
....................            { 
....................              Ack.B8 = 1; 
2224:  BSF    xE1.7
....................              In.B8 = 0; 
2226:  BCF    xE2.7
....................              In2.B8 = 0;      //for auto reset 
2228:  BCF    xE3.7
....................              Output.B8 = 0; 
222A:  BCF    xDB.7
....................              SendSMS.B8 =0; 
222C:  BCF    xE8.7
....................            } 
....................        
....................             if(functointest_f){ 
222E:  BTFSS  2D.1
2230:  BRA    2234
....................                functointest_f = 0; 
2232:  BCF    2D.1
....................             } 
....................             Ack_F = 1; 
2234:  BSF    17.7
....................             output_bit(Pbuzzer,1);   //Buzzer 
2236:  BSF    F89.4
2238:  BCF    F92.4
....................             output_bit(Pbell,1);     //Bell 
223A:  BSF    F89.3
223C:  BCF    F92.3
....................    } 
....................    else if(input(Pack) == 1 && Ack_F == 1) 
223E:  BRA    2250
2240:  MOVLB  0
2242:  BSF    F94.0
2244:  BTFSS  F82.0
2246:  BRA    224E
2248:  BTFSS  17.7
224A:  BRA    224E
....................    { 
....................       Ack_F = 0; 
224C:  BCF    17.7
224E:  MOVLB  7
....................    } 
....................  
.................... } 
2250:  MOVLB  0
2252:  RETLW  00
....................  
.................... ///////////////////// Check Reset /////////////////////////////////// 
.................... void check_reset(void) 
.................... { 
....................     if((input(Preset) == 0 && Reset_F == 0)|| AutoResetFlag ==1) delay_ms(50); 
2254:  BSF    F94.1
2256:  BTFSC  F82.1
2258:  BRA    225E
225A:  BTFSS  2D.0
225C:  BRA    2262
225E:  BTFSS  17.3
2260:  BRA    226E
2262:  MOVLW  32
2264:  MOVLB  8
2266:  MOVWF  x79
2268:  MOVLB  0
226A:  CALL   0772
....................     if((input(Preset) == 0 && Reset_F == 0)|| AutoResetFlag ==1) 
226E:  BSF    F94.1
2270:  BTFSC  F82.1
2272:  BRA    2278
2274:  BTFSS  2D.0
2276:  BRA    227C
2278:  BTFSS  17.3
227A:  BRA    23B6
....................     { 
....................        AutoResetFlag = 0; 
227C:  BCF    17.3
....................         
....................        if((Input.B1 ^ InputType.B1) == 0 && In.B1 == 0) Output.B1 = 1; 
227E:  MOVLW  00
2280:  MOVLB  7
2282:  BTFSC  xDA.0
2284:  MOVLW  01
2286:  MOVLB  8
2288:  MOVWF  x79
228A:  MOVLW  00
228C:  MOVLB  7
228E:  BTFSC  xDC.0
2290:  MOVLW  01
2292:  MOVLB  8
2294:  XORWF  x79,W
2296:  BNZ   22A4
2298:  MOVLB  7
229A:  BTFSS  xE2.0
229C:  BRA    22A2
229E:  MOVLB  8
22A0:  BRA    22A4
22A2:  BSF    xDB.0
....................        if((Input.B2 ^ InputType.B2) == 0 && In.B2 == 0) Output.B2 = 1; 
22A4:  MOVLW  00
22A6:  MOVLB  7
22A8:  BTFSC  xDA.1
22AA:  MOVLW  01
22AC:  MOVLB  8
22AE:  MOVWF  x79
22B0:  MOVLW  00
22B2:  MOVLB  7
22B4:  BTFSC  xDC.1
22B6:  MOVLW  01
22B8:  MOVLB  8
22BA:  XORWF  x79,W
22BC:  BNZ   22CA
22BE:  MOVLB  7
22C0:  BTFSS  xE2.1
22C2:  BRA    22C8
22C4:  MOVLB  8
22C6:  BRA    22CA
22C8:  BSF    xDB.1
....................        if((Input.B3 ^ InputType.B3) == 0 && In.B3 == 0) Output.B3 = 1; 
22CA:  MOVLW  00
22CC:  MOVLB  7
22CE:  BTFSC  xDA.2
22D0:  MOVLW  01
22D2:  MOVLB  8
22D4:  MOVWF  x79
22D6:  MOVLW  00
22D8:  MOVLB  7
22DA:  BTFSC  xDC.2
22DC:  MOVLW  01
22DE:  MOVLB  8
22E0:  XORWF  x79,W
22E2:  BNZ   22F0
22E4:  MOVLB  7
22E6:  BTFSS  xE2.2
22E8:  BRA    22EE
22EA:  MOVLB  8
22EC:  BRA    22F0
22EE:  BSF    xDB.2
....................        if((Input.B4 ^ InputType.B4) == 0 && In.B4 == 0) Output.B4 = 1; 
22F0:  MOVLW  00
22F2:  MOVLB  7
22F4:  BTFSC  xDA.3
22F6:  MOVLW  01
22F8:  MOVLB  8
22FA:  MOVWF  x79
22FC:  MOVLW  00
22FE:  MOVLB  7
2300:  BTFSC  xDC.3
2302:  MOVLW  01
2304:  MOVLB  8
2306:  XORWF  x79,W
2308:  BNZ   2316
230A:  MOVLB  7
230C:  BTFSS  xE2.3
230E:  BRA    2314
2310:  MOVLB  8
2312:  BRA    2316
2314:  BSF    xDB.3
....................        if((Input.B5 ^ InputType.B5) == 0 && In.B5 == 0) Output.B5 = 1; 
2316:  MOVLW  00
2318:  MOVLB  7
231A:  BTFSC  xDA.4
231C:  MOVLW  01
231E:  MOVLB  8
2320:  MOVWF  x79
2322:  MOVLW  00
2324:  MOVLB  7
2326:  BTFSC  xDC.4
2328:  MOVLW  01
232A:  MOVLB  8
232C:  XORWF  x79,W
232E:  BNZ   233C
2330:  MOVLB  7
2332:  BTFSS  xE2.4
2334:  BRA    233A
2336:  MOVLB  8
2338:  BRA    233C
233A:  BSF    xDB.4
....................        if((Input.B6 ^ InputType.B6) == 0 && In.B6 == 0) Output.B6 = 1; 
233C:  MOVLW  00
233E:  MOVLB  7
2340:  BTFSC  xDA.5
2342:  MOVLW  01
2344:  MOVLB  8
2346:  MOVWF  x79
2348:  MOVLW  00
234A:  MOVLB  7
234C:  BTFSC  xDC.5
234E:  MOVLW  01
2350:  MOVLB  8
2352:  XORWF  x79,W
2354:  BNZ   2362
2356:  MOVLB  7
2358:  BTFSS  xE2.5
235A:  BRA    2360
235C:  MOVLB  8
235E:  BRA    2362
2360:  BSF    xDB.5
....................        if((Input.B7 ^ InputType.B7) == 0 && In.B7 == 0) Output.B7 = 1; 
2362:  MOVLW  00
2364:  MOVLB  7
2366:  BTFSC  xDA.6
2368:  MOVLW  01
236A:  MOVLB  8
236C:  MOVWF  x79
236E:  MOVLW  00
2370:  MOVLB  7
2372:  BTFSC  xDC.6
2374:  MOVLW  01
2376:  MOVLB  8
2378:  XORWF  x79,W
237A:  BNZ   2388
237C:  MOVLB  7
237E:  BTFSS  xE2.6
2380:  BRA    2386
2382:  MOVLB  8
2384:  BRA    2388
2386:  BSF    xDB.6
....................        if((Input.B8 ^ InputType.B8) == 0 && In.B8 == 0) Output.B8 = 1; 
2388:  MOVLW  00
238A:  MOVLB  7
238C:  BTFSC  xDA.7
238E:  MOVLW  01
2390:  MOVLB  8
2392:  MOVWF  x79
2394:  MOVLW  00
2396:  MOVLB  7
2398:  BTFSC  xDC.7
239A:  MOVLW  01
239C:  MOVLB  8
239E:  XORWF  x79,W
23A0:  BNZ   23B0
23A2:  MOVLB  7
23A4:  BTFSS  xE2.7
23A6:  BRA    23AC
23A8:  MOVLB  8
23AA:  BRA    23B0
23AC:  BSF    xDB.7
23AE:  MOVLB  8
....................  
....................  
....................        Reset_F = 1; 
23B0:  BSF    2D.0
....................         
....................         
....................  
....................         
....................     } 
....................     else if(input(Preset) == 1 && Reset_F == 1) 
23B2:  BRA    23C4
23B4:  MOVLB  0
23B6:  BSF    F94.1
23B8:  BTFSS  F82.1
23BA:  BRA    23C2
23BC:  BTFSS  2D.0
23BE:  BRA    23C2
....................     { 
....................        Reset_F = 0; 
23C0:  BCF    2D.0
23C2:  MOVLB  8
....................     } 
.................... } 
23C4:  MOVLB  0
23C6:  RETLW  00
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /////////////////////// Check Auto Reset function /////////////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////////// 
.................... int1 CheckAutoReset(unsigned char DatType) 
.................... { 
....................    int1 check;     /// "1" = true  //Other Alarm active or not "ACK" 
....................  
....................    if(DatType == 0x01) // Buzzer 
*
44B2:  MOVLB  8
44B4:  DECFSZ x78,W
44B6:  BRA    4720
....................    { 
....................       check = (In.B1 | In2.B1) & ~Ack.B1 & (OutputType.B1 | OutputBoth.B1); 
44B8:  MOVLW  00
44BA:  MOVLB  7
44BC:  BTFSC  xE2.0
44BE:  MOVLW  01
44C0:  MOVLB  8
44C2:  MOVWF  x7A
44C4:  MOVLW  00
44C6:  MOVLB  7
44C8:  BTFSC  xE3.0
44CA:  MOVLW  01
44CC:  MOVLB  8
44CE:  IORWF  x7A,F
44D0:  MOVLW  00
44D2:  MOVLB  7
44D4:  BTFSS  xE1.0
44D6:  MOVLW  01
44D8:  MOVLB  8
44DA:  ANDWF  x7A,F
44DC:  MOVLW  00
44DE:  MOVLB  7
44E0:  BTFSC  xDE.0
44E2:  MOVLW  01
44E4:  MOVLB  8
44E6:  MOVWF  x7B
44E8:  MOVLW  00
44EA:  MOVLB  7
44EC:  BTFSC  xDF.0
44EE:  MOVLW  01
44F0:  MOVLB  8
44F2:  IORWF  x7B,W
44F4:  ANDWF  x7A,W
44F6:  BCF    x79.0
44F8:  BTFSC  FE8.0
44FA:  BSF    x79.0
....................       check = check | ((In.B2 | In2.B2) & ~Ack.B2 & (OutputType.B2 | OutputBoth.B2)); 
44FC:  MOVLW  00
44FE:  BTFSC  x79.0
4500:  MOVLW  01
4502:  MOVWF  x7A
4504:  MOVLW  00
4506:  MOVLB  7
4508:  BTFSC  xE2.1
450A:  MOVLW  01
450C:  MOVLB  8
450E:  MOVWF  x7B
4510:  MOVLW  00
4512:  MOVLB  7
4514:  BTFSC  xE3.1
4516:  MOVLW  01
4518:  MOVLB  8
451A:  IORWF  x7B,F
451C:  MOVLW  00
451E:  MOVLB  7
4520:  BTFSS  xE1.1
4522:  MOVLW  01
4524:  MOVLB  8
4526:  ANDWF  x7B,F
4528:  MOVLW  00
452A:  MOVLB  7
452C:  BTFSC  xDE.1
452E:  MOVLW  01
4530:  MOVLB  8
4532:  MOVWF  x7C
4534:  MOVLW  00
4536:  MOVLB  7
4538:  BTFSC  xDF.1
453A:  MOVLW  01
453C:  MOVLB  8
453E:  IORWF  x7C,W
4540:  ANDWF  x7B,W
4542:  IORWF  x7A,W
4544:  BCF    x79.0
4546:  BTFSC  FE8.0
4548:  BSF    x79.0
....................       check = check | ((In.B3 | In2.B3) & ~Ack.B3 & (OutputType.B3 | OutputBoth.B3)); 
454A:  MOVLW  00
454C:  BTFSC  x79.0
454E:  MOVLW  01
4550:  MOVWF  x7A
4552:  MOVLW  00
4554:  MOVLB  7
4556:  BTFSC  xE2.2
4558:  MOVLW  01
455A:  MOVLB  8
455C:  MOVWF  x7B
455E:  MOVLW  00
4560:  MOVLB  7
4562:  BTFSC  xE3.2
4564:  MOVLW  01
4566:  MOVLB  8
4568:  IORWF  x7B,F
456A:  MOVLW  00
456C:  MOVLB  7
456E:  BTFSS  xE1.2
4570:  MOVLW  01
4572:  MOVLB  8
4574:  ANDWF  x7B,F
4576:  MOVLW  00
4578:  MOVLB  7
457A:  BTFSC  xDE.2
457C:  MOVLW  01
457E:  MOVLB  8
4580:  MOVWF  x7C
4582:  MOVLW  00
4584:  MOVLB  7
4586:  BTFSC  xDF.2
4588:  MOVLW  01
458A:  MOVLB  8
458C:  IORWF  x7C,W
458E:  ANDWF  x7B,W
4590:  IORWF  x7A,W
4592:  BCF    x79.0
4594:  BTFSC  FE8.0
4596:  BSF    x79.0
....................       check = check | ((In.B4 | In2.B4) & ~Ack.B4 & (OutputType.B4 | OutputBoth.B4)); 
4598:  MOVLW  00
459A:  BTFSC  x79.0
459C:  MOVLW  01
459E:  MOVWF  x7A
45A0:  MOVLW  00
45A2:  MOVLB  7
45A4:  BTFSC  xE2.3
45A6:  MOVLW  01
45A8:  MOVLB  8
45AA:  MOVWF  x7B
45AC:  MOVLW  00
45AE:  MOVLB  7
45B0:  BTFSC  xE3.3
45B2:  MOVLW  01
45B4:  MOVLB  8
45B6:  IORWF  x7B,F
45B8:  MOVLW  00
45BA:  MOVLB  7
45BC:  BTFSS  xE1.3
45BE:  MOVLW  01
45C0:  MOVLB  8
45C2:  ANDWF  x7B,F
45C4:  MOVLW  00
45C6:  MOVLB  7
45C8:  BTFSC  xDE.3
45CA:  MOVLW  01
45CC:  MOVLB  8
45CE:  MOVWF  x7C
45D0:  MOVLW  00
45D2:  MOVLB  7
45D4:  BTFSC  xDF.3
45D6:  MOVLW  01
45D8:  MOVLB  8
45DA:  IORWF  x7C,W
45DC:  ANDWF  x7B,W
45DE:  IORWF  x7A,W
45E0:  BCF    x79.0
45E2:  BTFSC  FE8.0
45E4:  BSF    x79.0
....................       check = check | ((In.B5 | In2.B5) & ~Ack.B5 & (OutputType.B5 | OutputBoth.B5)); 
45E6:  MOVLW  00
45E8:  BTFSC  x79.0
45EA:  MOVLW  01
45EC:  MOVWF  x7A
45EE:  MOVLW  00
45F0:  MOVLB  7
45F2:  BTFSC  xE2.4
45F4:  MOVLW  01
45F6:  MOVLB  8
45F8:  MOVWF  x7B
45FA:  MOVLW  00
45FC:  MOVLB  7
45FE:  BTFSC  xE3.4
4600:  MOVLW  01
4602:  MOVLB  8
4604:  IORWF  x7B,F
4606:  MOVLW  00
4608:  MOVLB  7
460A:  BTFSS  xE1.4
460C:  MOVLW  01
460E:  MOVLB  8
4610:  ANDWF  x7B,F
4612:  MOVLW  00
4614:  MOVLB  7
4616:  BTFSC  xDE.4
4618:  MOVLW  01
461A:  MOVLB  8
461C:  MOVWF  x7C
461E:  MOVLW  00
4620:  MOVLB  7
4622:  BTFSC  xDF.4
4624:  MOVLW  01
4626:  MOVLB  8
4628:  IORWF  x7C,W
462A:  ANDWF  x7B,W
462C:  IORWF  x7A,W
462E:  BCF    x79.0
4630:  BTFSC  FE8.0
4632:  BSF    x79.0
....................       check = check | ((In.B6 | In2.B6) & ~Ack.B6 & (OutputType.B6 | OutputBoth.B6)); 
4634:  MOVLW  00
4636:  BTFSC  x79.0
4638:  MOVLW  01
463A:  MOVWF  x7A
463C:  MOVLW  00
463E:  MOVLB  7
4640:  BTFSC  xE2.5
4642:  MOVLW  01
4644:  MOVLB  8
4646:  MOVWF  x7B
4648:  MOVLW  00
464A:  MOVLB  7
464C:  BTFSC  xE3.5
464E:  MOVLW  01
4650:  MOVLB  8
4652:  IORWF  x7B,F
4654:  MOVLW  00
4656:  MOVLB  7
4658:  BTFSS  xE1.5
465A:  MOVLW  01
465C:  MOVLB  8
465E:  ANDWF  x7B,F
4660:  MOVLW  00
4662:  MOVLB  7
4664:  BTFSC  xDE.5
4666:  MOVLW  01
4668:  MOVLB  8
466A:  MOVWF  x7C
466C:  MOVLW  00
466E:  MOVLB  7
4670:  BTFSC  xDF.5
4672:  MOVLW  01
4674:  MOVLB  8
4676:  IORWF  x7C,W
4678:  ANDWF  x7B,W
467A:  IORWF  x7A,W
467C:  BCF    x79.0
467E:  BTFSC  FE8.0
4680:  BSF    x79.0
....................       check = check | ((In.B7 | In2.B7) & ~Ack.B7 & (OutputType.B7 | OutputBoth.B7)); 
4682:  MOVLW  00
4684:  BTFSC  x79.0
4686:  MOVLW  01
4688:  MOVWF  x7A
468A:  MOVLW  00
468C:  MOVLB  7
468E:  BTFSC  xE2.6
4690:  MOVLW  01
4692:  MOVLB  8
4694:  MOVWF  x7B
4696:  MOVLW  00
4698:  MOVLB  7
469A:  BTFSC  xE3.6
469C:  MOVLW  01
469E:  MOVLB  8
46A0:  IORWF  x7B,F
46A2:  MOVLW  00
46A4:  MOVLB  7
46A6:  BTFSS  xE1.6
46A8:  MOVLW  01
46AA:  MOVLB  8
46AC:  ANDWF  x7B,F
46AE:  MOVLW  00
46B0:  MOVLB  7
46B2:  BTFSC  xDE.6
46B4:  MOVLW  01
46B6:  MOVLB  8
46B8:  MOVWF  x7C
46BA:  MOVLW  00
46BC:  MOVLB  7
46BE:  BTFSC  xDF.6
46C0:  MOVLW  01
46C2:  MOVLB  8
46C4:  IORWF  x7C,W
46C6:  ANDWF  x7B,W
46C8:  IORWF  x7A,W
46CA:  BCF    x79.0
46CC:  BTFSC  FE8.0
46CE:  BSF    x79.0
....................       check = check | ((In.B8 | In2.B8) & ~Ack.B8 & (OutputType.B8 | OutputBoth.B8)); 
46D0:  MOVLW  00
46D2:  BTFSC  x79.0
46D4:  MOVLW  01
46D6:  MOVWF  x7A
46D8:  MOVLW  00
46DA:  MOVLB  7
46DC:  BTFSC  xE2.7
46DE:  MOVLW  01
46E0:  MOVLB  8
46E2:  MOVWF  x7B
46E4:  MOVLW  00
46E6:  MOVLB  7
46E8:  BTFSC  xE3.7
46EA:  MOVLW  01
46EC:  MOVLB  8
46EE:  IORWF  x7B,F
46F0:  MOVLW  00
46F2:  MOVLB  7
46F4:  BTFSS  xE1.7
46F6:  MOVLW  01
46F8:  MOVLB  8
46FA:  ANDWF  x7B,F
46FC:  MOVLW  00
46FE:  MOVLB  7
4700:  BTFSC  xDE.7
4702:  MOVLW  01
4704:  MOVLB  8
4706:  MOVWF  x7C
4708:  MOVLW  00
470A:  MOVLB  7
470C:  BTFSC  xDF.7
470E:  MOVLW  01
4710:  MOVLB  8
4712:  IORWF  x7C,W
4714:  ANDWF  x7B,W
4716:  IORWF  x7A,W
4718:  BCF    x79.0
471A:  BTFSC  FE8.0
471C:  BSF    x79.0
....................  
....................       
....................    } 
....................    else if(DatType == 0x02)             //Bell 
471E:  BRA    498E
4720:  MOVF   x78,W
4722:  SUBLW  02
4724:  BTFSS  FD8.2
4726:  BRA    498E
....................    { 
....................       check = (In.B1 | In2.B1) & ~Ack.B1 & (~OutputType.B1 | OutputBoth.B1); 
4728:  MOVLW  00
472A:  MOVLB  7
472C:  BTFSC  xE2.0
472E:  MOVLW  01
4730:  MOVLB  8
4732:  MOVWF  x7A
4734:  MOVLW  00
4736:  MOVLB  7
4738:  BTFSC  xE3.0
473A:  MOVLW  01
473C:  MOVLB  8
473E:  IORWF  x7A,F
4740:  MOVLW  00
4742:  MOVLB  7
4744:  BTFSS  xE1.0
4746:  MOVLW  01
4748:  MOVLB  8
474A:  ANDWF  x7A,F
474C:  MOVLW  00
474E:  MOVLB  7
4750:  BTFSS  xDE.0
4752:  MOVLW  01
4754:  MOVLB  8
4756:  MOVWF  x7B
4758:  MOVLW  00
475A:  MOVLB  7
475C:  BTFSC  xDF.0
475E:  MOVLW  01
4760:  MOVLB  8
4762:  IORWF  x7B,W
4764:  ANDWF  x7A,W
4766:  BCF    x79.0
4768:  BTFSC  FE8.0
476A:  BSF    x79.0
....................       check = check | ((In.B2 | In2.B2) & ~Ack.B2 & (~OutputType.B2 | OutputBoth.B2)); 
476C:  MOVLW  00
476E:  BTFSC  x79.0
4770:  MOVLW  01
4772:  MOVWF  x7A
4774:  MOVLW  00
4776:  MOVLB  7
4778:  BTFSC  xE2.1
477A:  MOVLW  01
477C:  MOVLB  8
477E:  MOVWF  x7B
4780:  MOVLW  00
4782:  MOVLB  7
4784:  BTFSC  xE3.1
4786:  MOVLW  01
4788:  MOVLB  8
478A:  IORWF  x7B,F
478C:  MOVLW  00
478E:  MOVLB  7
4790:  BTFSS  xE1.1
4792:  MOVLW  01
4794:  MOVLB  8
4796:  ANDWF  x7B,F
4798:  MOVLW  00
479A:  MOVLB  7
479C:  BTFSS  xDE.1
479E:  MOVLW  01
47A0:  MOVLB  8
47A2:  MOVWF  x7C
47A4:  MOVLW  00
47A6:  MOVLB  7
47A8:  BTFSC  xDF.1
47AA:  MOVLW  01
47AC:  MOVLB  8
47AE:  IORWF  x7C,W
47B0:  ANDWF  x7B,W
47B2:  IORWF  x7A,W
47B4:  BCF    x79.0
47B6:  BTFSC  FE8.0
47B8:  BSF    x79.0
....................       check = check | ((In.B3 | In2.B3) & ~Ack.B3 & (~OutputType.B3 | OutputBoth.B3)); 
47BA:  MOVLW  00
47BC:  BTFSC  x79.0
47BE:  MOVLW  01
47C0:  MOVWF  x7A
47C2:  MOVLW  00
47C4:  MOVLB  7
47C6:  BTFSC  xE2.2
47C8:  MOVLW  01
47CA:  MOVLB  8
47CC:  MOVWF  x7B
47CE:  MOVLW  00
47D0:  MOVLB  7
47D2:  BTFSC  xE3.2
47D4:  MOVLW  01
47D6:  MOVLB  8
47D8:  IORWF  x7B,F
47DA:  MOVLW  00
47DC:  MOVLB  7
47DE:  BTFSS  xE1.2
47E0:  MOVLW  01
47E2:  MOVLB  8
47E4:  ANDWF  x7B,F
47E6:  MOVLW  00
47E8:  MOVLB  7
47EA:  BTFSS  xDE.2
47EC:  MOVLW  01
47EE:  MOVLB  8
47F0:  MOVWF  x7C
47F2:  MOVLW  00
47F4:  MOVLB  7
47F6:  BTFSC  xDF.2
47F8:  MOVLW  01
47FA:  MOVLB  8
47FC:  IORWF  x7C,W
47FE:  ANDWF  x7B,W
4800:  IORWF  x7A,W
4802:  BCF    x79.0
4804:  BTFSC  FE8.0
4806:  BSF    x79.0
....................       check = check | ((In.B4 | In2.B4) & ~Ack.B4 & (~OutputType.B4 | OutputBoth.B4)); 
4808:  MOVLW  00
480A:  BTFSC  x79.0
480C:  MOVLW  01
480E:  MOVWF  x7A
4810:  MOVLW  00
4812:  MOVLB  7
4814:  BTFSC  xE2.3
4816:  MOVLW  01
4818:  MOVLB  8
481A:  MOVWF  x7B
481C:  MOVLW  00
481E:  MOVLB  7
4820:  BTFSC  xE3.3
4822:  MOVLW  01
4824:  MOVLB  8
4826:  IORWF  x7B,F
4828:  MOVLW  00
482A:  MOVLB  7
482C:  BTFSS  xE1.3
482E:  MOVLW  01
4830:  MOVLB  8
4832:  ANDWF  x7B,F
4834:  MOVLW  00
4836:  MOVLB  7
4838:  BTFSS  xDE.3
483A:  MOVLW  01
483C:  MOVLB  8
483E:  MOVWF  x7C
4840:  MOVLW  00
4842:  MOVLB  7
4844:  BTFSC  xDF.3
4846:  MOVLW  01
4848:  MOVLB  8
484A:  IORWF  x7C,W
484C:  ANDWF  x7B,W
484E:  IORWF  x7A,W
4850:  BCF    x79.0
4852:  BTFSC  FE8.0
4854:  BSF    x79.0
....................       check = check | ((In.B5 | In2.B5) & ~Ack.B5 & (~OutputType.B5 | OutputBoth.B5)); 
4856:  MOVLW  00
4858:  BTFSC  x79.0
485A:  MOVLW  01
485C:  MOVWF  x7A
485E:  MOVLW  00
4860:  MOVLB  7
4862:  BTFSC  xE2.4
4864:  MOVLW  01
4866:  MOVLB  8
4868:  MOVWF  x7B
486A:  MOVLW  00
486C:  MOVLB  7
486E:  BTFSC  xE3.4
4870:  MOVLW  01
4872:  MOVLB  8
4874:  IORWF  x7B,F
4876:  MOVLW  00
4878:  MOVLB  7
487A:  BTFSS  xE1.4
487C:  MOVLW  01
487E:  MOVLB  8
4880:  ANDWF  x7B,F
4882:  MOVLW  00
4884:  MOVLB  7
4886:  BTFSS  xDE.4
4888:  MOVLW  01
488A:  MOVLB  8
488C:  MOVWF  x7C
488E:  MOVLW  00
4890:  MOVLB  7
4892:  BTFSC  xDF.4
4894:  MOVLW  01
4896:  MOVLB  8
4898:  IORWF  x7C,W
489A:  ANDWF  x7B,W
489C:  IORWF  x7A,W
489E:  BCF    x79.0
48A0:  BTFSC  FE8.0
48A2:  BSF    x79.0
....................       check = check | ((In.B6 | In2.B6) & ~Ack.B6 & (~OutputType.B6 | OutputBoth.B6)); 
48A4:  MOVLW  00
48A6:  BTFSC  x79.0
48A8:  MOVLW  01
48AA:  MOVWF  x7A
48AC:  MOVLW  00
48AE:  MOVLB  7
48B0:  BTFSC  xE2.5
48B2:  MOVLW  01
48B4:  MOVLB  8
48B6:  MOVWF  x7B
48B8:  MOVLW  00
48BA:  MOVLB  7
48BC:  BTFSC  xE3.5
48BE:  MOVLW  01
48C0:  MOVLB  8
48C2:  IORWF  x7B,F
48C4:  MOVLW  00
48C6:  MOVLB  7
48C8:  BTFSS  xE1.5
48CA:  MOVLW  01
48CC:  MOVLB  8
48CE:  ANDWF  x7B,F
48D0:  MOVLW  00
48D2:  MOVLB  7
48D4:  BTFSS  xDE.5
48D6:  MOVLW  01
48D8:  MOVLB  8
48DA:  MOVWF  x7C
48DC:  MOVLW  00
48DE:  MOVLB  7
48E0:  BTFSC  xDF.5
48E2:  MOVLW  01
48E4:  MOVLB  8
48E6:  IORWF  x7C,W
48E8:  ANDWF  x7B,W
48EA:  IORWF  x7A,W
48EC:  BCF    x79.0
48EE:  BTFSC  FE8.0
48F0:  BSF    x79.0
....................       check = check | ((In.B7 | In2.B7) & ~Ack.B7 & (~OutputType.B7 | OutputBoth.B7)); 
48F2:  MOVLW  00
48F4:  BTFSC  x79.0
48F6:  MOVLW  01
48F8:  MOVWF  x7A
48FA:  MOVLW  00
48FC:  MOVLB  7
48FE:  BTFSC  xE2.6
4900:  MOVLW  01
4902:  MOVLB  8
4904:  MOVWF  x7B
4906:  MOVLW  00
4908:  MOVLB  7
490A:  BTFSC  xE3.6
490C:  MOVLW  01
490E:  MOVLB  8
4910:  IORWF  x7B,F
4912:  MOVLW  00
4914:  MOVLB  7
4916:  BTFSS  xE1.6
4918:  MOVLW  01
491A:  MOVLB  8
491C:  ANDWF  x7B,F
491E:  MOVLW  00
4920:  MOVLB  7
4922:  BTFSS  xDE.6
4924:  MOVLW  01
4926:  MOVLB  8
4928:  MOVWF  x7C
492A:  MOVLW  00
492C:  MOVLB  7
492E:  BTFSC  xDF.6
4930:  MOVLW  01
4932:  MOVLB  8
4934:  IORWF  x7C,W
4936:  ANDWF  x7B,W
4938:  IORWF  x7A,W
493A:  BCF    x79.0
493C:  BTFSC  FE8.0
493E:  BSF    x79.0
....................       check = check | ((In.B8 | In2.B8) & ~Ack.B8 & (~OutputType.B8 | OutputBoth.B8)); 
4940:  MOVLW  00
4942:  BTFSC  x79.0
4944:  MOVLW  01
4946:  MOVWF  x7A
4948:  MOVLW  00
494A:  MOVLB  7
494C:  BTFSC  xE2.7
494E:  MOVLW  01
4950:  MOVLB  8
4952:  MOVWF  x7B
4954:  MOVLW  00
4956:  MOVLB  7
4958:  BTFSC  xE3.7
495A:  MOVLW  01
495C:  MOVLB  8
495E:  IORWF  x7B,F
4960:  MOVLW  00
4962:  MOVLB  7
4964:  BTFSS  xE1.7
4966:  MOVLW  01
4968:  MOVLB  8
496A:  ANDWF  x7B,F
496C:  MOVLW  00
496E:  MOVLB  7
4970:  BTFSS  xDE.7
4972:  MOVLW  01
4974:  MOVLB  8
4976:  MOVWF  x7C
4978:  MOVLW  00
497A:  MOVLB  7
497C:  BTFSC  xDF.7
497E:  MOVLW  01
4980:  MOVLB  8
4982:  IORWF  x7C,W
4984:  ANDWF  x7B,W
4986:  IORWF  x7A,W
4988:  BCF    x79.0
498A:  BTFSC  FE8.0
498C:  BSF    x79.0
....................  
....................  
....................    } 
....................    return(check); 
498E:  MOVLW  00
4990:  BTFSC  x79.0
4992:  MOVLW  01
4994:  MOVWF  01
.................... } 
4996:  MOVLB  0
4998:  RETLW  00
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... void main() 
.................... { 
*
63B6:  CLRF   FF8
63B8:  BCF    FD0.7
63BA:  BSF    07.7
63BC:  CLRF   FEA
63BE:  CLRF   FE9
63C0:  BSF    FB8.3
63C2:  MOVLW  08
63C4:  MOVWF  FAF
63C6:  MOVLW  02
63C8:  MOVWF  FB0
63CA:  MOVLW  A6
63CC:  MOVWF  FAC
63CE:  MOVLW  90
63D0:  MOVWF  FAB
63D2:  CLRF   16
63D4:  BCF    17.0
63D6:  MOVLW  19
63D8:  MOVWF  18
63DA:  BCF    17.1
63DC:  MOVLW  64
63DE:  MOVWF  19
63E0:  CLRF   1A
63E2:  BCF    17.2
63E4:  BCF    17.3
63E6:  BCF    17.4
63E8:  CLRF   2B
63EA:  BCF    17.5
63EC:  CLRF   2C
63EE:  BCF    17.6
63F0:  BCF    17.7
63F2:  BCF    2D.0
63F4:  BCF    2D.1
63F6:  BCF    2D.2
63F8:  BCF    2D.3
63FA:  CLRF   2E
63FC:  BCF    2D.4
63FE:  MOVLW  11
6400:  MOVWF  6C
6402:  MOVLW  12
6404:  MOVWF  6D
6406:  MOVLW  13
6408:  MOVWF  6E
640A:  MOVLW  14
640C:  MOVWF  6F
640E:  MOVLW  16
6410:  MOVWF  70
6412:  MOVLW  17
6414:  MOVWF  71
6416:  MOVLW  19
6418:  MOVWF  72
641A:  MOVLW  20
641C:  MOVWF  73
641E:  BCF    2D.5
6420:  CLRF   76
6422:  MOVLW  01
6424:  MOVLB  5
6426:  MOVWF  x79
6428:  MOVLW  F4
642A:  MOVWF  x78
642C:  CLRF   x7B
642E:  CLRF   x7A
6430:  CLRF   x7D
6432:  CLRF   x7C
6434:  CLRF   x7E
6436:  MOVLB  6
6438:  CLRF   x81
643A:  CLRF   x82
643C:  MOVLB  8
643E:  CLRF   x6C
6440:  MOVF   FC1,W
6442:  ANDLW  C0
6444:  IORLW  0F
6446:  MOVWF  FC1
6448:  MOVLW  07
644A:  MOVWF  FB4
....................     
....................     
....................    delay_ms(50); 
644C:  MOVLW  32
644E:  MOVWF  x79
6450:  MOVLB  0
6452:  CALL   0772
....................    output_bit(Pled,0);   //power on watchdog signal 
6456:  BCF    F8A.5
6458:  BCF    F93.5
....................  
....................    setup_adc_ports(NO_ANALOGS|VSS_VDD); 
645A:  MOVF   FC1,W
645C:  ANDLW  C0
645E:  IORLW  0F
6460:  MOVWF  FC1
....................    setup_adc(ADC_OFF|ADC_TAD_MUL_0); 
6462:  BCF    FC2.0
....................    //setup_spi(FALSE); 
....................     
....................    setup_timer_0(RTCC_INTERNAL); 
6464:  MOVLW  80
6466:  MOVWF  FD5
....................    //setup_timer_1(T1_DISABLED); 
....................    setup_timer_2(T2_DIV_BY_16,196,16);         //10ms 
6468:  MOVLW  78
646A:  IORLW  06
646C:  MOVWF  FCA
646E:  MOVLW  C4
6470:  MOVWF  FCB
....................    //setup_timer_3(T3_DISABLED|T3_DIV_BY_1); 
....................    //setup_comparator(NC_NC_NC_NC); 
....................    //setup_vref(FALSE); 
....................    enable_interrupts(INT_TIMER2); 
6472:  BSF    F9D.1
....................    enable_interrupts(INT_RDA); 
6474:  BSF    F9D.5
....................     
....................    //setup_oscillator(False); 
....................     
....................  
....................    //  set_tris_c (0b01010111); 
....................    //setup_spi(SPI_MASTER | SPI_XMIT_L_TO_H |SPI_SS_DISABLED|SPI_H_TO_L  | SPI_CLK_DIV_4  ); 
....................    //setup_spi(SPI_MASTER | SPI_H_TO_L  | SPI_CLK_DIV_4 |SPI_SS_DISABLED); // Initial SPI 
....................    //setup_spi(SPI_MASTER|SPI_H_TO_L|SPI_SS_DISABLED|SPI_CLK_DIV_16); 
....................    //setup_spi2( FALSE ); 
....................    //setup_spi( FALSE ); 
....................     
....................   // setup_spi(SPI_MASTER |SPI_SS_DISABLED | SPI_L_TO_H | SPI_XMIT_L_TO_H| SPI_CLK_DIV_4 ); //masterOK 
....................     
....................    setup_spi(SPI_MASTER  | SPI_L_TO_H | SPI_XMIT_L_TO_H| SPI_CLK_DIV_4 ); //master1 
6476:  BCF    FC6.5
6478:  BCF    F94.5
647A:  BSF    F94.4
647C:  BCF    F94.3
647E:  MOVLW  20
6480:  MOVWF  FC6
6482:  MOVLW  40
6484:  MOVWF  FC7
....................  
....................     //setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_XMIT_L_TO_H | SPI_CLK_DIV_4 ); //master2 
....................     //setup_spi(SPI_MASTER |SPI_SS_DISABLED |SPI_SAMPLE_AT_END | SPI_H_TO_L | SPI_XMIT_L_TO_H| SPI_CLK_DIV_4 ); //master1.1 
....................    //spi_init(SPI1_MODE0, TRUE); 
....................    //spi_init(250000); 
....................    //setup_spi(SPI_MASTER | SPI_XMIT_L_TO_H | SPI_CLK_DIV_4 ); 
....................    //setup_spi(SPI_SS_DISABLED  | SPI_XMIT_L_TO_H | SPI_CLK_DIV_4 ); 
....................    //setup_spi(SPI_MASTER | SPI_H_TO_L | SPI_CLK_T2 | SPI_XMIT_L_TO_H); 
....................    //setup_spi(SPI_MASTER | SPI_H_TO_L| SPI_SAMPLE_AT_END | SPI_CLK_DIV_64);//master3 
....................    //setup_spi(SPI_MASTER |SPI_SS_DISABLED| SPI_L_TO_H | SPI_SAMPLE_AT_END | SPI_CLK_DIV_4 ); 
....................    //setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_XMIT_L_TO_H | SPI_CLK_DIV_4); 
....................    //setup_spi(SPI_MASTER |SPI_SS_DISABLED | SPI_XMIT_L_TO_H| SPI_CLK_DIV_4 ); 
....................    //setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_CLK_DIV_4); 
....................    //setup_spi(SPI_MASTER | SPI_H_TO_L | SPI_CLK_DIV_16); 
....................    //setup_spi(SPI_MASTER |SPI_SS_DISABLED| spi_L_to_H| SPI_XMIT_L_TO_H|SPI_CLK_DIV_4 ); 
....................    
....................    IO_INIT();   //initializes the MCP23S17 chip.//----------jj 
6486:  GOTO   07D4
....................    
....................    IO_SET_TRIS_A(IO_DEVICE_0, 0xFF); //addr.0 Set PortA As Input 
648A:  MOVLB  8
648C:  CLRF   x70
648E:  MOVLW  FF
6490:  MOVWF  x71
6492:  MOVLB  0
6494:  CALL   086A
....................    IO_SET_TRIS_B(IO_DEVICE_0, 0xFF); //addr.0 Set PortB As Input 
6498:  MOVLB  8
649A:  CLRF   x70
649C:  MOVLW  FF
649E:  MOVWF  x71
64A0:  MOVLB  0
64A2:  CALL   087C
....................    IO_SET_TRIS_A(IO_DEVICE_1, 0xFF); //addr.1 Set PortA As Input  
64A6:  MOVLW  02
64A8:  MOVLB  8
64AA:  MOVWF  x70
64AC:  MOVLW  FF
64AE:  MOVWF  x71
64B0:  MOVLB  0
64B2:  CALL   086A
....................    IO_SET_TRIS_B(IO_DEVICE_1, 0xFF); //addr.1 Set PortB As Input  
64B6:  MOVLW  02
64B8:  MOVLB  8
64BA:  MOVWF  x70
64BC:  MOVLW  FF
64BE:  MOVWF  x71
64C0:  MOVLB  0
64C2:  CALL   087C
....................    IO_SET_TRIS_A(IO_DEVICE_2, 0x00); //addr.2 Set PortA As Output  
64C6:  MOVLW  04
64C8:  MOVLB  8
64CA:  MOVWF  x70
64CC:  CLRF   x71
64CE:  MOVLB  0
64D0:  CALL   086A
....................    IO_SET_TRIS_B(IO_DEVICE_2, 0x00); //addr.2 Set PortB As Output 
64D4:  MOVLW  04
64D6:  MOVLB  8
64D8:  MOVWF  x70
64DA:  CLRF   x71
64DC:  MOVLB  0
64DE:  CALL   087C
....................    IO_SET_TRIS_A(IO_DEVICE_3, 0x00); //addr.3 Set PortA As Output  
64E2:  MOVLW  06
64E4:  MOVLB  8
64E6:  MOVWF  x70
64E8:  CLRF   x71
64EA:  MOVLB  0
64EC:  CALL   086A
....................    IO_SET_TRIS_B(IO_DEVICE_3, 0x00); //addr.3 Set PortB As Output 
64F0:  MOVLW  06
64F2:  MOVLB  8
64F4:  MOVWF  x70
64F6:  CLRF   x71
64F8:  MOVLB  0
64FA:  CALL   087C
....................    IO_SET_TRIS_A(IO_DEVICE_4, 0x00); //addr.4 Set PortA As Output  
64FE:  MOVLW  08
6500:  MOVLB  8
6502:  MOVWF  x70
6504:  CLRF   x71
6506:  MOVLB  0
6508:  CALL   086A
....................    IO_SET_TRIS_B(IO_DEVICE_4, 0x00); //addr.4 Set PortB As Output  
650C:  MOVLW  08
650E:  MOVLB  8
6510:  MOVWF  x70
6512:  CLRF   x71
6514:  MOVLB  0
6516:  CALL   087C
....................    IO_SET_TRIS_A(IO_DEVICE_5, 0x00); //addr.5 Set PortA As Output  
651A:  MOVLW  0A
651C:  MOVLB  8
651E:  MOVWF  x70
6520:  CLRF   x71
6522:  MOVLB  0
6524:  CALL   086A
....................    IO_SET_TRIS_B(IO_DEVICE_5, 0x00); //addr.5 Set PortB As Output 
6528:  MOVLW  0A
652A:  MOVLB  8
652C:  MOVWF  x70
652E:  CLRF   x71
6530:  MOVLB  0
6532:  CALL   087C
....................     
....................    FlashingFlag = 1; 
6536:  BSF    17.1
....................    //output_bit(P485ctrl,0); 
....................    sequence = end_sq; 
6538:  MOVFF  6C,74
....................    Address = 1; 
653C:  MOVLW  01
653E:  MOVWF  75
....................  
....................    Output.B1 = 1; 
6540:  MOVLB  7
6542:  BSF    xDB.0
....................    Output.B2 = 1; 
6544:  BSF    xDB.1
....................    Output.B3 = 1; 
6546:  BSF    xDB.2
....................    Output.B4 = 1; 
6548:  BSF    xDB.3
....................    Output.B5 = 1; 
654A:  BSF    xDB.4
....................    Output.B6 = 1; 
654C:  BSF    xDB.5
....................    Output.B7 = 1; 
654E:  BSF    xDB.6
....................    Output.B8 = 1; 
6550:  BSF    xDB.7
....................  
....................     
....................    //////////////////// 
....................    In.B1 = 0; 
6552:  BCF    xE2.0
....................    In.B2 = 0; 
6554:  BCF    xE2.1
....................    In.B3 = 0; 
6556:  BCF    xE2.2
....................    In.B4 = 0; 
6558:  BCF    xE2.3
....................    In.B5 = 0; 
655A:  BCF    xE2.4
....................    In.B6 = 0; 
655C:  BCF    xE2.5
....................    In.B7 = 0; 
655E:  BCF    xE2.6
....................    In.B8 = 0; 
6560:  BCF    xE2.7
....................  
....................     
....................    //////////////////// 
....................    In2.B1 = 0; 
6562:  BCF    xE3.0
....................    In2.B2 = 0; 
6564:  BCF    xE3.1
....................    In2.B3 = 0; 
6566:  BCF    xE3.2
....................    In2.B4 = 0; 
6568:  BCF    xE3.3
....................    In2.B5 = 0; 
656A:  BCF    xE3.4
....................    In2.B6 = 0; 
656C:  BCF    xE3.5
....................    In2.B7 = 0; 
656E:  BCF    xE3.6
....................    In2.B8 = 0;   
6570:  BCF    xE3.7
....................    //////////////////////// 
....................    Ack.B1 = 0; 
6572:  BCF    xE1.0
....................    Ack.B2 = 0; 
6574:  BCF    xE1.1
....................    Ack.B3 = 0; 
6576:  BCF    xE1.2
....................    Ack.B4 = 0; 
6578:  BCF    xE1.3
....................    Ack.B5 = 0; 
657A:  BCF    xE1.4
....................    Ack.B6 = 0; 
657C:  BCF    xE1.5
....................    Ack.B7 = 0; 
657E:  BCF    xE1.6
....................    Ack.B8 = 0; 
6580:  BCF    xE1.7
....................   
....................     /////// read setting ////////// 
....................  
....................    if(read_eeprom(0x00) == 0x0F) 
6582:  MOVFF  FF2,870
6586:  BCF    FF2.7
6588:  CLRF   FAA
658A:  CLRF   FA9
658C:  BCF    FA6.6
658E:  BCF    FA6.7
6590:  BSF    FA6.0
6592:  MOVF   FA8,W
6594:  MOVLB  8
6596:  BTFSC  x70.7
6598:  BSF    FF2.7
659A:  SUBLW  0F
659C:  BNZ   65A8
....................    { 
....................       Read_Config(); 
659E:  MOVLB  0
65A0:  CALL   0890
....................    } 
....................    else 
65A4:  BRA    6744
65A6:  MOVLB  8
....................    { 
....................       FlashingRateTime = 25; 
65A8:  MOVLW  19
65AA:  MOVWF  18
....................       AutoAck = 0xF0; //not use auto ack 
65AC:  MOVLW  F0
65AE:  MOVWF  67
....................       Address = 0x01; 
65B0:  MOVLW  01
65B2:  MOVWF  75
....................  
....................       AutoAckTime = 5; 
65B4:  MOVLW  05
65B6:  MOVWF  68
....................       FlashingRate = 25; 
65B8:  MOVLW  19
65BA:  MOVWF  69
....................       NoOfPoint = 16; 
65BC:  MOVLW  10
65BE:  MOVWF  6A
....................       FaultDelayTime = 0x00; 
65C0:  CLRF   x2E
65C2:  CLRF   x2D
....................  
....................  
....................       InputType.B1 = 1; 
65C4:  MOVLB  7
65C6:  BSF    xDC.0
....................       InputType.B2 = 1; 
65C8:  BSF    xDC.1
....................       InputType.B3 = 1; 
65CA:  BSF    xDC.2
....................       InputType.B4 = 1; 
65CC:  BSF    xDC.3
....................       InputType.B5 = 1; 
65CE:  BSF    xDC.4
....................       InputType.B6 = 1; 
65D0:  BSF    xDC.5
....................       InputType.B7 = 1; 
65D2:  BSF    xDC.6
....................       InputType.B8 = 1; 
65D4:  BSF    xDC.7
....................        
....................       FaultNCNO[1] = 1; 
65D6:  MOVLB  8
65D8:  BSF    x69.1
....................       FaultNCNO[2] = 1; 
65DA:  BSF    x69.2
....................       FaultNCNO[3] = 1; 
65DC:  BSF    x69.3
....................       FaultNCNO[4] = 1; 
65DE:  BSF    x69.4
....................       FaultNCNO[5] = 1; 
65E0:  BSF    x69.5
....................       FaultNCNO[6] = 1; 
65E2:  BSF    x69.6
....................       FaultNCNO[7] = 1; 
65E4:  BSF    x69.7
....................       FaultNCNO[8] = 1; 
65E6:  BSF    x6A.0
....................        
....................       ///////////////////////////// 
....................       FaultType.B1 = 1; 
65E8:  MOVLB  7
65EA:  BSF    xDD.0
....................       FaultType.B2= 1; 
65EC:  BSF    xDD.1
....................       FaultType.B3 = 1; 
65EE:  BSF    xDD.2
....................       FaultType.B4 = 1; 
65F0:  BSF    xDD.3
....................       FaultType.B5 = 1; 
65F2:  BSF    xDD.4
....................       FaultType.B6 = 1; 
65F4:  BSF    xDD.5
....................       FaultType.B7 = 1; 
65F6:  BSF    xDD.6
....................       FaultType.B8 = 1; 
65F8:  BSF    xDD.7
....................        
....................       //////////////////////////// 
....................       OutputType.B1 = 1; 
65FA:  BSF    xDE.0
....................       OutputType.B2 = 1; 
65FC:  BSF    xDE.1
....................       OutputType.B3 = 1; 
65FE:  BSF    xDE.2
....................       OutputType.B4 = 1; 
6600:  BSF    xDE.3
....................       OutputType.B5 = 1; 
6602:  BSF    xDE.4
....................       OutputType.B6 = 1; 
6604:  BSF    xDE.5
....................       OutputType.B7 = 1; 
6606:  BSF    xDE.6
....................       OutputType.B8 = 1; 
6608:  BSF    xDE.7
....................  
....................       ///////////////////////////// 
....................       OutputBoth.B1 = 1; 
660A:  BSF    xDF.0
....................       OutputBoth.B2 = 1; 
660C:  BSF    xDF.1
....................       OutputBoth.B3 = 1; 
660E:  BSF    xDF.2
....................       OutputBoth.B4 = 1; 
6610:  BSF    xDF.3
....................       OutputBoth.B5 = 1; 
6612:  BSF    xDF.4
....................       OutputBoth.B6 = 1; 
6614:  BSF    xDF.5
....................       OutputBoth.B7 = 1; 
6616:  BSF    xDF.6
....................       OutputBoth.B8 = 1; 
6618:  BSF    xDF.7
....................  
....................        
....................       ////////////////////////////////////////////// 
....................       AlarmIndicator.B1 = 1; 
661A:  BSF    xE0.0
....................       AlarmIndicator.B2 = 1; 
661C:  BSF    xE0.1
....................       AlarmIndicator.B3 = 1; 
661E:  BSF    xE0.2
....................       AlarmIndicator.B4 = 1; 
6620:  BSF    xE0.3
....................       AlarmIndicator.B5 = 1; 
6622:  BSF    xE0.4
....................       AlarmIndicator.B6 = 1; 
6624:  BSF    xE0.5
....................       AlarmIndicator.B7 = 1; 
6626:  BSF    xE0.6
....................       AlarmIndicator.B8 = 1; 
6628:  BSF    xE0.7
....................  
....................        
....................       ///////////// JACK/////////////////// 
....................    EEpDat = read_eeprom(0x10); 
662A:  MOVFF  FF2,870
662E:  BCF    FF2.7
6630:  CLRF   FAA
6632:  MOVLW  10
6634:  MOVWF  FA9
6636:  BCF    FA6.6
6638:  BCF    FA6.7
663A:  BSF    FA6.0
663C:  MOVF   FA8,W
663E:  MOVLB  8
6640:  BTFSC  x70.7
6642:  BSF    FF2.7
6644:  MOVWF  36
....................    //Red1_8 = EEpDat; 
....................    RED_Colour.B1 = EEpDat; 
6646:  MOVLB  7
6648:  BCF    xE6.0
664A:  BTFSC  36.0
664C:  BSF    xE6.0
....................    RED_Colour.B2 = EEpDat >> 1; 
664E:  BCF    FD8.0
6650:  RRCF   36,W
6652:  BCF    xE6.1
6654:  BTFSC  FE8.0
6656:  BSF    xE6.1
....................    RED_Colour.B3 = EEpDat >> 2; 
6658:  RRCF   36,W
665A:  MOVWF  00
665C:  RRCF   00,F
665E:  MOVLW  3F
6660:  ANDWF  00,F
6662:  BCF    xE6.2
6664:  BTFSC  00.0
6666:  BSF    xE6.2
....................    RED_Colour.B4 = EEpDat >> 3; 
6668:  RRCF   36,W
666A:  MOVWF  00
666C:  RRCF   00,F
666E:  RRCF   00,F
6670:  MOVLW  1F
6672:  ANDWF  00,F
6674:  BCF    xE6.3
6676:  BTFSC  00.0
6678:  BSF    xE6.3
....................    RED_Colour.B5 = EEpDat >> 4; 
667A:  SWAPF  36,W
667C:  MOVWF  00
667E:  MOVLW  0F
6680:  ANDWF  00,F
6682:  BCF    xE6.4
6684:  BTFSC  00.0
6686:  BSF    xE6.4
....................    RED_Colour.B6 = EEpDat >> 5; 
6688:  SWAPF  36,W
668A:  MOVWF  00
668C:  RRCF   00,F
668E:  MOVLW  07
6690:  ANDWF  00,F
6692:  BCF    xE6.5
6694:  BTFSC  00.0
6696:  BSF    xE6.5
....................    RED_Colour.B7 = EEpDat >> 6; 
6698:  SWAPF  36,W
669A:  MOVWF  00
669C:  RRCF   00,F
669E:  RRCF   00,F
66A0:  MOVLW  03
66A2:  ANDWF  00,F
66A4:  BCF    xE6.6
66A6:  BTFSC  00.0
66A8:  BSF    xE6.6
....................    RED_Colour.B8 = EEpDat >> 7; 
66AA:  CLRF   00
66AC:  BTFSC  36.7
66AE:  BSF    00.0
66B0:  BCF    xE6.7
66B2:  BTFSC  00.0
66B4:  BSF    xE6.7
....................        
....................    EEpDat = read_eeprom(0x14); 
66B6:  MOVFF  FF2,870
66BA:  BCF    FF2.7
66BC:  CLRF   FAA
66BE:  MOVLW  14
66C0:  MOVWF  FA9
66C2:  BCF    FA6.6
66C4:  BCF    FA6.7
66C6:  BSF    FA6.0
66C8:  MOVF   FA8,W
66CA:  MOVLB  8
66CC:  BTFSC  x70.7
66CE:  BSF    FF2.7
66D0:  MOVWF  36
....................    //Green1_8 = EEpDat; 
....................    GREEN_Colour.B1 = EEpDat; 
66D2:  MOVLB  7
66D4:  BCF    xE7.0
66D6:  BTFSC  36.0
66D8:  BSF    xE7.0
....................    GREEN_Colour.B2 = EEpDat >> 1; 
66DA:  BCF    FD8.0
66DC:  RRCF   36,W
66DE:  BCF    xE7.1
66E0:  BTFSC  FE8.0
66E2:  BSF    xE7.1
....................    GREEN_Colour.B3 = EEpDat >> 2; 
66E4:  RRCF   36,W
66E6:  MOVWF  00
66E8:  RRCF   00,F
66EA:  MOVLW  3F
66EC:  ANDWF  00,F
66EE:  BCF    xE7.2
66F0:  BTFSC  00.0
66F2:  BSF    xE7.2
....................    GREEN_Colour.B4 = EEpDat >> 3; 
66F4:  RRCF   36,W
66F6:  MOVWF  00
66F8:  RRCF   00,F
66FA:  RRCF   00,F
66FC:  MOVLW  1F
66FE:  ANDWF  00,F
6700:  BCF    xE7.3
6702:  BTFSC  00.0
6704:  BSF    xE7.3
....................    GREEN_Colour.B5 = EEpDat >> 4; 
6706:  SWAPF  36,W
6708:  MOVWF  00
670A:  MOVLW  0F
670C:  ANDWF  00,F
670E:  BCF    xE7.4
6710:  BTFSC  00.0
6712:  BSF    xE7.4
....................    GREEN_Colour.B6 = EEpDat >> 5; 
6714:  SWAPF  36,W
6716:  MOVWF  00
6718:  RRCF   00,F
671A:  MOVLW  07
671C:  ANDWF  00,F
671E:  BCF    xE7.5
6720:  BTFSC  00.0
6722:  BSF    xE7.5
....................    GREEN_Colour.B7 = EEpDat >> 6; 
6724:  SWAPF  36,W
6726:  MOVWF  00
6728:  RRCF   00,F
672A:  RRCF   00,F
672C:  MOVLW  03
672E:  ANDWF  00,F
6730:  BCF    xE7.6
6732:  BTFSC  00.0
6734:  BSF    xE7.6
....................    GREEN_Colour.B8 = EEpDat >> 7; 
6736:  CLRF   00
6738:  BTFSC  36.7
673A:  BSF    00.0
673C:  BCF    xE7.7
673E:  BTFSC  00.0
6740:  BSF    xE7.7
6742:  MOVLB  0
....................     
....................    ///////////// JACK///////////////////////////////////// 
....................        
....................    } 
....................     
....................    set_tris_a (0b00000000); //PORTA SET TO OUTPUT 
6744:  MOVLW  00
6746:  MOVWF  F92
....................    set_tris_b (0b00000000); //PORTA SET TO OUTPUT 
6748:  MOVWF  F93
....................    enable_interrupts(GLOBAL); 
674A:  MOVLW  C0
674C:  IORWF  FF2,F
....................    setup_wdt(WDT_ON); 
674E:  BSF    FD1.0
....................    Read_input(); restart_wdt(); 
6750:  CALL   15B8
6754:  CLRWDT
....................    output_bit(Pbuzzer,1);  //Clear Buzzer 
6756:  BSF    F89.4
6758:  BCF    F92.4
....................    output_bit(Pbell,1);   //Clear Bell 
675A:  BSF    F89.3
675C:  BCF    F92.3
....................    output_bit(P485ctrl,0); 
675E:  BCF    F8A.3
6760:  BCF    F93.3
....................    //output_bit(P485ctrl,0); 
....................    output_bit(PIN_B4,0); //jj 
6762:  BCF    F8A.4
6764:  BCF    F93.4
....................    Send_Ouput(); 
6766:  CALL   1D4E
....................     
....................    IO_OUTPUT_A(IO_DEVICE_2, 0xff); 
676A:  MOVLW  04
676C:  MOVLB  8
676E:  MOVWF  x78
6770:  MOVLW  FF
6772:  MOVWF  x79
6774:  MOVLB  0
6776:  CALL   1D22
....................    IO_OUTPUT_B(IO_DEVICE_2, 0xff); 
677A:  MOVLW  04
677C:  MOVLB  8
677E:  MOVWF  x78
6780:  MOVLW  FF
6782:  MOVWF  x79
6784:  MOVLB  0
6786:  CALL   1D38
....................              
....................    IO_OUTPUT_A(IO_DEVICE_3, 0xff); 
678A:  MOVLW  06
678C:  MOVLB  8
678E:  MOVWF  x78
6790:  MOVLW  FF
6792:  MOVWF  x79
6794:  MOVLB  0
6796:  CALL   1D22
....................    IO_OUTPUT_B(IO_DEVICE_3, 0xff); 
679A:  MOVLW  06
679C:  MOVLB  8
679E:  MOVWF  x78
67A0:  MOVLW  FF
67A2:  MOVWF  x79
67A4:  MOVLB  0
67A6:  CALL   1D38
....................     
....................     
....................    char loop; 
....................    for(loop=0;loop<=2;loop++) 
67AA:  MOVLB  8
67AC:  CLRF   x6D
67AE:  MOVF   x6D,W
67B0:  SUBLW  02
67B2:  BTFSS  FD8.0
67B4:  BRA    68C2
....................    { 
....................        
....................       IO_OUTPUT_A(IO_DEVICE_2, 0); 
67B6:  MOVLW  04
67B8:  MOVWF  x78
67BA:  CLRF   x79
67BC:  MOVLB  0
67BE:  CALL   1D22
....................       IO_OUTPUT_B(IO_DEVICE_2, 0); 
67C2:  MOVLW  04
67C4:  MOVLB  8
67C6:  MOVWF  x78
67C8:  CLRF   x79
67CA:  MOVLB  0
67CC:  CALL   1D38
....................                  
....................       IO_OUTPUT_A(IO_DEVICE_3, 0); 
67D0:  MOVLW  06
67D2:  MOVLB  8
67D4:  MOVWF  x78
67D6:  CLRF   x79
67D8:  MOVLB  0
67DA:  CALL   1D22
....................       IO_OUTPUT_B(IO_DEVICE_3, 0); 
67DE:  MOVLW  06
67E0:  MOVLB  8
67E2:  MOVWF  x78
67E4:  CLRF   x79
67E6:  MOVLB  0
67E8:  CALL   1D38
....................       
....................       IO_OUTPUT_A(IO_DEVICE_4, 0); 
67EC:  MOVLW  08
67EE:  MOVLB  8
67F0:  MOVWF  x78
67F2:  CLRF   x79
67F4:  MOVLB  0
67F6:  CALL   1D22
....................       IO_OUTPUT_B(IO_DEVICE_4, 0); 
67FA:  MOVLW  08
67FC:  MOVLB  8
67FE:  MOVWF  x78
6800:  CLRF   x79
6802:  MOVLB  0
6804:  CALL   1D38
....................                 
....................       IO_OUTPUT_A(IO_DEVICE_5, 0); 
6808:  MOVLW  0A
680A:  MOVLB  8
680C:  MOVWF  x78
680E:  CLRF   x79
6810:  MOVLB  0
6812:  CALL   1D22
....................       IO_OUTPUT_B(IO_DEVICE_5, 0); 
6816:  MOVLW  0A
6818:  MOVLB  8
681A:  MOVWF  x78
681C:  CLRF   x79
681E:  MOVLB  0
6820:  CALL   1D38
....................       delay_ms(200); 
6824:  MOVLW  C8
6826:  MOVLB  8
6828:  MOVWF  x79
682A:  MOVLB  0
682C:  CALL   0772
....................        
....................       IO_OUTPUT_A(IO_DEVICE_2, 0xFF); 
6830:  MOVLW  04
6832:  MOVLB  8
6834:  MOVWF  x78
6836:  MOVLW  FF
6838:  MOVWF  x79
683A:  MOVLB  0
683C:  CALL   1D22
....................       IO_OUTPUT_B(IO_DEVICE_2, 0xFF); 
6840:  MOVLW  04
6842:  MOVLB  8
6844:  MOVWF  x78
6846:  MOVLW  FF
6848:  MOVWF  x79
684A:  MOVLB  0
684C:  CALL   1D38
....................                  
....................       IO_OUTPUT_A(IO_DEVICE_3, 0xFF); 
6850:  MOVLW  06
6852:  MOVLB  8
6854:  MOVWF  x78
6856:  MOVLW  FF
6858:  MOVWF  x79
685A:  MOVLB  0
685C:  CALL   1D22
....................       IO_OUTPUT_B(IO_DEVICE_3, 0xFF); 
6860:  MOVLW  06
6862:  MOVLB  8
6864:  MOVWF  x78
6866:  MOVLW  FF
6868:  MOVWF  x79
686A:  MOVLB  0
686C:  CALL   1D38
....................       
....................       IO_OUTPUT_A(IO_DEVICE_4, 0xFF); 
6870:  MOVLW  08
6872:  MOVLB  8
6874:  MOVWF  x78
6876:  MOVLW  FF
6878:  MOVWF  x79
687A:  MOVLB  0
687C:  CALL   1D22
....................       IO_OUTPUT_B(IO_DEVICE_4, 0xFF); 
6880:  MOVLW  08
6882:  MOVLB  8
6884:  MOVWF  x78
6886:  MOVLW  FF
6888:  MOVWF  x79
688A:  MOVLB  0
688C:  CALL   1D38
....................                 
....................       IO_OUTPUT_A(IO_DEVICE_5, 0xFF); 
6890:  MOVLW  0A
6892:  MOVLB  8
6894:  MOVWF  x78
6896:  MOVLW  FF
6898:  MOVWF  x79
689A:  MOVLB  0
689C:  CALL   1D22
....................       IO_OUTPUT_B(IO_DEVICE_5, 0xFF); 
68A0:  MOVLW  0A
68A2:  MOVLB  8
68A4:  MOVWF  x78
68A6:  MOVLW  FF
68A8:  MOVWF  x79
68AA:  MOVLB  0
68AC:  CALL   1D38
....................        
....................       delay_ms(200); 
68B0:  MOVLW  C8
68B2:  MOVLB  8
68B4:  MOVWF  x79
68B6:  MOVLB  0
68B8:  CALL   0772
....................    } 
68BC:  MOVLB  8
68BE:  INCF   x6D,F
68C0:  BRA    67AE
....................    // jj 
....................    char i; 
....................    for(i=1;i<=8;i++) 
68C2:  MOVLW  01
68C4:  MOVWF  x6E
68C6:  MOVF   x6E,W
68C8:  SUBLW  08
68CA:  BTFSS  FD8.0
68CC:  BRA    69DE
....................    { 
....................       FaultAgo[i] = 0; 
68CE:  MOVFF  86E,87B
68D2:  CLRF   x7C
68D4:  MOVLW  07
68D6:  MOVWF  x7E
68D8:  MOVLW  E9
68DA:  MOVWF  x7D
68DC:  MOVLB  0
68DE:  CALL   1530
....................       FaultNow[i] = 0; 
68E2:  MOVFF  86E,87B
68E6:  MOVLB  8
68E8:  CLRF   x7C
68EA:  MOVLW  07
68EC:  MOVWF  x7E
68EE:  MOVLW  ED
68F0:  MOVWF  x7D
68F2:  MOVLB  0
68F4:  CALL   1530
....................       ReleaseTime[i] = 0; 
68F8:  BCF    FD8.0
68FA:  MOVLB  8
68FC:  RLCF   x6E,W
68FE:  CLRF   03
6900:  ADDLW  F1
6902:  MOVWF  FE9
6904:  MOVLW  07
6906:  ADDWFC 03,W
6908:  MOVWF  FEA
690A:  CLRF   FEC
690C:  MOVF   FED,F
690E:  CLRF   FEF
....................       if(FaultNCNO[i] ==NO) 
6910:  MOVFF  86E,87B
6914:  MOVLW  08
6916:  MOVWF  x7D
6918:  MOVLW  69
691A:  MOVWF  x7C
691C:  MOVLB  0
691E:  CALL   14DC
6922:  MOVLW  00
6924:  BTFSC  01.0
6926:  MOVLW  01
6928:  ANDLW  01
692A:  SUBLW  01
692C:  BNZ   6986
....................       { 
....................          switch(i) 
....................          { 
692E:  MOVLW  01
6930:  MOVLB  8
6932:  SUBWF  x6E,W
6934:  ADDLW  F8
6936:  BC    6982
6938:  ADDLW  08
693A:  MOVLB  0
693C:  GOTO   6B9C
....................             case 1: 
....................                Input.B1 = 1;  
6940:  MOVLB  7
6942:  BSF    xDA.0
....................             break; 
6944:  MOVLB  8
6946:  BRA    6982
....................             case 2: 
....................                Input.B2 = 1;  
6948:  MOVLB  7
694A:  BSF    xDA.1
....................             break; 
694C:  MOVLB  8
694E:  BRA    6982
....................             case 3: 
....................                Input.B3 = 1;  
6950:  MOVLB  7
6952:  BSF    xDA.2
....................             break; 
6954:  MOVLB  8
6956:  BRA    6982
....................             case 4: 
....................                Input.B4 = 1;  
6958:  MOVLB  7
695A:  BSF    xDA.3
....................             break; 
695C:  MOVLB  8
695E:  BRA    6982
....................             case 5: 
....................                Input.B5 = 1;  
6960:  MOVLB  7
6962:  BSF    xDA.4
....................             break; 
6964:  MOVLB  8
6966:  BRA    6982
....................             case 6: 
....................                Input.B6 = 1;  
6968:  MOVLB  7
696A:  BSF    xDA.5
....................             break; 
696C:  MOVLB  8
696E:  BRA    6982
....................             case 7: 
....................                Input.B7 = 1;  
6970:  MOVLB  7
6972:  BSF    xDA.6
....................              break; 
6974:  MOVLB  8
6976:  BRA    6982
....................              case 8: 
....................                Input.B8 = 1;  
6978:  MOVLB  7
697A:  BSF    xDA.7
....................             break; 
697C:  MOVLB  8
697E:  BRA    6982
6980:  MOVLB  8
....................           
....................          }                  
....................       } 
....................       else 
6982:  BRA    69DA
6984:  MOVLB  0
....................       { 
....................          switch(i) 
....................          { 
6986:  MOVLW  01
6988:  MOVLB  8
698A:  SUBWF  x6E,W
698C:  ADDLW  F8
698E:  BC    69DA
6990:  ADDLW  08
6992:  MOVLB  0
6994:  GOTO   6BD0
....................             case 1: 
....................                Input.B1 = 0;  
6998:  MOVLB  7
699A:  BCF    xDA.0
....................             break; 
699C:  MOVLB  8
699E:  BRA    69DA
....................             case 2: 
....................                Input.B2 = 0;  
69A0:  MOVLB  7
69A2:  BCF    xDA.1
....................             break; 
69A4:  MOVLB  8
69A6:  BRA    69DA
....................             case 3: 
....................                Input.B3 = 0;  
69A8:  MOVLB  7
69AA:  BCF    xDA.2
....................             break; 
69AC:  MOVLB  8
69AE:  BRA    69DA
....................             case 4: 
....................                Input.B4 = 0;  
69B0:  MOVLB  7
69B2:  BCF    xDA.3
....................             break; 
69B4:  MOVLB  8
69B6:  BRA    69DA
....................             case 5: 
....................                Input.B5 = 0;  
69B8:  MOVLB  7
69BA:  BCF    xDA.4
....................             break; 
69BC:  MOVLB  8
69BE:  BRA    69DA
....................             case 6: 
....................                Input.B6 = 0;  
69C0:  MOVLB  7
69C2:  BCF    xDA.5
....................             break; 
69C4:  MOVLB  8
69C6:  BRA    69DA
....................             case 7: 
....................                Input.B7 = 0;  
69C8:  MOVLB  7
69CA:  BCF    xDA.6
....................              break; 
69CC:  MOVLB  8
69CE:  BRA    69DA
....................              case 8: 
....................                Input.B8 = 0;  
69D0:  MOVLB  7
69D2:  BCF    xDA.7
....................             break; 
69D4:  MOVLB  8
69D6:  BRA    69DA
69D8:  MOVLB  8
....................        
....................          }                  
....................       } 
....................    } 
69DA:  INCF   x6E,F
69DC:  BRA    68C6
....................    //GSM SIM900 Init 
....................    delay_ms(1000); 
69DE:  MOVLW  04
69E0:  MOVWF  x70
69E2:  MOVLW  FA
69E4:  MOVWF  x79
69E6:  MOVLB  0
69E8:  CALL   0772
69EC:  MOVLB  8
69EE:  DECFSZ x70,F
69F0:  BRA    69E2
....................    printf("AT+CMGF=1");  
69F2:  MOVLW  68
69F4:  MOVWF  FF6
69F6:  MOVLW  07
69F8:  MOVWF  FF7
69FA:  MOVLB  0
69FC:  CALL   1F28
....................    putc('\n'); 
6A00:  MOVLW  0A
6A02:  CALL   1F4C
....................    delay_ms(50); 
6A06:  MOVLW  32
6A08:  MOVLB  8
6A0A:  MOVWF  x79
6A0C:  MOVLB  0
6A0E:  CALL   0772
....................     
....................    SendSMS.B1 =0; 
6A12:  MOVLB  7
6A14:  BCF    xE8.0
....................    SendSMS.B2 =0; 
6A16:  BCF    xE8.1
....................    SendSMS.B3 =0; 
6A18:  BCF    xE8.2
....................    SendSMS.B4 =0; 
6A1A:  BCF    xE8.3
....................    SendSMS.B5 =0; 
6A1C:  BCF    xE8.4
....................    SendSMS.B6 =0; 
6A1E:  BCF    xE8.5
....................    SendSMS.B7 =0; 
6A20:  BCF    xE8.6
....................    SendSMS.B8 =0; 
6A22:  BCF    xE8.7
....................     
....................    char m; 
....................    for(m=0; m<10; m++) 
6A24:  MOVLB  8
6A26:  CLRF   x6F
6A28:  MOVF   x6F,W
6A2A:  SUBLW  09
6A2C:  BNC   6A60
....................    { 
....................       sms_phonenumber[m] = read_eeprom(0x32 + m); 
6A2E:  CLRF   03
6A30:  MOVF   x6F,W
6A32:  ADDLW  83
6A34:  MOVWF  FE9
6A36:  MOVLW  06
6A38:  ADDWFC 03,W
6A3A:  MOVWF  FEA
6A3C:  MOVLW  32
6A3E:  ADDWF  x6F,W
6A40:  MOVWF  x72
6A42:  MOVFF  FF2,873
6A46:  BCF    FF2.7
6A48:  CLRF   FAA
6A4A:  MOVFF  872,FA9
6A4E:  BCF    FA6.6
6A50:  BCF    FA6.7
6A52:  BSF    FA6.0
6A54:  MOVF   FA8,W
6A56:  BTFSC  x73.7
6A58:  BSF    FF2.7
6A5A:  MOVWF  FEF
....................    } 
6A5C:  INCF   x6F,F
6A5E:  BRA    6A28
....................    sms_phonenumber[m] = '\0' ; // end string 
6A60:  CLRF   03
6A62:  MOVF   x6F,W
6A64:  ADDLW  83
6A66:  MOVWF  FE9
6A68:  MOVLW  06
6A6A:  ADDWFC 03,W
6A6C:  MOVWF  FEA
6A6E:  CLRF   FEF
....................     
....................     
....................    while(TRUE) 
....................    { 
....................  
....................       IO_OUTPUT_A(IO_DEVICE_0, 0xFF); //jj  
6A70:  CLRF   x78
6A72:  MOVLW  FF
6A74:  MOVWF  x79
6A76:  MOVLB  0
6A78:  CALL   1D22
....................       IO_OUTPUT_B(IO_DEVICE_0, 0xFF); //jj  
6A7C:  MOVLB  8
6A7E:  CLRF   x78
6A80:  MOVLW  FF
6A82:  MOVWF  x79
6A84:  MOVLB  0
6A86:  CALL   1D38
....................       IO_OUTPUT_A(IO_DEVICE_1, 0xFF); //jj  
6A8A:  MOVLW  02
6A8C:  MOVLB  8
6A8E:  MOVWF  x78
6A90:  MOVLW  FF
6A92:  MOVWF  x79
6A94:  MOVLB  0
6A96:  CALL   1D22
....................       IO_OUTPUT_B(IO_DEVICE_1, 0xFF); //jj  
6A9A:  MOVLW  02
6A9C:  MOVLB  8
6A9E:  MOVWF  x78
6AA0:  MOVLW  FF
6AA2:  MOVWF  x79
6AA4:  MOVLB  0
6AA6:  CALL   1D38
....................        
....................       restart_wdt(); 
6AAA:  CLRWDT
....................  
....................       if(recieve_completed == 1) 
6AAC:  BTFSS  2D.5
6AAE:  BRA    6AB6
....................       { 
....................          Modbus_Function(); 
6AB0:  GOTO   23C8
....................          recieve_completed = 0 ; 
6AB4:  BCF    2D.5
....................       } 
....................    
....................       check_ack(); 
6AB6:  CALL   2170
....................       check_reset(); 
6ABA:  CALL   2254
....................       check_test(); 
6ABE:  GOTO   6196
....................        
....................       restart_wdt(); 
6AC2:  CLRWDT
....................  
....................       Read_input(); restart_wdt(); //must be first 
6AC4:  CALL   15B8
6AC8:  CLRWDT
....................       Anal_Function(); restart_wdt(); 
6ACA:  CALL   499A
6ACE:  CLRWDT
....................       Send_Ouput(); restart_wdt(); 
6AD0:  CALL   1D4E
6AD4:  CLRWDT
....................       Driver595(); restart_wdt(); 
6AD6:  GOTO   62A4
6ADA:  CLRWDT
....................        
....................       output_toggle(PIN_A0); 
6ADC:  BCF    F92.0
6ADE:  BTG    F89.0
....................        
....................       if(RefreshConfigData) 
6AE0:  BTFSS  2D.4
6AE2:  BRA    6B96
....................       { 
....................          RefreshConfigData =0; 
6AE4:  BCF    2D.4
....................          Read_Config(); 
6AE6:  CALL   0890
....................          //IO_INIT();   //initializes the MCP23S17 chip.//----------jj 
....................    
....................          IO_SET_TRIS_A(IO_DEVICE_0, 0xFF); //addr.0 Set PortA As Input 
6AEA:  MOVLB  8
6AEC:  CLRF   x70
6AEE:  MOVLW  FF
6AF0:  MOVWF  x71
6AF2:  MOVLB  0
6AF4:  CALL   086A
....................          IO_SET_TRIS_B(IO_DEVICE_0, 0xFF); //addr.0 Set PortB As Input 
6AF8:  MOVLB  8
6AFA:  CLRF   x70
6AFC:  MOVLW  FF
6AFE:  MOVWF  x71
6B00:  MOVLB  0
6B02:  CALL   087C
....................          IO_SET_TRIS_A(IO_DEVICE_1, 0xFF); //addr.1 Set PortA As Input  
6B06:  MOVLW  02
6B08:  MOVLB  8
6B0A:  MOVWF  x70
6B0C:  MOVLW  FF
6B0E:  MOVWF  x71
6B10:  MOVLB  0
6B12:  CALL   086A
....................          IO_SET_TRIS_B(IO_DEVICE_1, 0xFF); //addr.1 Set PortB As Input  
6B16:  MOVLW  02
6B18:  MOVLB  8
6B1A:  MOVWF  x70
6B1C:  MOVLW  FF
6B1E:  MOVWF  x71
6B20:  MOVLB  0
6B22:  CALL   087C
....................          IO_SET_TRIS_A(IO_DEVICE_2, 0x00); //addr.2 Set PortA As Output  
6B26:  MOVLW  04
6B28:  MOVLB  8
6B2A:  MOVWF  x70
6B2C:  CLRF   x71
6B2E:  MOVLB  0
6B30:  CALL   086A
....................          IO_SET_TRIS_B(IO_DEVICE_2, 0x00); //addr.2 Set PortB As Output 
6B34:  MOVLW  04
6B36:  MOVLB  8
6B38:  MOVWF  x70
6B3A:  CLRF   x71
6B3C:  MOVLB  0
6B3E:  CALL   087C
....................          IO_SET_TRIS_A(IO_DEVICE_3, 0x00); //addr.3 Set PortA As Output  
6B42:  MOVLW  06
6B44:  MOVLB  8
6B46:  MOVWF  x70
6B48:  CLRF   x71
6B4A:  MOVLB  0
6B4C:  CALL   086A
....................          IO_SET_TRIS_B(IO_DEVICE_3, 0x00); //addr.3 Set PortB As Output 
6B50:  MOVLW  06
6B52:  MOVLB  8
6B54:  MOVWF  x70
6B56:  CLRF   x71
6B58:  MOVLB  0
6B5A:  CALL   087C
....................          IO_SET_TRIS_A(IO_DEVICE_4, 0x00); //addr.4 Set PortA As Output  
6B5E:  MOVLW  08
6B60:  MOVLB  8
6B62:  MOVWF  x70
6B64:  CLRF   x71
6B66:  MOVLB  0
6B68:  CALL   086A
....................          IO_SET_TRIS_B(IO_DEVICE_4, 0x00); //addr.4 Set PortB As Output  
6B6C:  MOVLW  08
6B6E:  MOVLB  8
6B70:  MOVWF  x70
6B72:  CLRF   x71
6B74:  MOVLB  0
6B76:  CALL   087C
....................          IO_SET_TRIS_A(IO_DEVICE_5, 0x00); //addr.5 Set PortA As Output  
6B7A:  MOVLW  0A
6B7C:  MOVLB  8
6B7E:  MOVWF  x70
6B80:  CLRF   x71
6B82:  MOVLB  0
6B84:  CALL   086A
....................          IO_SET_TRIS_B(IO_DEVICE_5, 0x00); //addr.5 Set PortB As Output 
6B88:  MOVLW  0A
6B8A:  MOVLB  8
6B8C:  MOVWF  x70
6B8E:  CLRF   x71
6B90:  MOVLB  0
6B92:  CALL   087C
....................       } 
....................        
....................  
....................    } 
6B96:  MOVLB  8
6B98:  BRA    6A70
....................     
.................... } 
6B9A:  SLEEP 

Configuration Fuses:
   Word  1: C200   HS IESO FCMEN
   Word  2: 0D1F   BROWNOUT WDT64 WDT BORV20 NOPUT
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST
   Word  5: C000   PROTECT NOCPD NOCPB
   Word  6: E007   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 4007   NOEBTR NOEBTRB
