CCS PCH C Compiler, Version 5.091, 5967               28-¡.Â.-21 16:57

               Filename:   D:\jobESP\ESPAN-04\Firmware\SPAN-04\ESPAN04_8 - Delay - SP - SMS\ESPAN-04.lst

               ROM used:   24526 bytes (37%)
                           Largest free fragment is 41006
               RAM used:   1972 (51%) at main() level
                           1989 (51%) worst case
               Stack used: 4 locations (3 in main + 1 for interrupts)
               Stack size: 31

00000:  GOTO   59AA
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  BTFSS  F9D.1
00056:  GOTO   0060
0005A:  BTFSC  F9E.1
0005C:  GOTO   05AE
00060:  BTFSS  F9D.5
00062:  GOTO   006C
00066:  BTFSC  F9E.5
00068:  GOTO   059E
0006C:  MOVFF  0E,00
00070:  MOVFF  0F,01
00074:  MOVFF  10,02
00078:  MOVFF  11,03
0007C:  MOVFF  0C,FE9
00080:  MOVFF  07,FEA
00084:  BSF    07.7
00086:  MOVFF  08,FE1
0008A:  MOVFF  09,FE2
0008E:  MOVFF  0A,FD9
00092:  MOVFF  0B,FDA
00096:  MOVFF  12,FF3
0009A:  MOVFF  13,FF4
0009E:  MOVFF  14,FFA
000A2:  MOVFF  15,FF5
000A6:  MOVFF  16,FF6
000AA:  MOVFF  17,FF7
000AE:  MOVF   04,W
000B0:  MOVFF  06,FE0
000B4:  MOVFF  05,FD8
000B8:  RETFIE 0
.................... 
.................... #include "D:\jobESP\ESPAN-04\Firmware\SPAN-04\ESPAN04_20 - Delay - SP - SMD - SMS\string.h"
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... #device PIC18F26K22 
000BA:  CLRF   FF7
000BC:  ADDLW  CA
000BE:  MOVWF  FF6
000C0:  MOVLW  00
000C2:  ADDWFC FF7,F
000C4:  TBLRD*+
000C6:  MOVF   FF5,W
000C8:  RETURN 0
000CA:  DATA 00,C1
000CC:  DATA 81,40
000CE:  DATA 01,C0
000D0:  DATA 80,41
000D2:  DATA 01,C0
000D4:  DATA 80,41
000D6:  DATA 00,C1
000D8:  DATA 81,40
000DA:  DATA 01,C0
000DC:  DATA 80,41
000DE:  DATA 00,C1
000E0:  DATA 81,40
000E2:  DATA 00,C1
000E4:  DATA 81,40
000E6:  DATA 01,C0
000E8:  DATA 80,41
000EA:  DATA 01,C0
000EC:  DATA 80,41
000EE:  DATA 00,C1
000F0:  DATA 81,40
000F2:  DATA 00,C1
000F4:  DATA 81,40
000F6:  DATA 01,C0
000F8:  DATA 80,41
000FA:  DATA 00,C1
000FC:  DATA 81,40
000FE:  DATA 01,C0
00100:  DATA 80,41
00102:  DATA 01,C0
00104:  DATA 80,41
00106:  DATA 00,C1
00108:  DATA 81,40
0010A:  DATA 01,C0
0010C:  DATA 80,41
0010E:  DATA 00,C1
00110:  DATA 81,40
00112:  DATA 00,C1
00114:  DATA 81,40
00116:  DATA 01,C0
00118:  DATA 80,41
0011A:  DATA 00,C1
0011C:  DATA 81,40
0011E:  DATA 01,C0
00120:  DATA 80,41
00122:  DATA 01,C0
00124:  DATA 80,41
00126:  DATA 00,C1
00128:  DATA 81,40
0012A:  DATA 00,C1
0012C:  DATA 81,40
0012E:  DATA 01,C0
00130:  DATA 80,41
00132:  DATA 01,C0
00134:  DATA 80,41
00136:  DATA 00,C1
00138:  DATA 81,40
0013A:  DATA 01,C0
0013C:  DATA 80,41
0013E:  DATA 00,C1
00140:  DATA 81,40
00142:  DATA 00,C1
00144:  DATA 81,40
00146:  DATA 01,C0
00148:  DATA 80,41
0014A:  DATA 01,C0
0014C:  DATA 80,41
0014E:  DATA 00,C1
00150:  DATA 81,40
00152:  DATA 00,C1
00154:  DATA 81,40
00156:  DATA 01,C0
00158:  DATA 80,41
0015A:  DATA 00,C1
0015C:  DATA 81,40
0015E:  DATA 01,C0
00160:  DATA 80,41
00162:  DATA 01,C0
00164:  DATA 80,41
00166:  DATA 00,C1
00168:  DATA 81,40
0016A:  DATA 00,C1
0016C:  DATA 81,40
0016E:  DATA 01,C0
00170:  DATA 80,41
00172:  DATA 01,C0
00174:  DATA 80,41
00176:  DATA 00,C1
00178:  DATA 81,40
0017A:  DATA 01,C0
0017C:  DATA 80,41
0017E:  DATA 00,C1
00180:  DATA 81,40
00182:  DATA 00,C1
00184:  DATA 81,40
00186:  DATA 01,C0
00188:  DATA 80,41
0018A:  DATA 00,C1
0018C:  DATA 81,40
0018E:  DATA 01,C0
00190:  DATA 80,41
00192:  DATA 01,C0
00194:  DATA 80,41
00196:  DATA 00,C1
00198:  DATA 81,40
0019A:  DATA 01,C0
0019C:  DATA 80,41
0019E:  DATA 00,C1
001A0:  DATA 81,40
001A2:  DATA 00,C1
001A4:  DATA 81,40
001A6:  DATA 01,C0
001A8:  DATA 80,41
001AA:  DATA 01,C0
001AC:  DATA 80,41
001AE:  DATA 00,C1
001B0:  DATA 81,40
001B2:  DATA 00,C1
001B4:  DATA 81,40
001B6:  DATA 01,C0
001B8:  DATA 80,41
001BA:  DATA 00,C1
001BC:  DATA 81,40
001BE:  DATA 01,C0
001C0:  DATA 80,41
001C2:  DATA 01,C0
001C4:  DATA 80,41
001C6:  DATA 00,C1
001C8:  DATA 81,40
001CA:  CLRF   FF7
001CC:  ADDLW  DA
001CE:  MOVWF  FF6
001D0:  MOVLW  01
001D2:  ADDWFC FF7,F
001D4:  TBLRD*+
001D6:  MOVF   FF5,W
001D8:  RETURN 0
001DA:  DATA 00,C0
001DC:  DATA C1,01
001DE:  DATA C3,03
001E0:  DATA 02,C2
001E2:  DATA C6,06
001E4:  DATA 07,C7
001E6:  DATA 05,C5
001E8:  DATA C4,04
001EA:  DATA CC,0C
001EC:  DATA 0D,CD
001EE:  DATA 0F,CF
001F0:  DATA CE,0E
001F2:  DATA 0A,CA
001F4:  DATA CB,0B
001F6:  DATA C9,09
001F8:  DATA 08,C8
001FA:  DATA D8,18
001FC:  DATA 19,D9
001FE:  DATA 1B,DB
00200:  DATA DA,1A
00202:  DATA 1E,DE
00204:  DATA DF,1F
00206:  DATA DD,1D
00208:  DATA 1C,DC
0020A:  DATA 14,D4
0020C:  DATA D5,15
0020E:  DATA D7,17
00210:  DATA 16,D6
00212:  DATA D2,12
00214:  DATA 13,D3
00216:  DATA 11,D1
00218:  DATA D0,10
0021A:  DATA F0,30
0021C:  DATA 31,F1
0021E:  DATA 33,F3
00220:  DATA F2,32
00222:  DATA 36,F6
00224:  DATA F7,37
00226:  DATA F5,35
00228:  DATA 34,F4
0022A:  DATA 3C,FC
0022C:  DATA FD,3D
0022E:  DATA FF,3F
00230:  DATA 3E,FE
00232:  DATA FA,3A
00234:  DATA 3B,FB
00236:  DATA 39,F9
00238:  DATA F8,38
0023A:  DATA 28,E8
0023C:  DATA E9,29
0023E:  DATA EB,2B
00240:  DATA 2A,EA
00242:  DATA EE,2E
00244:  DATA 2F,EF
00246:  DATA 2D,ED
00248:  DATA EC,2C
0024A:  DATA E4,24
0024C:  DATA 25,E5
0024E:  DATA 27,E7
00250:  DATA E6,26
00252:  DATA 22,E2
00254:  DATA E3,23
00256:  DATA E1,21
00258:  DATA 20,E0
0025A:  DATA A0,60
0025C:  DATA 61,A1
0025E:  DATA 63,A3
00260:  DATA A2,62
00262:  DATA 66,A6
00264:  DATA A7,67
00266:  DATA A5,65
00268:  DATA 64,A4
0026A:  DATA 6C,AC
0026C:  DATA AD,6D
0026E:  DATA AF,6F
00270:  DATA 6E,AE
00272:  DATA AA,6A
00274:  DATA 6B,AB
00276:  DATA 69,A9
00278:  DATA A8,68
0027A:  DATA 78,B8
0027C:  DATA B9,79
0027E:  DATA BB,7B
00280:  DATA 7A,BA
00282:  DATA BE,7E
00284:  DATA 7F,BF
00286:  DATA 7D,BD
00288:  DATA BC,7C
0028A:  DATA B4,74
0028C:  DATA 75,B5
0028E:  DATA 77,B7
00290:  DATA B6,76
00292:  DATA 72,B2
00294:  DATA B3,73
00296:  DATA B1,71
00298:  DATA 70,B0
0029A:  DATA 50,90
0029C:  DATA 91,51
0029E:  DATA 93,53
002A0:  DATA 52,92
002A2:  DATA 96,56
002A4:  DATA 57,97
002A6:  DATA 55,95
002A8:  DATA 94,54
002AA:  DATA 9C,5C
002AC:  DATA 5D,9D
002AE:  DATA 5F,9F
002B0:  DATA 9E,5E
002B2:  DATA 5A,9A
002B4:  DATA 9B,5B
002B6:  DATA 99,59
002B8:  DATA 58,98
002BA:  DATA 88,48
002BC:  DATA 49,89
002BE:  DATA 4B,8B
002C0:  DATA 8A,4A
002C2:  DATA 4E,8E
002C4:  DATA 8F,4F
002C6:  DATA 8D,4D
002C8:  DATA 4C,8C
002CA:  DATA 44,84
002CC:  DATA 85,45
002CE:  DATA 87,47
002D0:  DATA 46,86
002D2:  DATA 82,42
002D4:  DATA 43,83
002D6:  DATA 41,81
002D8:  DATA 80,40
002DA:  DATA 41,54
002DC:  DATA 2B,43
002DE:  DATA 4D,47
002E0:  DATA 46,3D
002E2:  DATA 31,00
002E4:  DATA 41,54
002E6:  DATA 2B,43
002E8:  DATA 4D,47
002EA:  DATA 53,3D
002EC:  DATA 22,00
*
00658:  DATA 41,54
0065A:  DATA 2B,43
0065C:  DATA 4D,47
0065E:  DATA 46,3D
00660:  DATA 31,00
*
01374:  MOVLB  7
01376:  MOVF   xBD,W
01378:  ANDLW  07
0137A:  MOVWF  00
0137C:  RRCF   xBD,W
0137E:  MOVWF  01
01380:  RRCF   01,F
01382:  RRCF   01,F
01384:  MOVLW  1F
01386:  ANDWF  01,F
01388:  MOVF   01,W
0138A:  ADDWF  xBE,W
0138C:  MOVWF  FE9
0138E:  MOVLW  00
01390:  ADDWFC xBF,W
01392:  MOVWF  FEA
01394:  MOVFF  FEF,01
01398:  INCF   00,F
0139A:  BRA    139E
0139C:  RRCF   01,F
0139E:  DECFSZ 00,F
013A0:  BRA    139C
013A2:  MOVLW  01
013A4:  ANDWF  01,F
013A6:  MOVLB  0
013A8:  RETURN 0
013AA:  MOVLB  7
013AC:  MOVF   xBE,W
013AE:  MULWF  xC0
013B0:  MOVFF  FF3,01
013B4:  MOVFF  FF4,00
013B8:  MULWF  xC1
013BA:  MOVF   FF3,W
013BC:  ADDWF  00,F
013BE:  MOVF   xBF,W
013C0:  MULWF  xC0
013C2:  MOVF   FF3,W
013C4:  ADDWFC 00,W
013C6:  MOVWF  02
013C8:  MOVLB  0
013CA:  RETURN 0
013CC:  MOVLB  7
013CE:  MOVF   xBD,W
013D0:  ANDLW  07
013D2:  MOVWF  00
013D4:  RRCF   xBD,W
013D6:  MOVWF  01
013D8:  RRCF   01,F
013DA:  RRCF   01,F
013DC:  MOVLW  1F
013DE:  ANDWF  01,F
013E0:  MOVF   01,W
013E2:  ADDWF  xBF,W
013E4:  MOVWF  FE9
013E6:  MOVLW  00
013E8:  ADDWFC xC0,W
013EA:  MOVWF  FEA
013EC:  CLRF   01
013EE:  INCF   01,F
013F0:  INCF   00,F
013F2:  BRA    13F6
013F4:  RLCF   01,F
013F6:  DECFSZ 00,F
013F8:  BRA    13F4
013FA:  MOVF   xBE,F
013FC:  BZ    1404
013FE:  MOVF   01,W
01400:  IORWF  FEF,F
01402:  BRA    140A
01404:  COMF   01,F
01406:  MOVF   01,W
01408:  ANDWF  FEF,F
0140A:  MOVLB  0
0140C:  GOTO   1462 (RETURN)
*
01A6A:  ADDWF  FE8,W
01A6C:  CLRF   FF7
01A6E:  RLCF   FF7,F
01A70:  ADDLW  85
01A72:  MOVWF  FF6
01A74:  MOVLW  1A
01A76:  ADDWFC FF7,F
01A78:  TBLRD*-
01A7A:  MOVF   FF5,W
01A7C:  MOVWF  FFA
01A7E:  TBLRD*
01A80:  MOVF   FF5,W
01A82:  MOVWF  FF9
01A84:  DATA 2E,16
01A86:  DATA 34,16
01A88:  DATA 3A,16
01A8A:  DATA 40,16
01A8C:  DATA 46,16
01A8E:  DATA 4C,16
01A90:  DATA 52,16
01A92:  DATA 58,16
01A94:  ADDWF  FE8,W
01A96:  CLRF   FF7
01A98:  RLCF   FF7,F
01A9A:  ADDLW  AF
01A9C:  MOVWF  FF6
01A9E:  MOVLW  1A
01AA0:  ADDWFC FF7,F
01AA2:  TBLRD*-
01AA4:  MOVF   FF5,W
01AA6:  MOVWF  FFA
01AA8:  TBLRD*
01AAA:  MOVF   FF5,W
01AAC:  MOVWF  FF9
01AAE:  DATA 3E,17
01AB0:  DATA 44,17
01AB2:  DATA 4A,17
01AB4:  DATA 50,17
01AB6:  DATA 56,17
01AB8:  DATA 5C,17
01ABA:  DATA 62,17
01ABC:  DATA 68,17
01ABE:  ADDWF  FE8,W
01AC0:  CLRF   FF7
01AC2:  RLCF   FF7,F
01AC4:  ADDLW  D9
01AC6:  MOVWF  FF6
01AC8:  MOVLW  1A
01ACA:  ADDWFC FF7,F
01ACC:  TBLRD*-
01ACE:  MOVF   FF5,W
01AD0:  MOVWF  FFA
01AD2:  TBLRD*
01AD4:  MOVF   FF5,W
01AD6:  MOVWF  FF9
01AD8:  DATA 82,18
01ADA:  DATA 88,18
01ADC:  DATA 8E,18
01ADE:  DATA 94,18
01AE0:  DATA 9A,18
01AE2:  DATA A0,18
01AE4:  DATA A6,18
01AE6:  DATA AC,18
01AE8:  ADDWF  FE8,W
01AEA:  CLRF   FF7
01AEC:  RLCF   FF7,F
01AEE:  ADDLW  03
01AF0:  MOVWF  FF6
01AF2:  MOVLW  1B
01AF4:  ADDWFC FF7,F
01AF6:  TBLRD*-
01AF8:  MOVF   FF5,W
01AFA:  MOVWF  FFA
01AFC:  TBLRD*
01AFE:  MOVF   FF5,W
01B00:  MOVWF  FF9
01B02:  DATA 90,19
01B04:  DATA 96,19
01B06:  DATA 9C,19
01B08:  DATA A2,19
01B0A:  DATA A8,19
01B0C:  DATA AE,19
01B0E:  DATA B4,19
01B10:  DATA BA,19
*
01D5C:  TBLRD*+
01D5E:  MOVF   FF5,F
01D60:  BZ    1D7A
01D62:  MOVFF  FF6,7B0
01D66:  MOVFF  FF7,7B1
01D6A:  MOVFF  FF5,7B2
01D6E:  RCALL  1D16
01D70:  MOVFF  7B0,FF6
01D74:  MOVFF  7B1,FF7
01D78:  BRA    1D5C
01D7A:  RETURN 0
*
058CE:  MOVF   FEF,F
058D0:  BZ    58F2
058D2:  MOVFF  FEA,7B1
058D6:  MOVFF  FE9,7B0
058DA:  MOVFF  FEF,7B2
058DE:  CALL   1D16
058E2:  MOVFF  7B1,FEA
058E6:  MOVFF  7B0,FE9
058EA:  INCF   FE9,F
058EC:  BTFSC  FD8.2
058EE:  INCF   FEA,F
058F0:  BRA    58CE
058F2:  RETURN 0
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
*
04256:  MOVFF  7B1,7B5
0425A:  MOVFF  7B0,7B4
0425E:  MOVFF  7B5,FEA
04262:  MOVLB  7
04264:  MOVFF  7B4,FE9
04268:  MOVF   FEF,F
0426A:  BZ    4278
0426C:  INCF   xB4,F
0426E:  BTFSC  FD8.2
04270:  INCF   xB5,F
04272:  MOVLB  0
04274:  BRA    425E
04276:  MOVLB  7
....................    while(*s2 != '\0')
04278:  MOVFF  7B3,FEA
0427C:  MOVFF  7B2,FE9
04280:  MOVF   FEF,F
04282:  BZ    42AA
....................    {
....................       *s = *s2;
04284:  MOVFF  7B3,FEA
04288:  MOVFF  7B2,FE9
0428C:  MOVFF  FEF,7B8
04290:  MOVFF  7B5,FEA
04294:  MOVFF  7B4,FE9
04298:  MOVFF  7B8,FEF
....................       ++s;
0429C:  INCF   xB4,F
0429E:  BTFSC  FD8.2
042A0:  INCF   xB5,F
....................       ++s2;
042A2:  INCF   xB2,F
042A4:  BTFSC  FD8.2
042A6:  INCF   xB3,F
042A8:  BRA    4278
....................    }
.................... 
....................    *s = '\0';
042AA:  MOVFF  7B5,FEA
042AE:  MOVFF  7B4,FE9
042B2:  CLRF   FEF
....................    return(s1);
042B4:  MOVFF  7B0,01
042B8:  MOVFF  7B1,02
042BC:  MOVLB  0
042BE:  RETURN 0
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
05854:  MOVFF  7B1,FEA
05858:  MOVLB  7
0585A:  MOVFF  7B0,FE9
0585E:  MOVFF  FEF,7B4
05862:  MOVFF  7B3,FEA
05866:  MOVFF  7B2,FE9
0586A:  MOVF   FEF,W
0586C:  SUBWF  xB4,W
0586E:  BNZ   589E
....................       if (*s1 == '\0')
05870:  MOVFF  7B1,03
05874:  MOVFF  7B0,FE9
05878:  MOVFF  03,FEA
0587C:  MOVF   FEF,F
0587E:  BNZ   5886
....................          return(0);
05880:  MOVLW  00
05882:  MOVWF  01
05884:  BRA    58C8
05886:  MOVFF  7B1,03
0588A:  MOVF   xB0,W
0588C:  INCF   xB0,F
0588E:  BTFSC  FD8.2
05890:  INCF   xB1,F
05892:  INCF   xB2,F
05894:  BTFSC  FD8.2
05896:  INCF   xB3,F
05898:  MOVLB  0
0589A:  BRA    5854
0589C:  MOVLB  7
....................    return((*s1 < *s2) ? -1: 1);
0589E:  MOVFF  7B1,03
058A2:  MOVFF  7B0,FE9
058A6:  MOVFF  03,FEA
058AA:  MOVFF  FEF,7B4
058AE:  MOVFF  7B3,03
058B2:  MOVFF  7B2,FE9
058B6:  MOVFF  03,FEA
058BA:  MOVF   FEF,W
058BC:  SUBWF  xB4,W
058BE:  BC    58C4
058C0:  MOVLW  FF
058C2:  BRA    58C6
058C4:  MOVLW  01
058C6:  MOVWF  01
058C8:  MOVLB  0
058CA:  GOTO   590A (RETURN)
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #include "D:\jobESP\ESPAN-04\Firmware\SPAN-04\ESPAN04_20 - Delay - SP - SMD - PIC18F252\ESPAN-04.h"
.................... //#include <18F252.h>
.................... #include <18F26K22.h>
.................... //////////// Standard Header file for the PIC18F26K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F26K22
.................... 
.................... #list
.................... 
.................... //#device adc=8
.................... #FUSES WDT
.................... #FUSES WDT64                    //Watch Dog Timer uses 1:64 Postscale
.................... //#FUSES HS                     //High speed Osc (> 4mhz)(for 18F2525)
.................... #fuses INTRC_IO         //High speed Osc, high power 16MHz-25MHz(for 18F26k22)
.................... #FUSES NOPROTECT                //Code not protected from reading
.................... //#FUSES IESO                     //Internal External Switch Over mode enabled
.................... #FUSES BROWNOUT                 //Reset when brownout detected
.................... //#FUSES BORV20                   //Brownout reset at 2.0V
.................... #FUSES NOPUT                    //No Power Up Timer
.................... #FUSES NOCPD                    //No EE protection
.................... //#FUSES STVREN                   //Stack full/underflow will cause reset
.................... //#FUSES LVP                      //Low Voltage Programming on B3(PIC16) or B5(PIC18)
.................... //#FUSES NOWRT                    //Program memory not write protected
.................... //#FUSES NOWRTD                   //Data EEPROM not write protected
.................... #FUSES NOEBTR                   //Memory not protected from table reads
.................... #FUSES NOCPB                    //No Boot Block code protection
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads
.................... #FUSES NOWRTC                   //configuration not registers write protected
.................... #FUSES NOWRTB                   //Boot block not write protected
.................... //#FUES FCMEN                    //Fail-safe clock monitor enabled
.................... 
.................... #FUSES NODEBUG                  //No Debug mode for ICD
.................... //#device icd = true
.................... 
.................... /* //jj
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode)
.................... #FUSES PBADEN                   //PORTB pins are configured as analog input channels on RESET
.................... #FUSES LPT1OSC                  //Timer1 configured for low-power operation
.................... #FUSES MCLR                     //Master Clear pin enabled
.................... */
.................... #define CLOCK_SP   16000000   //Clock Speed 20MHz
.................... 
.................... //23S17 Define
.................... #define IO_MULTIPLE_DEVICES
.................... #define IO_CS_PIN PIN_A5
.................... 
.................... #use delay(clock=16000000,RESTART_WDT)
*
00662:  MOVLW  07
00664:  MOVWF  FEA
00666:  MOVLW  B9
00668:  MOVWF  FE9
0066A:  MOVF   FEF,W
0066C:  BZ    0690
0066E:  MOVLW  05
00670:  MOVWF  01
00672:  MOVLW  BF
00674:  MOVWF  00
00676:  CLRWDT
00678:  DECFSZ 00,F
0067A:  BRA    0676
0067C:  DECFSZ 01,F
0067E:  BRA    0672
00680:  MOVLW  2E
00682:  MOVWF  00
00684:  DECFSZ 00,F
00686:  BRA    0684
00688:  NOP   
0068A:  CLRWDT
0068C:  DECFSZ FEF,F
0068E:  BRA    066E
00690:  RETURN 0
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8)
.................... 
.................... /*
.................... #include <16F886.h>
.................... #device adc=10
.................... 
.................... #FUSES WDT                      //Watch Dog Timer
.................... #FUSES HS                       //High speed Osc (> 4mhz)
.................... #FUSES NOPUT                    //No Power Up Timer
.................... //#FUSES MCLR                     //Master Clear pin enabled
.................... #FUSES PROTECT                  //Code protected from reads
.................... //#FUSES CPD                      //Data EEPROM Code Protected
.................... #FUSES NOBROWNOUT               //No brownout reset
.................... //#FUSES IESO                     //Internal External Switch Over mode enabled
.................... //#FUSES FCMEN                    //Fail-safe clock monitor enabled
.................... //#FUSES LVP                      //Low Voltage Programming on B3(PIC16) or B5(PIC18)
.................... #FUSES NODEBUG                  //No Debug mode for ICD
.................... //#FUSES BORV21                   //Brownout reset at 2.1V
.................... //#FUSES WRT                      //Program Memory Write Protected
.................... 
.................... #use delay(clock=20000000,RESTART_WDT)
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,restart_wdt)
.................... */
.................... 
.................... 
.................... #include "D:\jobESP\ESPAN-04\Firmware\SPAN-04\ESPAN04_20 - Delay - SP - SMD\23S17.c" // 16 bit I/O Expander
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                        23S17.c                                      ////
.................... ////                                                                   ////
.................... ////   Library for a MicroChip MCP23S17 SPI Port Expansion Chip        ////
.................... ////                                                                   ////
.................... //// The MCP23S17 device provides 16-bit, general purpose parallel I/O ////
.................... //// expansion for SPI applications. The 16-bit I/O port functionally  ////
.................... //// consists of two 8-bit ports (PORTA and PORTB). There are two      ////
.................... //// interrupt pins, INTA and INTB, that can be associated with their  ////
.................... //// respective ports, or can be logically ORed together so that both ////
.................... //// pins will activate if either port causes an interrupt. The        ////
.................... //// hardware address pins are used to determine the device address.   ////                                                 ////
.................... ////                                                                   ////
.................... ////  A #use spi must be provided by the main program.                 ////
.................... ////                                                                   ////
.................... ////  -------------------------------------------------------------    ////
.................... ////  PIN LAYOUT                                                       ////
.................... ////  -------------------------------------------------------------    ////
.................... ////                                                                    ////
.................... ////        -------------------------------------------                ////
.................... ////        | 1 : GPB0          | 28: GPA7            |                ////
.................... ////        |                   |                     |                ////
.................... ////        | 2 : GPB1          | 27: GPA6            |                ////
.................... ////        |                   |                     |                ////
.................... ////        | 3 : GPB2          | 26: GPA5            |                ////
.................... ////        |                   |                     |                ////
.................... ////        | 4 : GPB3          | 25: GPA4            |                ////
.................... ////        |                   |                     |                ////
.................... ////        | 5 : GPB4          | 24: GPA3            |                ////
.................... ////        |                   |                     |                ////
.................... ////        | 6 : GPB5          | 23: GPA2            |                ////
.................... ////        |                   |                     |                ////
.................... ////        | 7 : GPB6          | 22: GPA1            |                ////
.................... ////        |                   |                     |                ////
.................... ////        | 8 : GPB7          | 21: GPA0            |                ////
.................... ////        |                   |                     |                ////
.................... ////        | 9 : Vdd           | 20: INTA            |                ////
.................... ////        |                   |                     |                ////
.................... ////        | 10: Vss           | 19: INTB            |                ////
.................... ////        |     __            |     _____           |                ////
.................... ////        | 11: CS            | 18: RESET           |                ////
.................... ////        |                   |                     |                ////
.................... ////        | 12: SCK           | 17: A2              |                ////
.................... ////        |                   |                     |                ////
.................... ////        | 13: SI            | 16: A1              |                ////
.................... ////        |                   |                     |                ////
.................... ////        | 14: SO            | 15: A0              |                ////
.................... ////        -------------------------------------------                ////
.................... ////                                                                   ////
.................... ////  -------------------------------------------------------------    ////
.................... ////  FUNCTIONS                                                        ////
.................... ////  -------------------------------------------------------------    ////
.................... ////                                                                   ////
.................... ////   void IO_INIT()                                                   ////                   
.................... ////     Initializes the 23S17 chips on the SPI bus                      ////                                                 
.................... ////                                                                   ////  
.................... ////  void IO_WRITE_REGISTER(int8 address, int8 reg, int8 data)        ////
.................... ////     Writes the value to the specified register and device          ////                                                            
.................... ////                                                                   ////  
.................... ////  int8 IO_READ_REGISTER(int8 address, int8 reg);                    ////
.................... ////     Reads the value of the specified register and device          ////                                                           
.................... ////                                                                   ////  
.................... ////  void IO_OUTPUT_A(int8 address, int8 data);                       ////
.................... ////     Outputs the value to PORTA on the specified device. Doesn't   ////
.................... ////     change the direction of the port.                             ////
.................... ////                                                                   ////      
.................... ////  void IO_OUTPUT_B(int8 address, int8 data);                       ////
.................... ////     Outputs the value to PORTB on the specified device. Doesn't   ////
.................... ////     change the direction of the port.                             ////
.................... ////                                                                   ////      
.................... ////  int8 IO_INPUT_A(int8 address)                                    ////
.................... ////     Returns the value of PORTA on the specified device. Doesn't   ////
.................... ////     change the direction of the port.                             ////
.................... ////                                                                   ////      
.................... ////  int8 IO_INPUT_B(int8 address)                                    ////
.................... ////     Returns the value of PORTB on the specified device. Doesn't   ////
.................... ////     change the direction of the port.                             ////
.................... ////                                                                   ////      
.................... ////  void IO_OUTPUT_BIT(int8 address, int8 pin, int1 state)           ////
.................... ////     Outputs the value to specified pin and device. Doesn't change ////
.................... ////      the direction of the pin.                                     ////
.................... ////                                                                   ////      
.................... ////  void IO_OUTPUT_HIGH(int8 address, int8 pin)                      ////
.................... ////     Sets the output high on the specified pin and device. Doesn't ////
.................... ////     change the direction of the pin.                              ////
.................... ////                                                                   ////      
.................... ////  void IO_OUTPUT_LOW(int8 address, int8 pin)                       ////
.................... ////     Sets the output low on the specified pin and device. Doesn't  ////
.................... ////     change the direction of the pin.                              ////
.................... ////                                                                   ////   
.................... ////  void IO_OUTPUT_FLOAT(int8 address, int8 pin)                     ////
.................... ////     Sets the pin to an input on the specified device.             ////
.................... ////                                                                   ////
.................... ////  void IO_OUTPUT_TOGGLE(int8 address, int8 pin)                    ////
.................... ////     Toggles the output on the specified pin and device. Doesn't   ////
.................... ////     change the direction of the pin.                              ////
.................... ////                                                                   ////      
.................... ////  void IO_OUTPUT_DRIVE(int8 address, int8 pin)                     ////
.................... ////     Sets the pin to an output on the specified device.            ////
.................... ////                                                                   ////      
.................... ////  int1 IO_INPUT(int8 address, int8 pin)                            ////
.................... ////     Gets the current value on the specified pin and device.       ////
.................... ////                                                                   ////      
.................... ////  int1 IO_INPUT_STATE(int8 address, int8 pin)                      ////
.................... ////     Gets the current value on the specified pin and device.       //// 
.................... ////     Doesn't change the direction of the pin.                      ////
.................... ////                                                                   ////      
.................... ////  int8 IO_GET_TRIS_A(int8 address)                                 ////
.................... ////     Gets the data direction register for PORTA on the specified   //// 
.................... ////      device.                                                       ////
.................... ////                                                                   ////      
.................... ////  void IO_SET_TRIS_A(int8 address, int8 data)                      ////
.................... ////     Sets the data direction register for PORTA on the specified   //// 
.................... ////      device.                                                       ////
.................... ////                                                                   ////      
.................... ////  int8 IO_GET_TRIS_B(int8 address)                                 ////
.................... ////     Gets the data direction register for PORTB on the specified   //// 
.................... ////      device.                                                       ////
.................... ////                                                                   ////      
.................... ////  void IO_SET_TRIS_B(int8 address, int8 data)                      ////
.................... ////     Sets the data direction register for PORTB on the specified   //// 
.................... ////      device.                                                       ////
.................... ////                                                                   ////                                                                    ////
.................... ////  NOTE: address is only valid if IO_MULTIPLE_DEVICES is defined    ////
.................... ////        in your main program. Use the provided #defines as         ////
.................... ////        parameters for the address, pin, and reg fields.           ////
.................... ////                                                                    ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... //// VERSION HISTORY:                                                  ////
.................... ////                                                                   ////
.................... //// Author Date        Comments                                       ////
.................... //// -----  -------     ----------------------------------             ////
.................... //// TMH    Jul-29-2009 File Created                                   ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2009 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #ifndef MCP23S17
.................... #define MCP23S17
.................... 
.................... /******************************************************************************
.................... **** DEFINES
.................... ******************************************************************************/
.................... 
.................... //This is the device address mask. Device supports up to 8 of the chips on the
.................... //same bus. If multiple devices are to be used on the same bus, define 
.................... //IO_MULTIPLE_DEVICES in your program. This will add an address field to all 
.................... //functions. If IO_MULTIPLE_DEVICE is not defined, an address of 0 will be 
.................... //assumed (i.e. ground A2, A1, A0)
.................... #define IO_DEVICE_ADDRESS_READ   0b01000001
.................... #define IO_DEVICE_ADDRESS_WRITE  0b01000000
.................... 
.................... //User must define a CS pin in main. This pin can be connected to all similar
.................... //devices on the bus.
.................... //!#ifndef IO_CS_PIN
.................... //!#error Must define a chip select pin.
.................... //!#endif
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Address Defines
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Use these in the address field if using multiple 23S17 devices. If bit 3
.................... //// in IOCON is cleared these no longer work and only device 0 can be operated
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifdef IO_MULTIPLE_DEVICES
.................... 
.................... #define IO_DEVICE_0   0b00000000
.................... #define IO_DEVICE_1   0b00000010
.................... #define IO_DEVICE_2   0b00000100
.................... #define IO_DEVICE_3   0b00000110
.................... #define IO_DEVICE_4   0b00001000
.................... #define IO_DEVICE_5   0b00001010
.................... #define IO_DEVICE_6   0b00001100
.................... #define IO_DEVICE_7   0b00001110
.................... 
.................... #endif
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Device Register Defines
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Used in the reg field. If IOCON bit 7 is cleared these no longer are 
.................... //// correct, use values to right. Refer to data sheet for more information
.................... //// on their use.
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #define IODIRA      0x00     //0x00   Data Direction Register for PORTA
.................... #define IPOLA     0x01     //0x02   Input Polarity Register for PORTA
.................... #define GPINTENA    0x02     //0x04     Interrupt-on-change enable Register for PORTA                        
.................... #define DEFVALA   0x03     //0x06   Default Value Register for PORTA
.................... #define INTCONA   0x04     //0x08   Interrupt-on-change control Register for PORTA                          
.................... #define IOCON      0x05     //0x0A   Configuration register for device                      
.................... #define GPPUA      0x06     //0x0C   100kOhm pullup resistor register for PORTA (sets pin to input when set)                           
.................... #define INTFA      0x07     //0x0E   Interrupt flag Register for PORTA                             
.................... #define INTCAPA   0x08     //0x10   Interrupt captured value Register for PORTA                  
.................... #define GPIOA      0x09     //0x12   General purpose I/O Register for PORTA                            
.................... #define OLATA      0x0A     //0x14   Output latch Register for PORTA
.................... 
.................... #define IODIRB    0x10     //0x01   Data Direction Register for PORTB
.................... #define IPOLB     0x11     //0x03   Input Polarity Register for PORTB
.................... #define GPINTENB    0x12     //0x05     Interrupt-on-change enable Register for PORTB
.................... #define DEFVALB   0x13     //0x07   Default Value Register for PORTB
.................... #define INTCONB   0x14     //0x09   Interrupt-on-change control Register for PORTB
.................... //#define IOCON      0x15     //0x0B   //IOCON has 2 different addresses, both write to same register                              
.................... #define GPPUB      0x16     //0x0D   100kOhm pullup resistor register for PORTB (sets pin to input when set)
.................... #define INTFB      0x17     //0x0F   Interrupt flag Register for PORTB 
.................... #define INTCAPB   0x18     //0x11   Interrupt captured value Register for PORTB
.................... #define GPIOB      0x19     //0x13   General purpose I/O Register for PORTB
.................... #define OLATB      0x1A     //0x15   Output latch Register for PORTB
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Pin Defines
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Use in the Pin field.
.................... ///////////////////////////////////////////////////////////////////////////////
.................... 
.................... #define IO_PIN_A0      0x80
.................... #define IO_PIN_A1      0x81
.................... #define IO_PIN_A2      0x82
.................... #define IO_PIN_A3      0x83
.................... #define IO_PIN_A4      0x84
.................... #define IO_PIN_A5      0x85
.................... #define IO_PIN_A6      0x86
.................... #define IO_PIN_A7      0x87
.................... 
.................... #define IO_PIN_B0      0x00
.................... #define IO_PIN_B1      0x01
.................... #define IO_PIN_B2      0x02
.................... #define IO_PIN_B3      0x03
.................... #define IO_PIN_B4      0x04
.................... #define IO_PIN_B5      0x05
.................... #define IO_PIN_B6      0x06
.................... #define IO_PIN_B7      0x07
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IOCON Bits
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// OR wanted options together when setting the IOCON register.
.................... ///////////////////////////////////////////////////////////////////////////////
.................... 
.................... #define IO_IOCON_BANK      0x80   //Sets register addresses. Initialized to 1.                            
.................... #define IO_IOCON_MIRROR    0x40   //Internally connect interrupt PINs. 
.................... #define IO_IOCON_SEQOP     0x20   //Sets ~Sequential/Byte mode. Driver only uses byte mode.
.................... #define IO_IOCON_DISSLW    0x10    //Enables slew rate for SDA output                             
.................... #define IO_IOCON_HAEN      0x08   //Enables hardware address pins. If 0 only one device can be used.
.................... #define IO_IOCON_ODR       0x04   //Open drain/~active drive interrupt pin outputs
.................... #define IO_IOCON_INTPOL    0x02   //Sets INT output as active high/~low
.................... 
.................... /******************************************************************************
.................... **** FUNCTION PROTOTYPES
.................... ******************************************************************************/
.................... 
.................... void IO_INIT();   //don't need multiple inits because all devices are assumed 0 before HAEN is set
.................... 
.................... #ifndef IO_MULTIPLE_DEVICES
.................... void IO_WRITE_REGISTER(int8 reg, int8 data);
.................... int8 IO_READ_REGISTER(int8 reg);
.................... void IO_OUTPUT_A(int8 data);
.................... void IO_OUTPUT_B(int8 data);
.................... int8 IO_INPUT_A();
.................... int8 IO_INPUT_B();
.................... void IO_OUTPUT_BIT(int8 pin, int1 state);
.................... void IO_OUTPUT_HIGH(int8 pin);
.................... void IO_OUTPUT_LOW(int8 pin);
.................... void IO_OUTPUT_FLOAT(int8 pin);
.................... void IO_OUTPUT_TOGGLE(int8 pin);
.................... void IO_OUTPUT_DRIVE(int8 pin);
.................... int1 IO_INPUT(int8 pin);
.................... int1 IO_INPUT_STATE(int8 pin);
.................... int8 IO_GET_TRIS_A();
.................... void IO_SET_TRIS_A(int8 data);
.................... int8 IO_GET_TRIS_B();
.................... void IO_SET_TRIS_B(int8 data);
.................... #else
.................... void IO_WRITE_REGISTER(int8 address, int8 reg, int8 data);
.................... int8 IO_READ_REGISTER(int8 address, int8 reg);
.................... void IO_OUTPUT_A(int8 address, int8 data);
.................... void IO_OUTPUT_B(int8 address, int8 data);
.................... int8 IO_INPUT_A(int8 address);
.................... int8 IO_INPUT_B(int8 address);
.................... void IO_OUTPUT_BIT(int8 address, int8 pin, int1 state);
.................... void IO_OUTPUT_HIGH(int8 address, int8 pin);
.................... void IO_OUTPUT_LOW(int8 address, int8 pin);
.................... void IO_OUTPUT_FLOAT(int8 address, int8 pin);
.................... void IO_OUTPUT_TOGGLE(int8 address, int8 pin);
.................... void IO_OUTPUT_DRIVE(int8 address, int8 pin);
.................... int1 IO_INPUT(int8 address, int8 pin);
.................... int1 IO_INPUT_STATE(int8 address, int8 pin);
.................... int8 IO_GET_TRIS_A(int8 address);
.................... void IO_SET_TRIS_A(int8 address, int8 data);
.................... int8 IO_GET_TRIS_B(int8 address);
.................... void IO_SET_TRIS_B(int8 address, int8 data);
.................... #endif
.................... 
.................... /******************************************************************************
.................... **** FUNCTIONS
.................... ******************************************************************************/
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_INIT
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Must be called before anything else. Enables the MCP23S17 chip to have 
.................... //// the following settings:
.................... ////      IO_IOCON_BANK    = 1    Sets addresses to align with the #defines
.................... ////      IO_IOCON_MIRROR  = 0      INT pins are not internally connected
.................... ////      IO_IOCON_SEQOP     = 1      Operating in Byte mode   
.................... ////      IO_IOCON_DISSLW  = 0      SDA output slew rate is enabled                             
.................... ////      IO_IOCON_HAEN     = x      A2, A1, A0 enabled only if IO_MULTIPLE_DEVICES is defined   
.................... ////      IO_IOCON_ODR      = 0      Interrupt will drive its level   
.................... ////      IO_IOCON_INTPOL  = 1      Interrupt is active-high
.................... ////
.................... //// If different settings are required, use an IO_WRITE_REGISTER() with IOCON
.................... //// as the reg parameter. Note: if IO_IOCON_BANK is cleared then the #defines
.................... //// for the register values are no longer valid.
.................... ///////////////////////////////////////////////////////////////////////////////
.................... void IO_INIT(){
.................... 
....................    output_high(IO_CS_PIN);
*
006C4:  BCF    F92.5
006C6:  BSF    F89.5
....................    output_drive(IO_CS_PIN);
006C8:  BCF    F92.5
....................    #ifndef IO_MULTIPLE_DEVICES
....................    IO_WRITE_REGISTER(0x0A, 0xA2);   //IOCON's address is 0xA until IOCON.Bank is set                         
....................    #else
....................    IO_WRITE_REGISTER(IO_DEVICE_0, 0x0A, 0xAA);
006CA:  MOVLB  7
006CC:  CLRF   xBA
006CE:  MOVLW  0A
006D0:  MOVWF  xBB
006D2:  MOVLW  AA
006D4:  MOVWF  xBC
006D6:  MOVLB  0
006D8:  RCALL  0692
....................    IO_WRITE_REGISTER(IO_DEVICE_1, 0x0A, 0xAA);  //Edit by Jack
006DA:  MOVLW  02
006DC:  MOVLB  7
006DE:  MOVWF  xBA
006E0:  MOVLW  0A
006E2:  MOVWF  xBB
006E4:  MOVLW  AA
006E6:  MOVWF  xBC
006E8:  MOVLB  0
006EA:  RCALL  0692
....................    IO_WRITE_REGISTER(IO_DEVICE_2, 0x0A, 0xAA);  //Edit by Jack
006EC:  MOVLW  04
006EE:  MOVLB  7
006F0:  MOVWF  xBA
006F2:  MOVLW  0A
006F4:  MOVWF  xBB
006F6:  MOVLW  AA
006F8:  MOVWF  xBC
006FA:  MOVLB  0
006FC:  RCALL  0692
....................    IO_WRITE_REGISTER(IO_DEVICE_3, 0x0A, 0xAA);  //Edit by Jack
006FE:  MOVLW  06
00700:  MOVLB  7
00702:  MOVWF  xBA
00704:  MOVLW  0A
00706:  MOVWF  xBB
00708:  MOVLW  AA
0070A:  MOVWF  xBC
0070C:  MOVLB  0
0070E:  RCALL  0692
....................    IO_WRITE_REGISTER(IO_DEVICE_4, 0x0A, 0xAA);  //Edit by Jack
00710:  MOVLW  08
00712:  MOVLB  7
00714:  MOVWF  xBA
00716:  MOVLW  0A
00718:  MOVWF  xBB
0071A:  MOVLW  AA
0071C:  MOVWF  xBC
0071E:  MOVLB  0
00720:  RCALL  0692
....................    IO_WRITE_REGISTER(IO_DEVICE_5, 0x0A, 0xAA);  //Edit by Jack
00722:  MOVLW  0A
00724:  MOVLB  7
00726:  MOVWF  xBA
00728:  MOVWF  xBB
0072A:  MOVLW  AA
0072C:  MOVWF  xBC
0072E:  MOVLB  0
00730:  RCALL  0692
....................    IO_WRITE_REGISTER(IO_DEVICE_6, 0x0A, 0xAA);  //Edit by Jack
00732:  MOVLW  0C
00734:  MOVLB  7
00736:  MOVWF  xBA
00738:  MOVLW  0A
0073A:  MOVWF  xBB
0073C:  MOVLW  AA
0073E:  MOVWF  xBC
00740:  MOVLB  0
00742:  RCALL  0692
....................    IO_WRITE_REGISTER(IO_DEVICE_7, 0x0A, 0xAA);  //Edit by Jack
00744:  MOVLW  0E
00746:  MOVLB  7
00748:  MOVWF  xBA
0074A:  MOVLW  0A
0074C:  MOVWF  xBB
0074E:  MOVLW  AA
00750:  MOVWF  xBC
00752:  MOVLB  0
00754:  RCALL  0692
....................    #endif
00756:  GOTO   5ABC (RETURN)
.................... }
.................... 
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_WRITE_REGISTER
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Sets the value of the specified register.
.................... ////
.................... //// Parameters:
.................... ////      reg - the register to be written. use provided defines.
.................... ////      data - the data to be written.
.................... ////     address - address of the device. use provided defines.
.................... ////
.................... //// Returns:
.................... ////      void
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifndef IO_MULTIPLE_DEVICES
.................... void IO_WRITE_REGISTER(int8 reg, int8 data){
.................... #else
.................... void IO_WRITE_REGISTER(int8 address, int8 reg, int8 data){
.................... #endif
....................    
....................    output_low(IO_CS_PIN);
*
00692:  BCF    F92.5
00694:  BCF    F89.5
....................    
....................    #ifndef IO_MULTIPLE_DEVICES
....................    spi_write(IO_DEVICE_ADDRESS_WRITE);
....................    #else
....................    spi_write(IO_DEVICE_ADDRESS_WRITE | address);
00696:  MOVLB  7
00698:  MOVF   xBA,W
0069A:  IORLW  40
0069C:  MOVWF  xBD
0069E:  MOVF   FC9,W
006A0:  MOVFF  7BD,FC9
006A4:  RRCF   FC7,W
006A6:  BNC   06A4
....................    #endif
....................    
....................    spi_write(reg);
006A8:  MOVF   FC9,W
006AA:  MOVFF  7BB,FC9
006AE:  RRCF   FC7,W
006B0:  BNC   06AE
....................    spi_write(data);
006B2:  MOVF   FC9,W
006B4:  MOVFF  7BC,FC9
006B8:  RRCF   FC7,W
006BA:  BNC   06B8
....................    
....................    output_high(IO_CS_PIN);
006BC:  BCF    F92.5
006BE:  BSF    F89.5
006C0:  MOVLB  0
006C2:  RETURN 0
.................... 
.................... }
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_READ_REGISTER
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Gets the current value of the specified register.
.................... ////
.................... //// Parameters:
.................... ////      reg - the register to be read. use provided defines.
.................... ////     address - address of the device. use provided defines.
.................... ////
.................... //// Returns:
.................... ////      int8 - the current value of the requested register
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifndef IO_MULTIPLE_DEVICES
.................... int8 IO_READ_REGISTER(int8 reg){
.................... #else
.................... int8 IO_READ_REGISTER(int8 address, int8 reg){
.................... #endif
....................    int8 retVal;
.................... 
....................    output_low(IO_CS_PIN);
*
01300:  BCF    F92.5
01302:  BCF    F89.5
....................    
....................    #ifndef IO_MULTIPLE_DEVICES
....................    spi_write(IO_DEVICE_ADDRESS_READ);
....................    #else
....................    spi_write(IO_DEVICE_ADDRESS_READ | address);
01304:  MOVLB  7
01306:  MOVF   xBC,W
01308:  IORLW  41
0130A:  MOVWF  xBF
0130C:  MOVF   FC9,W
0130E:  MOVFF  7BF,FC9
01312:  RRCF   FC7,W
01314:  BNC   1312
....................    #endif
....................    
....................    spi_write(reg);
01316:  MOVF   FC9,W
01318:  MOVFF  7BD,FC9
0131C:  RRCF   FC7,W
0131E:  BNC   131C
....................    retVal = spi_read(0);
01320:  MOVF   FC9,W
01322:  CLRF   FC9
01324:  RRCF   FC7,W
01326:  BNC   1324
01328:  MOVFF  FC9,7BE
....................    
....................    output_high(IO_CS_PIN);
0132C:  BCF    F92.5
0132E:  BSF    F89.5
....................    
....................    return retVal;
01330:  MOVFF  7BE,01
01334:  MOVLB  0
01336:  RETURN 0
.................... 
.................... }
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_OUTPUT_A
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Sets the current output value of Port A. Does NOT change the PORT's 
.................... //// direction
.................... ////
.................... //// Parameters:
.................... ////      data - the value to be written to Port A
.................... ////     address - address of the device. use provided defines.
.................... ////
.................... //// Returns:
.................... ////      void
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifndef IO_MULTIPLE_DEVICES
.................... void IO_OUTPUT_A(int8 data){
.................... #else
.................... void IO_OUTPUT_A(int8 address, int8 data){
.................... #endif
.................... 
....................    #ifndef IO_MULTIPLE_DEVICES
....................    IO_WRITE_REGISTER(OLATA, data);
....................    #else
....................    IO_WRITE_REGISTER(address, OLATA, data);
*
01B12:  MOVFF  7B8,7BA
01B16:  MOVLW  0A
01B18:  MOVLB  7
01B1A:  MOVWF  xBB
01B1C:  MOVFF  7B9,7BC
01B20:  MOVLB  0
01B22:  CALL   0692
....................    #endif
01B26:  RETURN 0
.................... 
.................... }
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_OUTPUT_B
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Sets the current output value of Port B. Does NOT change the PORT's 
.................... //// direction
.................... ////
.................... //// Parameters:
.................... ////      data - the value to be written to Port B
.................... ////     address - address of the device. use provided defines.
.................... ////
.................... //// Returns:
.................... ////      void
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifndef IO_MULTIPLE_DEVICES
.................... void IO_OUTPUT_B(int8 data){
.................... #else
.................... void IO_OUTPUT_B(int8 address, int8 data){
.................... #endif
.................... 
....................    #ifndef IO_MULTIPLE_DEVICES
....................    IO_WRITE_REGISTER(OLATB, data);
....................    #else
....................    IO_WRITE_REGISTER(address, OLATB, data);
01B28:  MOVFF  7B8,7BA
01B2C:  MOVLW  1A
01B2E:  MOVLB  7
01B30:  MOVWF  xBB
01B32:  MOVFF  7B9,7BC
01B36:  MOVLB  0
01B38:  CALL   0692
....................    #endif
01B3C:  RETURN 0
.................... 
.................... }
.................... 
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_INPUT_A
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Gets the current input value of Port A. Does NOT change the PORT's 
.................... //// direction
.................... ////
.................... //// Parameters:
.................... ////     address - address of the device. use provided defines.
.................... ////
.................... //// Returns:
.................... ////      int8 - PORTA's input value
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifndef IO_MULTIPLE_DEVICES
.................... int8 IO_INPUT_A(){
.................... #else
.................... int8 IO_INPUT_A(int8 address){
.................... #endif
.................... 
....................    int8 retVal;
....................    
....................    #ifndef IO_MULTIPLE_DEVICES
....................    retVal = IO_READ_REGISTER(GPIOA);
....................    #else
....................    retVal = IO_READ_REGISTER(address, GPIOA);
*
01338:  MOVFF  7BA,7BC
0133C:  MOVLW  09
0133E:  MOVLB  7
01340:  MOVWF  xBD
01342:  MOVLB  0
01344:  RCALL  1300
01346:  MOVFF  01,7BB
....................    #endif
....................    
....................    return retVal;
0134A:  MOVLB  7
0134C:  MOVFF  7BB,01
01350:  MOVLB  0
01352:  GOTO   1478 (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_INPUT_B
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Gets the current input value of Port B. Does NOT change the PORT's 
.................... //// direction
.................... ////
.................... //// Parameters:
.................... ////     address - address of the device. use provided defines.
.................... ////
.................... //// Returns:
.................... ////      int8 - PORTB's input value
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifndef IO_MULTIPLE_DEVICES
.................... int8 IO_INPUT_B(){
.................... #else
.................... int8 IO_INPUT_B(int8 address){
.................... #endif
.................... 
....................    int8 retVal;
....................    
....................    #ifndef IO_MULTIPLE_DEVICES
....................    retVal = IO_READ_REGISTER(GPIOB);
....................    #else
....................    retVal = IO_READ_REGISTER(address, GPIOB);
01356:  MOVFF  7BA,7BC
0135A:  MOVLW  19
0135C:  MOVLB  7
0135E:  MOVWF  xBD
01360:  MOVLB  0
01362:  RCALL  1300
01364:  MOVFF  01,7BB
....................    #endif
....................    
....................    return retVal;
01368:  MOVLB  7
0136A:  MOVFF  7BB,01
0136E:  MOVLB  0
01370:  GOTO   1512 (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_OUTPUT_BIT
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Sets the specified PIN to the desired state. Does NOT change the PIN's 
.................... //// direction
.................... ////
.................... //// Parameters:
.................... ////      pin - pin to be changed. use provided defines.
.................... ////     address - address of the device. use provided defines.
.................... ////
.................... //// Returns:
.................... ////      void
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifndef IO_MULTIPLE_DEVICES
.................... void IO_OUTPUT_BIT(int8 pin, int1 state){
.................... #else
.................... void IO_OUTPUT_BIT(int8 address, int8 pin, int1 state){
.................... #endif
....................    
....................    int8 tempReg;
....................    
....................    if(bit_test(pin, 7)){ //PIN A
....................       #ifndef IO_MULTIPLE_DEVICES
....................       tempReg = IO_READ_REGISTER(OLATA);
....................       #else
....................       tempReg = IO_READ_REGISTER(address, OLATA);
....................       #endif
....................       if(state){    //set high                      
....................          bit_set(tempReg, pin &0x0F);     
....................       }else{        //set low                      
....................          bit_clear(tempReg, pin &0x0F);
....................       }
....................       #ifndef IO_MULTIPLE_DEVICES
....................       IO_WRITE_REGISTER(OLATA, tempReg);
....................       #else
....................       IO_WRITE_REGISTER(address, OLATA, tempReg);
....................       #endif
....................    }else{    //PIN B   
....................       #ifndef IO_MULTIPLE_DEVICES
....................       tempReg = IO_READ_REGISTER(OLATB);
....................       #else
....................       tempReg = IO_READ_REGISTER(address, OLATB);
....................       #endif
....................       if(state){    //set high                      
....................          bit_set(tempReg, pin);      
....................       }else{        //set low                      
....................          bit_clear(tempReg, pin);
....................       }
....................       #ifndef IO_MULTIPLE_DEVICES
....................       IO_WRITE_REGISTER(OLATB, tempReg);
....................       #else
....................       IO_WRITE_REGISTER(address, OLATB, tempReg);
....................       #endif
....................    }
.................... 
.................... }
.................... 
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_OUTPUT_HIGH
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Sets the specified PIN to output high. Does NOT change the PIN's direction
.................... ////
.................... //// Parameters:
.................... ////      pin - pin to be set. use provided defines.
.................... ////     address - address of the device. use provided defines.
.................... ////
.................... //// Returns:
.................... ////      void
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifndef IO_MULTIPLE_DEVICES
.................... void IO_OUTPUT_HIGH(int8 pin){
.................... #else
.................... void IO_OUTPUT_HIGH(int8 address, int8 pin){
.................... #endif
.................... 
....................    int8 tempReg;
....................    
....................    if(bit_test(pin, 7)){ //PIN A
....................       #ifndef IO_MULTIPLE_DEVICES
....................       tempReg = IO_READ_REGISTER(OLATA);
....................       #else
....................       tempReg = IO_READ_REGISTER(address, OLATA);
....................       #endif
....................       bit_set(tempReg, pin &0x0F); 
....................       #ifndef IO_MULTIPLE_DEVICES
....................       IO_WRITE_REGISTER(OLATA, tempReg);
....................       #else
....................       IO_WRITE_REGISTER(address, OLATA, tempReg);
....................       #endif
....................    }else{    //PIN B   
....................       #ifndef IO_MULTIPLE_DEVICES
....................       tempReg = IO_READ_REGISTER(OLATB);
....................       #else
....................       tempReg = IO_READ_REGISTER(address, OLATB);
....................       #endif
....................       bit_set(tempReg, pin); 
....................       #ifndef IO_MULTIPLE_DEVICES
....................       IO_WRITE_REGISTER(OLATB, tempReg);
....................       #else
....................       IO_WRITE_REGISTER(address, OLATB, tempReg);
....................       #endif
....................    }
.................... 
.................... }
.................... 
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_OUTPUT_LOW
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Sets the specified PIN to output low. Does NOT change the PIN's direction
.................... ////
.................... //// Parameters:
.................... ////      pin - pin to be cleared. use provided defines.
.................... ////     address - address of the device. use provided defines.
.................... ////
.................... //// Returns:
.................... ////      void
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifndef IO_MULTIPLE_DEVICES
.................... void IO_OUTPUT_LOW(int8 pin){
.................... #else
.................... void IO_OUTPUT_LOW(int8 address, int8 pin){
.................... #endif
.................... 
....................    int8 tempReg;
....................    
....................    if(bit_test(pin, 7)){ //PIN A
....................       #ifndef IO_MULTIPLE_DEVICES
....................       tempReg = IO_READ_REGISTER(OLATA);
....................       #else
....................       tempReg = IO_READ_REGISTER(address, OLATA);
....................       #endif
....................       bit_clear(tempReg, pin &0x0F);
....................       #ifndef IO_MULTIPLE_DEVICES
....................       IO_WRITE_REGISTER(OLATA, tempReg);
....................       #else
....................       IO_WRITE_REGISTER(address, OLATA, tempReg);
....................       #endif
....................    }else{    //PIN B   
....................       #ifndef IO_MULTIPLE_DEVICES
....................       tempReg = IO_READ_REGISTER(OLATB);
....................       #else
....................       tempReg = IO_READ_REGISTER(address, OLATB);
....................       #endif
....................       bit_clear(tempReg, pin);
....................       #ifndef IO_MULTIPLE_DEVICES
....................       IO_WRITE_REGISTER(OLATB, tempReg);
....................       #else
....................       IO_WRITE_REGISTER(address, OLATB, tempReg);
....................       #endif
....................    }
.................... 
.................... }
.................... 
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_OUTPUT_FLOAT
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Sets the specified PIN to an input.
.................... ////
.................... //// Parameters:
.................... ////      pin - pin to be changed. use provided defines.
.................... ////     address - address of the device. use provided defines.
.................... ////
.................... //// Returns:
.................... ////      void
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifndef IO_MULTIPLE_DEVICES
.................... void IO_OUTPUT_FLOAT(int8 pin){
.................... #else
.................... void IO_OUTPUT_FLOAT(int8 address, int8 pin){
.................... #endif
.................... 
....................    int8 tempReg;
....................    
....................    if(bit_test(pin, 7)){ //PIN A
....................       #ifndef IO_MULTIPLE_DEVICES
....................       tempReg = IO_GET_TRIS_A();
....................       #else
....................       tempReg = IO_GET_TRIS_A(address);
....................       #endif
....................       bit_set(tempReg, pin &0x0F); 
....................       #ifndef IO_MULTIPLE_DEVICES
....................       IO_SET_TRIS_A(tempReg);
....................       #else
....................       IO_SET_TRIS_A(address, tempReg);
....................       #endif
....................    }else{    //PIN B   
....................       #ifndef IO_MULTIPLE_DEVICES
....................       tempReg = IO_GET_TRIS_B();
....................       #else
....................       tempReg = IO_GET_TRIS_B(address);
....................       #endif
....................       bit_set(tempReg, pin);      
....................       #ifndef IO_MULTIPLE_DEVICES
....................       IO_SET_TRIS_B(tempReg);
....................       #else
....................       IO_SET_TRIS_B(address, tempReg);
....................       #endif
....................    }
.................... 
.................... }
.................... 
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_OUTPUT_TOGGLE
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Toggles the specified PIN's output.
.................... ////
.................... //// Parameters:
.................... ////      pin - pin to be toggled. use provided defines.
.................... ////     address - address of the device. use provided defines.
.................... ////
.................... //// Returns:
.................... ////      void
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifndef IO_MULTIPLE_DEVICES
.................... void IO_OUTPUT_TOGGLE(int8 pin){
.................... #else
.................... void IO_OUTPUT_TOGGLE(int8 address, int8 pin){
.................... #endif
.................... 
....................    int8 tempReg;
....................    
....................    if(bit_test(pin, 7)){ //PIN A
....................       #ifndef IO_MULTIPLE_DEVICES
....................       tempReg = IO_READ_REGISTER(OLATA);
....................       #else
....................       tempReg = IO_READ_REGISTER(address, OLATA);
....................       #endif
....................       tempReg ^= (1<< (pin&0x0F));
....................       #ifndef IO_MULTIPLE_DEVICES
....................       IO_WRITE_REGISTER(OLATA, tempReg);
....................       #else
....................       IO_WRITE_REGISTER(address, OLATA, tempReg);
....................       #endif
....................    }else{    //PIN B   
....................       #ifndef IO_MULTIPLE_DEVICES
....................       tempReg = IO_READ_REGISTER(OLATB);
....................       #else
....................       tempReg = IO_READ_REGISTER(address, OLATB);
....................       #endif
....................       tempReg ^= (1<< (pin&0x0F));
....................       #ifndef IO_MULTIPLE_DEVICES
....................       IO_WRITE_REGISTER(OLATB, tempReg);
....................       #else
....................       IO_WRITE_REGISTER(address, OLATB, tempReg);
....................       #endif
....................    }
.................... 
.................... }
.................... 
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_OUTPUT_DRIVE
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Sets the specified PIN to an output.
.................... ////
.................... //// Parameters:
.................... ////      pin - pin to be changed. use provided defines.
.................... ////     address - address of the device. use provided defines.
.................... ////
.................... //// Returns:
.................... ////      void
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifndef IO_MULTIPLE_DEVICES
.................... void IO_OUTPUT_DRIVE(int8 pin){
.................... #else
.................... void IO_OUTPUT_DRIVE(int8 address, int8 pin){
.................... #endif
.................... 
....................    int8 tempReg;
....................    
....................    if(bit_test(pin, 7)){ //PIN A
....................       #ifndef IO_MULTIPLE_DEVICES
....................       tempReg = IO_GET_TRIS_A();
....................       #else
....................       tempReg = IO_GET_TRIS_A(address);
....................       #endif
....................       bit_clear(tempReg, pin &0x0F);
....................       #ifndef IO_MULTIPLE_DEVICES
....................       IO_SET_TRIS_A(tempReg);
....................       #else
....................       IO_SET_TRIS_A(address, tempReg);
....................       #endif
....................    }else{    //PIN B   
....................       #ifndef IO_MULTIPLE_DEVICES
....................       tempReg = IO_GET_TRIS_B();
....................       #else
....................       tempReg = IO_GET_TRIS_B(address);
....................       #endif
....................       bit_clear(tempReg, pin);      
....................       #ifndef IO_MULTIPLE_DEVICES
....................       IO_SET_TRIS_B(tempReg);
....................       #else
....................       IO_SET_TRIS_B(address, tempReg);
....................       #endif
....................    }
.................... 
.................... }
.................... 
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_INPUT
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Gets the specified PIN's current input. Changes the PIN's direction to an
.................... //// input.
.................... ////
.................... //// Parameters:
.................... ////      pin - pin to be read. use provided defines.
.................... ////     address - address of the device. use provided defines.
.................... ////
.................... //// Returns:
.................... ////      int1 - the state of the pin
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifndef IO_MULTIPLE_DEVICES
.................... int1 IO_INPUT(int8 pin){
.................... #else
.................... int1 IO_INPUT(int8 address, int8 pin){
.................... #endif
....................    int1 retVal;
....................    int8 tempReg;
....................    
....................    #ifndef IO_MULTIPLE_DEVICES
....................    IO_OUTPUT_FLOAT(pin);
....................    #else
....................    IO_OUTPUT_FLOAT(address, pin);
....................    #endif
....................    
....................    if(bit_test(pin, 7)){
....................       #ifndef IO_MULTIPLE_DEVICES
....................       tempReg = IO_READ_REGISTER(GPIOA);
....................       #else
....................       tempReg = IO_READ_REGISTER(address, GPIOA);
....................       #endif
....................    }else{
....................       #ifndef IO_MULTIPLE_DEVICES
....................       tempReg = IO_READ_REGISTER(GPIOB);
....................       #else
....................       tempReg = IO_READ_REGISTER(address, GPIOB);
....................       #endif
....................    }
....................    retVal = bit_test(tempReg, pin&0x0F);
....................    
....................    return retVal;
.................... 
.................... }
.................... 
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_INPUT_STATE
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Gets the specified PIN's current input. Does NOT change the PIN's direction
.................... ////
.................... //// Parameters:
.................... ////      pin - pin to be read. use provided defines.
.................... ////     address - address of the device. use provided defines.
.................... ////
.................... //// Returns:
.................... ////      int1 - the state of the pin
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifndef IO_MULTIPLE_DEVICES
.................... int1 IO_INPUT_STATE(int8 pin){
.................... #else
.................... int1 IO_INPUT_STATE(int8 address, int8 pin){
.................... #endif
....................    int1 retVal;
....................    int8 tempReg;
....................    
....................    if(bit_test(pin, 7)){
....................       #ifndef IO_MULTIPLE_DEVICES
....................       tempReg = IO_READ_REGISTER(GPIOA);
....................       #else
....................       tempReg = IO_READ_REGISTER(address, GPIOA);
....................       #endif
....................    }else{
....................       #ifndef IO_MULTIPLE_DEVICES
....................       tempReg = IO_READ_REGISTER(GPIOB);
....................       #else
....................       tempReg = IO_READ_REGISTER(address, GPIOB);
....................       #endif
....................    }
....................    retVal = bit_test(tempReg, pin&0x0F);
....................    
....................    return retVal;
.................... 
.................... }
.................... 
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_GET_TRIS_A
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Gets the device's port A data direction register.
.................... ////
.................... //// Parameters:
.................... ////     address - address of the device. use provided defines.
.................... ////
.................... //// Returns:
.................... ////      The device's IODIRB register value
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifndef IO_MULTIPLE_DEVICES
.................... int8 IO_GET_TRIS_A(){
.................... #else
.................... int8 IO_GET_TRIS_A(int8 address){
.................... #endif
.................... 
....................    int8 retVal;
....................    
....................    #ifndef IO_MULTIPLE_DEVICES
....................    retVal = IO_READ_REGISTER(IODIRA);
....................    #else
....................    retVal = IO_READ_REGISTER(address, IODIRA);
....................    #endif
....................    
....................    return retVal;
.................... 
.................... }
.................... 
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_SET_TRIS_A
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Sets the device's port A data direction register to the specified value.
.................... ////
.................... //// Parameters:
.................... ////      data - value to be written to the register
.................... ////     address - address of the device. use provided defines.
.................... ////
.................... //// Returns:
.................... ////      void
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifndef IO_MULTIPLE_DEVICES
.................... void IO_SET_TRIS_A(int8 data){
.................... #else
.................... void IO_SET_TRIS_A(int8 address, int8 data){
.................... #endif
....................    
....................    #ifndef IO_MULTIPLE_DEVICES
....................    IO_WRITE_REGISTER(IODIRA, data);
....................    #else
....................    IO_WRITE_REGISTER(address, IODIRA, data);
*
0075A:  MOVFF  7B0,7BA
0075E:  MOVLB  7
00760:  CLRF   xBB
00762:  MOVFF  7B1,7BC
00766:  MOVLB  0
00768:  RCALL  0692
....................    #endif
0076A:  RETURN 0
.................... 
.................... }
.................... 
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_GET_TRIS_B
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Gets the device's port B data direction register.
.................... ////
.................... //// Parameters:
.................... ////     address - address of the device. use provided defines.
.................... ////
.................... //// Returns:
.................... ////      The device's IODIRB register value
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifndef IO_MULTIPLE_DEVICES
.................... int8 IO_GET_TRIS_B(){
.................... #else
.................... int8 IO_GET_TRIS_B(int8 address){
.................... #endif
.................... 
....................    int8 retVal;
....................    
....................    #ifndef IO_MULTIPLE_DEVICES
....................    retVal = IO_READ_REGISTER(IODIRB);
....................    #else
....................    retVal = IO_READ_REGISTER(address, IODIRB);
....................    #endif
....................    
....................    return retVal;
.................... 
.................... }
.................... 
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// IO_SET_TRIS_B
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //// Sets the device's port B data direction register to the specified value.
.................... ////
.................... //// Parameters:
.................... ////      data - value to be written to the register
.................... ////     address - address of the device. use provided defines.
.................... ////
.................... //// Returns:
.................... ////      void
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #ifndef IO_MULTIPLE_DEVICES
.................... void IO_SET_TRIS_B(int8 data){
.................... #else
.................... void IO_SET_TRIS_B(int8 address, int8 data){
.................... #endif
.................... 
....................    #ifndef IO_MULTIPLE_DEVICES
....................    IO_WRITE_REGISTER(IODIRB, data);
....................    #else
....................    IO_WRITE_REGISTER(address, IODIRB, data);
0076C:  MOVFF  7B0,7BA
00770:  MOVLW  10
00772:  MOVLB  7
00774:  MOVWF  xBB
00776:  MOVFF  7B1,7BC
0077A:  MOVLB  0
0077C:  RCALL  0692
....................    #endif
0077E:  RETURN 0
.................... 
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define Pled        PIN_B5
.................... #define I2C_SDA     PIN_C4
.................... #define I2C_SCL     PIN_C3
.................... 
.................... #define Pack        PIN_C0
.................... #define Preset      PIN_C1
.................... #define Ptest       PIN_C2
.................... 
.................... #define Pbell       PIN_A3
.................... #define Pbuzzer     PIN_A4
.................... 
.................... #define P485ctrl    PIN_B3       // ---jj
.................... #define PTxD        PIN_C6
.................... #define PRxD        PIN_C7
.................... 
.................... //#define PsyncR      PIN_B3
.................... //#define PsyncS      PIN_B4
.................... /*
.................... #define EXP_OUT_ENABLE  PIN_B0
.................... #define EXP_OUT_CLOCK   PIN_B1
.................... #define EXP_OUT_DO      PIN_B2
.................... */
.................... #define Red       0
.................... #define Green     1
.................... #define Ambian    2
.................... 
.................... //#define NUMBER_OF_595 8
.................... 
.................... //#use rs232(baud=9600,parity=N,xmit=PTxD,rcv=PRxD,bits=8,restart_wdt)
.................... /* Config and Enable Hardware UART1(RC6=TX1,RC7=RX1 */
.................... #use rs232(uart1, baud=9600, stream=CH1)
*
01DD2:  BTFSS  F9E.4
01DD4:  BRA    1DD2
01DD6:  MOVWF  FAD
01DD8:  RETURN 0
.................... 
.................... /* Config and Enable Software UART2(RC0=TX2,RC1=RX2 */
.................... 
.................... #define TX2 PIN_B0                                                            // RC0 = TXD
.................... #define RX2 PIN_B1                                                            // RC1 = RXD
.................... #use rs232(baud=9600, xmit=TX2, rcv=RX2,stream=CH2)
*
01D16:  BCF    F93.0
01D18:  BCF    F8A.0
01D1A:  MOVLW  08
01D1C:  MOVWF  01
01D1E:  BRA    1D20
01D20:  NOP   
01D22:  BSF    01.7
01D24:  BRA    1D46
01D26:  BCF    01.7
01D28:  MOVLB  7
01D2A:  RRCF   xB2,F
01D2C:  MOVLB  0
01D2E:  BTFSC  FD8.0
01D30:  BSF    F8A.0
01D32:  BTFSS  FD8.0
01D34:  BCF    F8A.0
01D36:  BSF    01.6
01D38:  BRA    1D46
01D3A:  BCF    01.6
01D3C:  DECFSZ 01,F
01D3E:  BRA    1D28
01D40:  BRA    1D42
01D42:  NOP   
01D44:  BSF    F8A.0
01D46:  MOVLW  84
01D48:  MOVWF  FE9
01D4A:  DECFSZ FE9,F
01D4C:  BRA    1D4A
01D4E:  BRA    1D50
01D50:  NOP   
01D52:  BTFSC  01.7
01D54:  BRA    1D26
01D56:  BTFSC  01.6
01D58:  BRA    1D3A
01D5A:  RETURN 0
.................... 
.................... //#USE SPI (  FORCE_HW, BITS=16, ENABLE=IO_CS_PIN, SAMPLE_RISE, stream=SPI_STREAM) 
.................... //#USE SPI (  FORCE_HW, BITS=16, ENABLE=IO_CS_PIN, SAMPLE_RISE, stream=SPI_STREAM2)
.................... 
.................... //#use spi(MASTER, MODE=0, SPI1, FORCE_HW)
.................... //#use spi(MASTER, MSB_FIRST, BITS=8, MODE=0, BAUD=100000)
.................... //#use spi(DI=PIN_B1, DO=PIN_B0, CLK=PIN_B2, ENABLE=PIN_B4, BITS=8)
.................... 
.................... void check_ack(void);
.................... void check_test(void);
.................... void check_reset(void);
.................... int1 CheckAutoReset(unsigned char DatType);
.................... void Read_Config(void);
.................... void ForceAllAlarm(void);
.................... void Read_input(void);
.................... 
.................... int8 StatusTime = 0;         //Hearth beat LED Timer
.................... int1 HearthbeatInd = 0;      //Hearth beat Indicator
.................... int8 FlashingRateTime = 25;
.................... int1 FlashingFlag = 0;
.................... int8 TimeBase1s = 100;
.................... int8 AutoAckDelayTime = 0;
.................... 
.................... int8 Input1_8_Send;
.................... int8 Input9_16_Send;
.................... int8 Input17_24_Send;
.................... int8 Input25_32_Send;
.................... int8 Input33_40_Send;
.................... int8 Input41_48_Send;
.................... int8 Input49_56_Send;
.................... int8 Input57_64_Send;
.................... 
.................... int8 Ack1_8_Send;
.................... int8 Ack9_16_Send;
.................... int8 Ack17_24_Send;
.................... int8 Ack25_32_Send;
.................... int8 Ack33_40_Send;
.................... int8 Ack41_48_Send;
.................... int8 Ack49_56_Send;
.................... int8 Ack57_64_Send;
.................... 
.................... int1 AutoAckFlag = 0;
.................... int1 AutoResetFlag = 0;
.................... int1 AutoTestFlag = 0;
.................... 
.................... int8 SBUF = 0x00;
.................... 
.................... int1 Test_fault = 0;
.................... int8 T_test = 0x00;
.................... 
.................... int1 Test = 0;
.................... int1 Ack_F = 0;
.................... int1 Reset_F = 0;
.................... 
.................... volatile int1 functointest_f = 0;
.................... 
.................... int1 SyncStatus = 0;   //"0" -> No Sync signal
.................... int1 SyncFlag = 0;     //use for debounce sync signal
.................... int8 Synctimer = 0x00; //use for debounce sync signal
.................... 
.................... int8 Output1_8;
.................... int8 Output9_16;
.................... 
.................... int8 Output595[4];
.................... 
.................... int8 tempdata;
.................... 
.................... int8 EEpDat;
.................... 
.................... ///////// Data from EEProm ///////
.................... //int Device_Addr;
.................... 
.................... int8 InputType1_8;
.................... int8 InputType9_16;
.................... int8 InputType17_24;
.................... 
.................... int8 FaultType1_8;
.................... int8 FaultType9_16;
.................... int8 FaultType17_24;
.................... 
.................... int8 OutputType1_8;
.................... int8 OutputType9_16;
.................... int8 OutputType17_24;
.................... 
.................... int8 OutputBoth1_8;
.................... int8 OutputBoth9_16;
.................... int8 OutputBoth17_24;
.................... 
.................... int8 Alarm_Indicator1_8;
.................... int8 Alarm_Indicator9_16;
.................... int8 Alarm_Indicator17_24;
.................... 
.................... int8 Input1_8;
.................... int8 Input9_16;
.................... 
.................... int8 Input9_10;
.................... int8 Input11_18;
.................... int8 Input19_20;
.................... 
.................... int8 Red1_7;
.................... int8 Red8_8;
.................... int8 Red9_15;
.................... int8 Red16_16;
.................... 
.................... int8 Green1_7;
.................... int8 Green8_8;
.................... int8 Green9_15;
.................... int8 Green16_16;
.................... 
.................... int8 Red1_8;
.................... int8 Red9_16;
.................... 
.................... int8 Red9_10 ;
.................... int8 Red11_18 ;
.................... int8 Red19_20 ;
.................... 
.................... int8 Green1_8 ;
.................... int8 Green9_16 ;
.................... 
.................... int8 Green9_10 ;
.................... int8 Green11_18 ;
.................... int8 Green19_20 ;
.................... 
.................... int8 OUTRed1_8;
.................... int8 OUTRed9_16 ;
.................... 
.................... int8 OUTRed9_10 ;
.................... int8 OUTRed11_18 ;
.................... int8 OUTRed19_20 ;
.................... 
.................... int8 OUTGreen1_8 ;
.................... int8 OUTGreen9_16 ;
.................... 
.................... int8 OUTGreen9_10 ;
.................... int8 OUTGreen11_18 ;
.................... int8 OUTGreen19_20 ;
.................... 
.................... int8 AutoAck;
.................... int8 AutoAckTime;
.................... int8 FlashingRate;
.................... int8 NoOfPoint;
.................... int8 MasterSlaveSync;
.................... 
.................... volatile int1 RefreshConfigData =0;
.................... 
.................... ////////////////////////////////
.................... ///////// tempolary register //////////
.................... //int8 temp;
.................... //int1 RxDreceive = 0;
.................... 
.................... //////////////////////////////////////second_numofdata = 0x18,
.................... unsigned char const addr_sq = 0x10, end_sq = 0x11, code_sq = 0x12, start_addr_hi_sq = 0x13, start_addr_lo_sq = 0x14;         //serial sequnce
.................... unsigned char const ubyte_hi_sq = 0x15, ubyte_lo_sq = 0x16, crc_hi_sq = 0x17,second_numofdata = 0x18, byte_count_sq = 0x19, data_sq = 0x20;      //serial sequnce
.................... 
.................... int1 recieve_completed = 0;
.................... unsigned char sequence;         //keep sequence use for RxD
.................... unsigned char Address;
.................... unsigned char RxD_DataLen = 0x00;
.................... unsigned char TxD_Buff[255];
.................... unsigned char RxD_Buff[512];
.................... unsigned char CRC_Lo;
.................... unsigned char CRC_Hi;
.................... int16 Send_check_Time = 500; //if no send reset buffer every 5 second
.................... 
.................... int16 Start_Address = 0x0000;
.................... int16 No_PointCount = 0x0000;
.................... unsigned char Data_ByteCount = 0x00;
.................... unsigned char Data_Buff[512];
.................... //unsigned char DataTemp;
.................... //unsigned char TxD_DataLen;
.................... 
.................... int8 MCP23s17_Ip_dat;
.................... 
.................... int8 MCP23s17_Op_dat;
.................... 
.................... unsigned char T_timeout;   //use for calculate RxD timeout
.................... int16 index = 0x00;         //use for Loop
.................... 
.................... int8 outmcp23 = 0;
.................... 
.................... unsigned char sms_phonenumber[15];
.................... 
.................... //unsigned char SMS_Massage[20][20];
.................... 
.................... unsigned char SMS_Massage1[32];
.................... unsigned char SMS_Massage2[32];
.................... unsigned char SMS_Massage3[32];
.................... unsigned char SMS_Massage4[32];
.................... unsigned char SMS_Massage5[32];
.................... unsigned char SMS_Massage6[32];
.................... unsigned char SMS_Massage7[32];
.................... unsigned char SMS_Massage8[32];
.................... 
.................... unsigned char SMS_MassageSUM[160] = ">>";
.................... 
.................... unsigned char spacestring[] = " ";
.................... 
.................... volatile int8 send_SMS_period ,send_SMS_count ;
.................... 
.................... unsigned char const CRC_Table_Hi[] = {
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
.................... 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01,
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81,
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
.................... 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01,
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
.................... 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
.................... 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01,
.................... 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
.................... 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
.................... 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
.................... 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 
.................... 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
.................... 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
.................... 0x40
.................... } ; 
.................... 
.................... unsigned  char const CRC_Table_Lo[] = {
.................... 0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4,
.................... 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09,
.................... 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD,
.................... 0x1D, 0x1C, 0xDC, 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
.................... 0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7,
.................... 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A,
.................... 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE,
.................... 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26, 
.................... 0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2,
.................... 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 
.................... 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB,
.................... 0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5, 
.................... 0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0, 0x50, 0x90, 0x91,
.................... 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C,
.................... 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88,
.................... 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
.................... 0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80,
.................... 0x40
.................... } ;
.................... 
.................... ///////////// Define Bit register ////////////////////////////
.................... 
.................... struct Bit64    // Inputt
.................... {
....................    int1 B1,B2,B3,B4,B5,B6,B7,B8;
.................... 
.................... };
.................... 
.................... 
.................... struct Bit64 Inputt,Output,InputType,FaultType,OutputType,OutputBoth;
.................... struct Bit64 AlarmIndicator,Ack,In,In2;
.................... struct Bit64 LED_Colour,AckSend,RED_Colour,GREEN_Colour;
.................... struct Bit64 SendSMS;
.................... 
.................... int1 FaultAgo[20];
.................... int1 FaultNow[20];
.................... int16 ReleaseTime[20];
.................... int16 FaultDelayTime[20];
.................... int8  AllFaultDelayTime;
.................... int1 FaultNCNO[20];
.................... #define NO 1
.................... #define NC 0
.................... 
.................... //////////////////////////////--Function--/////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////MODBUS Routine//////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////////////////////////////////////////////////////////////////////////////////
.................... void StoreReleaseFault()
*
01410:  MOVLB  7
01412:  CLRF   xBA
.................... {
....................    Signed int8 i=0;
....................    for(i=1;i<=16;i++)
01414:  MOVLW  01
01416:  MOVWF  xBA
01418:  BTFSC  xBA.7
0141A:  BRA    1422
0141C:  MOVF   xBA,W
0141E:  SUBLW  10
01420:  BNC   1468
....................    {
....................       FaultAgo[i] = FaultNow[i];
01422:  CLRF   03
01424:  MOVF   xBA,W
01426:  MOVWF  00
01428:  BTFSC  FE8.7
0142A:  DECF   03,F
0142C:  MOVWF  xBB
0142E:  MOVFF  03,7BC
01432:  CLRF   03
01434:  MOVF   xBA,W
01436:  MOVWF  00
01438:  BTFSC  FE8.7
0143A:  DECF   03,F
0143C:  MOVWF  xBD
0143E:  MOVLW  07
01440:  MOVWF  xBF
01442:  MOVLW  50
01444:  MOVWF  xBE
01446:  MOVLB  0
01448:  RCALL  1374
0144A:  MOVFF  7BB,7BD
0144E:  MOVLB  7
01450:  CLRF   xBE
01452:  BTFSC  01.0
01454:  INCF   xBE,F
01456:  MOVLW  07
01458:  MOVWF  xC0
0145A:  MOVLW  4D
0145C:  MOVWF  xBF
0145E:  MOVLB  0
01460:  BRA    13CC
01462:  MOVLB  7
01464:  INCF   xBA,F
01466:  BRA    1418
....................    }
01468:  MOVLB  0
0146A:  GOTO   19EA (RETURN)
.................... }
.................... 
.................... void CRC(unsigned char *puchMsg , unsigned char usDataLen)
.................... { 
....................    unsigned char uIndex ;                   /* fill index into CRC lookup table */
....................    unsigned char i ;
.................... 
....................    CRC_Hi = 0xFF ;                      /* high byte of CRC initialized */
*
01D7C:  MOVLB  3
01D7E:  SETF   x7D
....................    CRC_Lo = 0xFF ;                      /* low byte of CRC initialized */
01D80:  SETF   x7C
.................... 
....................    for(i = 0;i < usDataLen;i++)
01D82:  MOVLB  7
01D84:  CLRF   xBE
01D86:  MOVF   xBC,W
01D88:  SUBWF  xBE,W
01D8A:  BC    1DCE
....................    {
....................       restart_wdt();
01D8C:  CLRWDT
....................       uIndex = CRC_Hi ^ (unsigned char) puchMsg[i] ;
01D8E:  MOVF   xBE,W
01D90:  ADDWF  xBA,W
01D92:  MOVWF  FE9
01D94:  MOVLW  00
01D96:  ADDWFC xBB,W
01D98:  MOVWF  FEA
01D9A:  MOVF   FEF,W
01D9C:  MOVLB  3
01D9E:  XORWF  x7D,W
01DA0:  MOVLB  7
01DA2:  MOVWF  xBD
....................       CRC_Hi = CRC_Lo ^ CRC_Table_Hi[uIndex] ;
01DA4:  CLRF   03
01DA6:  MOVF   xBD,W
01DA8:  MOVLB  0
01DAA:  CALL   00BA
01DAE:  MOVWF  01
01DB0:  MOVLB  3
01DB2:  MOVF   x7C,W
01DB4:  XORWF  01,W
01DB6:  MOVWF  x7D
....................       CRC_Lo = CRC_Table_Lo[uIndex] ;
01DB8:  CLRF   03
01DBA:  MOVLB  7
01DBC:  MOVF   xBD,W
01DBE:  MOVLB  0
01DC0:  CALL   01CA
01DC4:  MOVFF  FE8,37C
01DC8:  MOVLB  7
01DCA:  INCF   xBE,F
01DCC:  BRA    1D86
....................    }
01DCE:  MOVLB  0
01DD0:  RETURN 0
.................... }
.................... 
.................... /********************************6B595 Driver*********************************/
.................... /*
.................... void Driver595()
.................... {
....................    Signed int8 j=0;
....................    int8 data_out ;
.................... 
....................    restart_wdt();
....................     
....................     data_out = (~Input19_20);
....................     for(j=7;j>=0;j--)
....................     {
....................      output_bit(EXP_OUT_DO,bit_test(data_out,j));
....................      output_high(EXP_OUT_CLOCK);
....................      delay_us(1);
....................      output_low(EXP_OUT_CLOCK);
....................     }    
....................     data_out = (~Input11_18);
....................     for(j=7;j>=0;j--)
....................     {
....................      output_bit(EXP_OUT_DO,bit_test(data_out,j));
....................      output_high(EXP_OUT_CLOCK);
....................      delay_us(1);
....................      output_low(EXP_OUT_CLOCK);
....................     }
....................     
....................     data_out = (~Input9_10);
....................     for(j=7;j>=0;j--)
....................     {
....................      output_bit(EXP_OUT_DO,bit_test(data_out,j));
....................      output_high(EXP_OUT_CLOCK);
....................      delay_us(1);
....................      output_low(EXP_OUT_CLOCK);
....................     }    
....................     data_out = (~Input1_8);
....................     for(j=7;j>=0;j--)
....................     {
....................      output_bit(EXP_OUT_DO,bit_test(data_out,j));
....................      output_high(EXP_OUT_CLOCK);
....................      delay_us(1);
....................      output_low(EXP_OUT_CLOCK);
....................     }
....................  
....................    output_high(EXP_OUT_ENABLE);
....................    delay_us(1);
....................    output_low(EXP_OUT_ENABLE);
.................... }
.................... */
.................... ////////////////////////////////////////////////////////////////////////////////
.................... char blankSigned[] = ">>";
.................... void sendsum_sms(void)
.................... {
....................    if(strcmp(SMS_MassageSUM, blankSigned) != 0){
*
058F4:  MOVLW  06
058F6:  MOVLB  7
058F8:  MOVWF  xB1
058FA:  MOVLW  9A
058FC:  MOVWF  xB0
058FE:  MOVLW  07
05900:  MOVWF  xB3
05902:  MOVLW  A7
05904:  MOVWF  xB2
05906:  MOVLB  0
05908:  BRA    5854
0590A:  MOVF   01,F
0590C:  BZ    59A6
....................    
....................       fprintf(CH2,"AT+CMGF=1"); 
0590E:  MOVLW  DA
05910:  MOVWF  FF6
05912:  MOVLW  02
05914:  MOVWF  FF7
05916:  CALL   1D5C
....................       putc('\n',CH2);
0591A:  MOVLW  0A
0591C:  MOVLB  7
0591E:  MOVWF  xB2
05920:  MOVLB  0
05922:  CALL   1D16
....................       delay_ms(10);
05926:  MOVLW  0A
05928:  MOVLB  7
0592A:  MOVWF  xB9
0592C:  MOVLB  0
0592E:  CALL   0662
....................    
....................       fprintf(CH2,"AT+CMGS=\"");
05932:  MOVLW  E4
05934:  MOVWF  FF6
05936:  MOVLW  02
05938:  MOVWF  FF7
0593A:  CALL   1D5C
....................       fprintf(CH2,sms_phonenumber);
0593E:  MOVLW  05
05940:  MOVWF  FEA
05942:  MOVLW  8B
05944:  MOVWF  FE9
05946:  RCALL  58CE
....................       
....................       fprintf(CH2,"\"");
05948:  MOVLW  22
0594A:  MOVLB  7
0594C:  MOVWF  xB2
0594E:  MOVLB  0
05950:  CALL   1D16
....................       putc('\n',CH2);
05954:  MOVLW  0A
05956:  MOVLB  7
05958:  MOVWF  xB2
0595A:  MOVLB  0
0595C:  CALL   1D16
....................       delay_ms(50);
05960:  MOVLW  32
05962:  MOVLB  7
05964:  MOVWF  xB9
05966:  MOVLB  0
05968:  CALL   0662
....................      
....................      fprintf(CH2,SMS_MassageSUM);
0596C:  MOVLW  06
0596E:  MOVWF  FEA
05970:  MOVLW  9A
05972:  MOVWF  FE9
05974:  RCALL  58CE
....................      putc('\n',CH2);
05976:  MOVLW  0A
05978:  MOVLB  7
0597A:  MOVWF  xB2
0597C:  MOVLB  0
0597E:  CALL   1D16
....................      putc(26,CH2);
05982:  MOVLW  1A
05984:  MOVLB  7
05986:  MOVWF  xB2
05988:  MOVLB  0
0598A:  CALL   1D16
....................      
....................      strcpy(SMS_MassageSUM, blankSigned);
0598E:  MOVLW  06
05990:  MOVWF  FEA
05992:  MOVLW  9A
05994:  MOVWF  FE9
05996:  MOVLW  07
05998:  MOVWF  FE2
0599A:  MOVLW  A7
0599C:  MOVWF  FE1
0599E:  MOVF   FE7,F
059A0:  MOVFF  FE6,FEE
059A4:  BNZ   599E
.................... 
....................    }
059A6:  GOTO   5F0A (RETURN)
.................... }
.................... ///////////////////////////////////////////////////////////////////////////////
.................... 
.................... void Alarmtosend(void)
.................... {
....................    Input1_8_Send = 0x00;
*
01DDA:  CLRF   20
....................    
....................    Ack1_8_Send = 0x00;
01DDC:  CLRF   28
....................   
....................    /////////////////////////////////////////////////////
....................   
....................    if((In.B1 == 0) && (Output.B1 ==0))
01DDE:  MOVLB  7
01DE0:  BTFSC  x46.0
01DE2:  BRA    1DEC
01DE4:  BTFSC  x3F.0
01DE6:  BRA    1DEC
....................       AckSend.B1 = 1;
01DE8:  BSF    x49.0
01DEA:  BRA    1DEE
....................    else
....................       AckSend.B1 = 0;
01DEC:  BCF    x49.0
....................    if((In.B2 == 0) && (Output.B2 ==0))
01DEE:  BTFSC  x46.1
01DF0:  BRA    1DFA
01DF2:  BTFSC  x3F.1
01DF4:  BRA    1DFA
....................       AckSend.B2 = 1;
01DF6:  BSF    x49.1
01DF8:  BRA    1DFC
....................    else
....................       AckSend.B2 = 0;
01DFA:  BCF    x49.1
....................    if((In.B3 == 0) && (Output.B3 ==0))
01DFC:  BTFSC  x46.2
01DFE:  BRA    1E08
01E00:  BTFSC  x3F.2
01E02:  BRA    1E08
....................       AckSend.B3 = 1;
01E04:  BSF    x49.2
01E06:  BRA    1E0A
....................    else
....................       AckSend.B3 = 0;
01E08:  BCF    x49.2
....................    if((In.B4 == 0) && (Output.B4 ==0))
01E0A:  BTFSC  x46.3
01E0C:  BRA    1E16
01E0E:  BTFSC  x3F.3
01E10:  BRA    1E16
....................       AckSend.B4 = 1;
01E12:  BSF    x49.3
01E14:  BRA    1E18
....................    else
....................       AckSend.B4 = 0;
01E16:  BCF    x49.3
....................    if((In.B5 == 0) && (Output.B5 ==0))
01E18:  BTFSC  x46.4
01E1A:  BRA    1E24
01E1C:  BTFSC  x3F.4
01E1E:  BRA    1E24
....................       AckSend.B5 = 1;
01E20:  BSF    x49.4
01E22:  BRA    1E26
....................    else
....................       AckSend.B5 = 0;
01E24:  BCF    x49.4
....................    if((In.B6 == 0) && (Output.B6 ==0))
01E26:  BTFSC  x46.5
01E28:  BRA    1E32
01E2A:  BTFSC  x3F.5
01E2C:  BRA    1E32
....................       AckSend.B6 = 1;
01E2E:  BSF    x49.5
01E30:  BRA    1E34
....................    else
....................       AckSend.B6 = 0;
01E32:  BCF    x49.5
....................    if((In.B7 == 0) && (Output.B7 ==0))
01E34:  BTFSC  x46.6
01E36:  BRA    1E40
01E38:  BTFSC  x3F.6
01E3A:  BRA    1E40
....................       AckSend.B7 = 1;
01E3C:  BSF    x49.6
01E3E:  BRA    1E42
....................    else
....................       AckSend.B7 = 0;
01E40:  BCF    x49.6
....................    if((In.B8 == 0) && (Output.B8 ==0))
01E42:  BTFSC  x46.7
01E44:  BRA    1E4E
01E46:  BTFSC  x3F.7
01E48:  BRA    1E4E
....................       AckSend.B8 = 1;
01E4A:  BSF    x49.7
01E4C:  BRA    1E50
....................    else
....................       AckSend.B8 = 0;
01E4E:  BCF    x49.7
.................... 
....................    
....................    ///////////////////Ack/////////////////////////////////
....................    Ack1_8_Send = Ack1_8_Send | AckSend.B8;
01E50:  MOVLW  00
01E52:  BTFSC  x49.7
01E54:  MOVLW  01
01E56:  IORWF  28,F
....................    Ack1_8_Send = (Ack1_8_Send << 1) | AckSend.B7;
01E58:  BCF    FD8.0
01E5A:  RLCF   28,W
01E5C:  MOVWF  xBA
01E5E:  MOVLW  00
01E60:  BTFSC  x49.6
01E62:  MOVLW  01
01E64:  IORWF  xBA,W
01E66:  MOVWF  28
....................    Ack1_8_Send = (Ack1_8_Send << 1) | AckSend.B6;
01E68:  BCF    FD8.0
01E6A:  RLCF   28,W
01E6C:  MOVWF  xBA
01E6E:  MOVLW  00
01E70:  BTFSC  x49.5
01E72:  MOVLW  01
01E74:  IORWF  xBA,W
01E76:  MOVWF  28
....................    Ack1_8_Send = (Ack1_8_Send << 1) | AckSend.B5;
01E78:  BCF    FD8.0
01E7A:  RLCF   28,W
01E7C:  MOVWF  xBA
01E7E:  MOVLW  00
01E80:  BTFSC  x49.4
01E82:  MOVLW  01
01E84:  IORWF  xBA,W
01E86:  MOVWF  28
....................    Ack1_8_Send = (Ack1_8_Send << 1) | AckSend.B4;
01E88:  BCF    FD8.0
01E8A:  RLCF   28,W
01E8C:  MOVWF  xBA
01E8E:  MOVLW  00
01E90:  BTFSC  x49.3
01E92:  MOVLW  01
01E94:  IORWF  xBA,W
01E96:  MOVWF  28
....................    Ack1_8_Send = (Ack1_8_Send << 1) | AckSend.B3;
01E98:  BCF    FD8.0
01E9A:  RLCF   28,W
01E9C:  MOVWF  xBA
01E9E:  MOVLW  00
01EA0:  BTFSC  x49.2
01EA2:  MOVLW  01
01EA4:  IORWF  xBA,W
01EA6:  MOVWF  28
....................    Ack1_8_Send = (Ack1_8_Send << 1) | AckSend.B2;
01EA8:  BCF    FD8.0
01EAA:  RLCF   28,W
01EAC:  MOVWF  xBA
01EAE:  MOVLW  00
01EB0:  BTFSC  x49.1
01EB2:  MOVLW  01
01EB4:  IORWF  xBA,W
01EB6:  MOVWF  28
....................    Ack1_8_Send = (Ack1_8_Send << 1) | AckSend.B1;
01EB8:  BCF    FD8.0
01EBA:  RLCF   28,W
01EBC:  MOVWF  xBA
01EBE:  MOVLW  00
01EC0:  BTFSC  x49.0
01EC2:  MOVLW  01
01EC4:  IORWF  xBA,W
01EC6:  MOVWF  28
....................    
....................    ///////////////////Fault/////////////////////////////////
....................    Input1_8_Send = Input1_8_Send | In.B8;
01EC8:  MOVLW  00
01ECA:  BTFSC  x46.7
01ECC:  MOVLW  01
01ECE:  IORWF  20,F
....................    Input1_8_Send = (Input1_8_Send << 1) | In.B7;
01ED0:  BCF    FD8.0
01ED2:  RLCF   20,W
01ED4:  MOVWF  xBA
01ED6:  MOVLW  00
01ED8:  BTFSC  x46.6
01EDA:  MOVLW  01
01EDC:  IORWF  xBA,W
01EDE:  MOVWF  20
....................    Input1_8_Send = (Input1_8_Send << 1) | In.B6;
01EE0:  BCF    FD8.0
01EE2:  RLCF   20,W
01EE4:  MOVWF  xBA
01EE6:  MOVLW  00
01EE8:  BTFSC  x46.5
01EEA:  MOVLW  01
01EEC:  IORWF  xBA,W
01EEE:  MOVWF  20
....................    Input1_8_Send = (Input1_8_Send << 1) | In.B5;
01EF0:  BCF    FD8.0
01EF2:  RLCF   20,W
01EF4:  MOVWF  xBA
01EF6:  MOVLW  00
01EF8:  BTFSC  x46.4
01EFA:  MOVLW  01
01EFC:  IORWF  xBA,W
01EFE:  MOVWF  20
....................    Input1_8_Send = (Input1_8_Send << 1) | In.B4;
01F00:  BCF    FD8.0
01F02:  RLCF   20,W
01F04:  MOVWF  xBA
01F06:  MOVLW  00
01F08:  BTFSC  x46.3
01F0A:  MOVLW  01
01F0C:  IORWF  xBA,W
01F0E:  MOVWF  20
....................    Input1_8_Send = (Input1_8_Send << 1) | In.B3;
01F10:  BCF    FD8.0
01F12:  RLCF   20,W
01F14:  MOVWF  xBA
01F16:  MOVLW  00
01F18:  BTFSC  x46.2
01F1A:  MOVLW  01
01F1C:  IORWF  xBA,W
01F1E:  MOVWF  20
....................    Input1_8_Send = (Input1_8_Send << 1) | In.B2;
01F20:  BCF    FD8.0
01F22:  RLCF   20,W
01F24:  MOVWF  xBA
01F26:  MOVLW  00
01F28:  BTFSC  x46.1
01F2A:  MOVLW  01
01F2C:  IORWF  xBA,W
01F2E:  MOVWF  20
....................    Input1_8_Send = (Input1_8_Send << 1) | In.B1;
01F30:  BCF    FD8.0
01F32:  RLCF   20,W
01F34:  MOVWF  xBA
01F36:  MOVLW  00
01F38:  BTFSC  x46.0
01F3A:  MOVLW  01
01F3C:  IORWF  xBA,W
01F3E:  MOVWF  20
01F40:  MOVLB  0
01F42:  GOTO   288A (RETURN)
....................      
.................... }
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... int8 count_bytecount =0;
.................... void checkCommand(void)
.................... {
....................    
....................    restart_wdt();
*
002EE:  CLRWDT
.................... 
....................    if(sequence == end_sq )     //check Address
002F0:  MOVF   x71,W
002F2:  SUBWF  x7A,W
002F4:  BNZ   0320
....................    {
....................      RxD_DataLen = 0x00 ;
002F6:  CLRF   x7C
....................      RxD_Buff[RxD_DataLen] = SBUF ;      //Byte 1   Address
002F8:  MOVLW  7C
002FA:  ADDWF  x7C,W
002FC:  MOVWF  FE9
002FE:  MOVLW  01
00300:  MOVWF  FEA
00302:  BTFSC  FD8.0
00304:  INCF   FEA,F
00306:  MOVFF  30,FEF
....................      restart_wdt();
0030A:  CLRWDT
....................      RxD_DataLen ++ ;
0030C:  INCF   x7C,F
....................      sequence = addr_sq;
0030E:  MOVLW  10
00310:  MOVWF  x7A
....................      count_bytecount =0; // bytecount = 2 Byte //jj10092564
00312:  MOVLB  7
00314:  CLRF   xAC
....................      T_timeout = 0x14; //200ms
00316:  MOVLW  14
00318:  MOVLB  5
0031A:  MOVWF  x87
....................    }
0031C:  BRA    0598
0031E:  MOVLB  0
....................    else if(sequence == addr_sq)
00320:  MOVF   x7A,W
00322:  SUBLW  10
00324:  BNZ   03DE
....................    {
....................       RxD_Buff[RxD_DataLen] = SBUF ;      //Byte 2   Function Code
00326:  MOVLW  7C
00328:  ADDWF  x7C,W
0032A:  MOVWF  FE9
0032C:  MOVLW  01
0032E:  MOVWF  FEA
00330:  BTFSC  FD8.0
00332:  INCF   FEA,F
00334:  MOVFF  30,FEF
....................       restart_wdt();
00338:  CLRWDT
....................       RxD_DataLen ++ ;
0033A:  INCF   x7C,F
.................... 
....................        if(RxD_Buff[RxD_DataLen - 1] < 0x17)   //Function Code Must be less than 0x20
0033C:  MOVLW  01
0033E:  SUBWF  x7C,W
00340:  ADDLW  7C
00342:  MOVWF  FE9
00344:  MOVLW  01
00346:  MOVWF  FEA
00348:  BTFSC  FD8.0
0034A:  INCF   FEA,F
0034C:  MOVF   FEF,W
0034E:  SUBLW  16
00350:  BNC   0360
....................        {
....................            sequence = code_sq;
00352:  MOVFF  72,7A
....................            T_timeout = 0x14; //200ms
00356:  MOVLW  14
00358:  MOVLB  5
0035A:  MOVWF  x87
....................        }
0035C:  BRA    03DA
0035E:  MOVLB  0
....................        else if(RxD_Buff[RxD_DataLen - 1] == 0x20)   /////Read Setting//////
00360:  MOVLW  01
00362:  SUBWF  x7C,W
00364:  ADDLW  7C
00366:  MOVWF  FE9
00368:  MOVLW  01
0036A:  MOVWF  FEA
0036C:  BTFSC  FD8.0
0036E:  INCF   FEA,F
00370:  MOVF   FEF,W
00372:  SUBLW  20
00374:  BNZ   0384
....................        {
....................           sequence = ubyte_lo_sq;
00376:  MOVFF  75,7A
....................           T_timeout = 0x14; //200ms
0037A:  MOVLW  14
0037C:  MOVLB  5
0037E:  MOVWF  x87
....................        }
00380:  BRA    03DA
00382:  MOVLB  0
....................        else if(RxD_Buff[RxD_DataLen - 1] == 0x21)   /////Write setting/////
00384:  MOVLW  01
00386:  SUBWF  x7C,W
00388:  ADDLW  7C
0038A:  MOVWF  FE9
0038C:  MOVLW  01
0038E:  MOVWF  FEA
00390:  BTFSC  FD8.0
00392:  INCF   FEA,F
00394:  MOVF   FEF,W
00396:  SUBLW  21
00398:  BNZ   03A8
....................        {
....................           sequence = byte_count_sq ;
0039A:  MOVFF  78,7A
....................           T_timeout = 0x14; //200ms
0039E:  MOVLW  14
003A0:  MOVLB  5
003A2:  MOVWF  x87
....................        }
003A4:  BRA    03DA
003A6:  MOVLB  0
....................        else if(RxD_Buff[RxD_DataLen - 1] == 0x22)   /////SMS setting/////
003A8:  MOVLW  01
003AA:  SUBWF  x7C,W
003AC:  ADDLW  7C
003AE:  MOVWF  FE9
003B0:  MOVLW  01
003B2:  MOVWF  FEA
003B4:  BTFSC  FD8.0
003B6:  INCF   FEA,F
003B8:  MOVF   FEF,W
003BA:  SUBLW  22
003BC:  BNZ   03CC
....................        {
....................           sequence = second_numofdata ;
003BE:  MOVFF  77,7A
....................           T_timeout = 0x14; //200ms
003C2:  MOVLW  14
003C4:  MOVLB  5
003C6:  MOVWF  x87
....................        }
003C8:  BRA    03DA
003CA:  MOVLB  0
....................        else                           // Invalid Code
....................        {
....................           RxD_DataLen = 0x00;
003CC:  CLRF   x7C
....................           sequence = end_sq;
003CE:  MOVFF  71,7A
....................           T_timeout = 0x00; 
003D2:  MOVLB  5
003D4:  CLRF   x87
....................           output_bit(P485ctrl,0);
003D6:  BCF    F8A.3
003D8:  BCF    F93.3
....................        }
....................        
....................    }
003DA:  BRA    0598
003DC:  MOVLB  0
....................    ////////////////////////////////
....................    else if(sequence == second_numofdata)
003DE:  MOVF   x77,W
003E0:  SUBWF  x7A,W
003E2:  BNZ   0408
....................    {
....................       RxD_Buff[RxD_DataLen] = SBUF ;      //Byte 3   Start address High Byte
003E4:  MOVLW  7C
003E6:  ADDWF  x7C,W
003E8:  MOVWF  FE9
003EA:  MOVLW  01
003EC:  MOVWF  FEA
003EE:  BTFSC  FD8.0
003F0:  INCF   FEA,F
003F2:  MOVFF  30,FEF
....................       restart_wdt();
003F6:  CLRWDT
....................       RxD_DataLen ++ ;
003F8:  INCF   x7C,F
....................       sequence = byte_count_sq;
003FA:  MOVFF  78,7A
....................       T_timeout = 0x14; //200ms
003FE:  MOVLW  14
00400:  MOVLB  5
00402:  MOVWF  x87
.................... 
....................    }
00404:  BRA    0598
00406:  MOVLB  0
....................    ////////////////////////////////
....................    else if(sequence == byte_count_sq)
00408:  MOVF   x78,W
0040A:  SUBWF  x7A,W
0040C:  BNZ   0464
....................    {
....................       RxD_Buff[RxD_DataLen] = SBUF ;      //Byte 3   Data Byte Count
0040E:  MOVLW  7C
00410:  ADDWF  x7C,W
00412:  MOVWF  FE9
00414:  MOVLW  01
00416:  MOVWF  FEA
00418:  BTFSC  FD8.0
0041A:  INCF   FEA,F
0041C:  MOVFF  30,FEF
....................       restart_wdt();
00420:  CLRWDT
....................       RxD_DataLen ++ ;
00422:  INCF   x7C,F
....................       if(RxD_Buff[1] == 0x22)   /////SMS setting/////
00424:  MOVLB  1
00426:  MOVF   x7D,W
00428:  SUBLW  22
0042A:  BNZ   043E
....................       {
....................          index = (RxD_Buff[2] * 0x64) + RxD_Buff[3];
0042C:  MOVF   x7E,W
0042E:  MULLW  64
00430:  MOVF   FF3,W
00432:  ADDWF  x7F,W
00434:  MOVLB  5
00436:  MOVWF  x88
00438:  CLRF   x89
....................       }
0043A:  BRA    0458
0043C:  MOVLB  1
....................       else{
....................          index = RxD_Buff[RxD_DataLen - 1] ;    //Data Byte Count
0043E:  MOVLW  01
00440:  MOVLB  0
00442:  SUBWF  x7C,W
00444:  ADDLW  7C
00446:  MOVWF  FE9
00448:  MOVLW  01
0044A:  MOVWF  FEA
0044C:  BTFSC  FD8.0
0044E:  INCF   FEA,F
00450:  MOVLB  5
00452:  CLRF   x89
00454:  MOVFF  FEF,588
....................       }
....................       
....................       T_timeout = 0x14; //200ms
00458:  MOVLW  14
0045A:  MOVWF  x87
....................       sequence = data_sq ;
0045C:  MOVFF  79,7A
....................    }
00460:  BRA    0598
00462:  MOVLB  0
....................    else if(sequence == data_sq)
00464:  MOVF   x79,W
00466:  SUBWF  x7A,W
00468:  BNZ   049E
....................    {
....................       RxD_Buff[RxD_DataLen] = SBUF ;      //
0046A:  MOVLW  7C
0046C:  ADDWF  x7C,W
0046E:  MOVWF  FE9
00470:  MOVLW  01
00472:  MOVWF  FEA
00474:  BTFSC  FD8.0
00476:  INCF   FEA,F
00478:  MOVFF  30,FEF
....................       restart_wdt();
0047C:  CLRWDT
....................       RxD_DataLen ++ ;
0047E:  INCF   x7C,F
....................       index -- ;                     //Data Byte Count
00480:  MOVLB  5
00482:  MOVF   x88,W
00484:  BTFSC  FD8.2
00486:  DECF   x89,F
00488:  DECF   x88,F
....................       if(index == 0x00)
0048A:  MOVF   x88,F
0048C:  BNZ   0496
0048E:  MOVF   x89,F
00490:  BNZ   0496
....................       {
....................          sequence = ubyte_lo_sq ;      //next CRC
00492:  MOVFF  75,7A
....................       }
....................       T_timeout = 0x14; //200ms
00496:  MOVLW  14
00498:  MOVWF  x87
....................    }
0049A:  BRA    0598
0049C:  MOVLB  0
....................    else if(sequence == code_sq)
0049E:  MOVF   x72,W
004A0:  SUBWF  x7A,W
004A2:  BNZ   04C8
....................    {
....................       RxD_Buff[RxD_DataLen] = SBUF ;      //Byte 3   Start address High Byte
004A4:  MOVLW  7C
004A6:  ADDWF  x7C,W
004A8:  MOVWF  FE9
004AA:  MOVLW  01
004AC:  MOVWF  FEA
004AE:  BTFSC  FD8.0
004B0:  INCF   FEA,F
004B2:  MOVFF  30,FEF
....................       restart_wdt();
004B6:  CLRWDT
....................       RxD_DataLen ++ ;
004B8:  INCF   x7C,F
....................       sequence = start_addr_hi_sq;
004BA:  MOVFF  73,7A
....................       T_timeout = 0x14; //200ms
004BE:  MOVLW  14
004C0:  MOVLB  5
004C2:  MOVWF  x87
.................... 
....................    }
004C4:  BRA    0598
004C6:  MOVLB  0
....................    else if(sequence == start_addr_hi_sq)
004C8:  MOVF   x73,W
004CA:  SUBWF  x7A,W
004CC:  BNZ   04F2
....................    {
....................       RxD_Buff[RxD_DataLen] = SBUF ;         //Byte 4   Start address Low Byte
004CE:  MOVLW  7C
004D0:  ADDWF  x7C,W
004D2:  MOVWF  FE9
004D4:  MOVLW  01
004D6:  MOVWF  FEA
004D8:  BTFSC  FD8.0
004DA:  INCF   FEA,F
004DC:  MOVFF  30,FEF
....................       restart_wdt();
004E0:  CLRWDT
....................       RxD_DataLen ++ ;
004E2:  INCF   x7C,F
....................       sequence = start_addr_lo_sq;
004E4:  MOVFF  74,7A
....................       T_timeout = 0x14; //200ms
004E8:  MOVLW  14
004EA:  MOVLB  5
004EC:  MOVWF  x87
....................    }
004EE:  BRA    0598
004F0:  MOVLB  0
....................    else if(sequence == start_addr_lo_sq)
004F2:  MOVF   x74,W
004F4:  SUBWF  x7A,W
004F6:  BNZ   051C
....................    {
....................       RxD_Buff[RxD_DataLen] = SBUF ;         //Byte 5   No. of point/force data High Byte
004F8:  MOVLW  7C
004FA:  ADDWF  x7C,W
004FC:  MOVWF  FE9
004FE:  MOVLW  01
00500:  MOVWF  FEA
00502:  BTFSC  FD8.0
00504:  INCF   FEA,F
00506:  MOVFF  30,FEF
....................       restart_wdt();
0050A:  CLRWDT
....................       RxD_DataLen ++ ;
0050C:  INCF   x7C,F
....................       sequence = ubyte_hi_sq;
0050E:  MOVLW  15
00510:  MOVWF  x7A
....................       T_timeout = 0x14; //200ms
00512:  MOVLW  14
00514:  MOVLB  5
00516:  MOVWF  x87
....................    }
00518:  BRA    0598
0051A:  MOVLB  0
....................    else if(sequence == ubyte_hi_sq)
0051C:  MOVF   x7A,W
0051E:  SUBLW  15
00520:  BNZ   0546
....................    {
....................       RxD_Buff[RxD_DataLen] = SBUF ;         //Byte 6   No. of point/force data Low Byte
00522:  MOVLW  7C
00524:  ADDWF  x7C,W
00526:  MOVWF  FE9
00528:  MOVLW  01
0052A:  MOVWF  FEA
0052C:  BTFSC  FD8.0
0052E:  INCF   FEA,F
00530:  MOVFF  30,FEF
....................       restart_wdt();
00534:  CLRWDT
....................       RxD_DataLen ++ ;
00536:  INCF   x7C,F
....................       sequence = ubyte_lo_sq;
00538:  MOVFF  75,7A
....................       T_timeout = 0x14; //200ms
0053C:  MOVLW  14
0053E:  MOVLB  5
00540:  MOVWF  x87
....................    }
00542:  BRA    0598
00544:  MOVLB  0
....................    else if(sequence == ubyte_lo_sq)
00546:  MOVF   x75,W
00548:  SUBWF  x7A,W
0054A:  BNZ   0570
....................    {
....................       RxD_Buff[RxD_DataLen] = SBUF ;         //Byte 7   CRC High Byte
0054C:  MOVLW  7C
0054E:  ADDWF  x7C,W
00550:  MOVWF  FE9
00552:  MOVLW  01
00554:  MOVWF  FEA
00556:  BTFSC  FD8.0
00558:  INCF   FEA,F
0055A:  MOVFF  30,FEF
....................       restart_wdt();
0055E:  CLRWDT
....................       RxD_DataLen ++ ;
00560:  INCF   x7C,F
....................       sequence = crc_hi_sq;
00562:  MOVFF  76,7A
....................       T_timeout = 0x14; //200ms
00566:  MOVLW  14
00568:  MOVLB  5
0056A:  MOVWF  x87
....................    }
0056C:  BRA    0598
0056E:  MOVLB  0
....................    else if(sequence == crc_hi_sq)
00570:  MOVF   x76,W
00572:  SUBWF  x7A,W
00574:  BNZ   0598
....................    {
....................       RxD_Buff[RxD_DataLen] = SBUF ;         //Byte 8   CRC Low Byte
00576:  MOVLW  7C
00578:  ADDWF  x7C,W
0057A:  MOVWF  FE9
0057C:  MOVLW  01
0057E:  MOVWF  FEA
00580:  BTFSC  FD8.0
00582:  INCF   FEA,F
00584:  MOVFF  30,FEF
....................       restart_wdt();
00588:  CLRWDT
....................       sequence = end_sq;
0058A:  MOVFF  71,7A
....................       T_timeout = 0x00;
0058E:  MOVLB  5
00590:  CLRF   x87
....................       recieve_completed = 1 ;            //Recieve completed then translate
00592:  BSF    32.5
....................       output_bit(P485ctrl,0);
00594:  BCF    F8A.3
00596:  BCF    F93.3
00598:  MOVLB  0
....................      //T_timeout = 0x14; //200ms  
....................      
....................    }
0059A:  GOTO   05A8 (RETURN)
.................... }
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////
.................... ///////////////////// MODBUS FUNCTION //////////////////////////////////////////
.................... ////////////////////////////////////////////////////////////////////////////////
.................... void Modbus_Function(void)
.................... {
....................    restart_wdt();
*
0212E:  CLRWDT
....................    CRC(RxD_Buff , RxD_DataLen - 1);
02130:  MOVLW  01
02132:  SUBWF  x7C,W
02134:  MOVLB  7
02136:  MOVWF  xB9
02138:  MOVLW  01
0213A:  MOVWF  xBB
0213C:  MOVLW  7C
0213E:  MOVWF  xBA
02140:  MOVFF  7B9,7BC
02144:  MOVLB  0
02146:  RCALL  1D7C
.................... 
....................    if(CRC_Hi == RxD_Buff[RxD_DataLen - 1] && CRC_Lo == RxD_Buff[RxD_DataLen])
02148:  MOVLW  01
0214A:  SUBWF  x7C,W
0214C:  ADDLW  7C
0214E:  MOVWF  FE9
02150:  MOVLW  01
02152:  MOVWF  FEA
02154:  BTFSC  FD8.0
02156:  INCF   FEA,F
02158:  MOVF   FEF,W
0215A:  MOVLB  3
0215C:  SUBWF  x7D,W
0215E:  BTFSS  FD8.2
02160:  GOTO   4168
02164:  MOVLW  7C
02166:  MOVLB  0
02168:  ADDWF  x7C,W
0216A:  MOVWF  FE9
0216C:  MOVLW  01
0216E:  MOVWF  FEA
02170:  BTFSC  FD8.0
02172:  INCF   FEA,F
02174:  MOVF   FEF,W
02176:  MOVLB  3
02178:  SUBWF  x7C,W
0217A:  BTFSS  FD8.2
0217C:  GOTO   4168
....................    {
....................       
....................     
....................       if((RxD_Buff[0] == 0xAA)&&(RxD_Buff[1] == 0x20)) //Read Setting//0xAA Is Any Address 
02180:  MOVLB  1
02182:  MOVF   x7C,W
02184:  SUBLW  AA
02186:  BTFSS  FD8.2
02188:  BRA    2446
0218A:  MOVF   x7D,W
0218C:  SUBLW  20
0218E:  BTFSS  FD8.2
02190:  BRA    2446
....................       {
....................          TxD_Buff[0] = Address ;         //Address
02192:  MOVFF  7B,7D
....................          TxD_Buff[1] = 0x20 ;            //function code
02196:  MOVLW  20
02198:  MOVLB  0
0219A:  MOVWF  x7E
....................          TxD_Buff[2] = 0x1C ;           //28 Byte  //Data Byte count
0219C:  MOVLW  1C
0219E:  MOVWF  x7F
....................          TxD_Buff[3] = InputType1_8 ;    //1
021A0:  MOVFF  3C,80
....................          TxD_Buff[4] = InputType9_16 ;  //2
021A4:  MOVFF  3D,81
....................          TxD_Buff[5] = InputType17_24 ;//3
021A8:  MOVFF  3E,82
....................          
....................          TxD_Buff[6] = FaultType1_8 ;  //4
021AC:  MOVFF  3F,83
....................          TxD_Buff[7] = FaultType9_16 ; //5
021B0:  MOVFF  40,84
....................          TxD_Buff[8] = FaultType17_24 ;   //6
021B4:  MOVFF  41,85
....................         
....................          TxD_Buff[9] = OutputType1_8 ; //7
021B8:  MOVFF  42,86
....................          TxD_Buff[10] = OutputType9_16 ;  //8
021BC:  MOVFF  43,87
....................          TxD_Buff[11] = OutputType17_24 ; //9
021C0:  MOVFF  44,88
....................         
....................          TxD_Buff[12] = OutputBoth1_8 ;   //10
021C4:  MOVFF  45,89
....................          TxD_Buff[13] = OutputBoth9_16 ;  //11
021C8:  MOVFF  46,8A
....................          TxD_Buff[14] = OutputBoth17_24 ; //12
021CC:  MOVFF  47,8B
....................         
....................          TxD_Buff[15] = Alarm_Indicator1_8 ; //13
021D0:  MOVFF  48,8C
....................          TxD_Buff[16] = Alarm_Indicator9_16 ;   //14
021D4:  MOVFF  49,8D
....................          TxD_Buff[17] = Alarm_Indicator17_24 ;  //15
021D8:  MOVFF  4A,8E
....................         
....................           TxD_Buff[18] = read_eeprom(0x10);//Red1_8;    //16
021DC:  MOVFF  FF2,7B9
021E0:  BCF    FF2.7
021E2:  CLRF   FAA
021E4:  MOVLW  10
021E6:  MOVWF  FA9
021E8:  BCF    FA6.6
021EA:  BCF    FA6.7
021EC:  BSF    FA6.0
021EE:  MOVF   FA8,W
021F0:  MOVLB  7
021F2:  BTFSC  xB9.7
021F4:  BSF    FF2.7
021F6:  MOVLB  0
021F8:  MOVWF  x8F
....................           TxD_Buff[19] = read_eeprom(0x11);//Red9_10;      //17
021FA:  MOVFF  FF2,7B9
021FE:  BCF    FF2.7
02200:  CLRF   FAA
02202:  MOVLW  11
02204:  MOVWF  FA9
02206:  BCF    FA6.6
02208:  BCF    FA6.7
0220A:  BSF    FA6.0
0220C:  MOVF   FA8,W
0220E:  MOVLB  7
02210:  BTFSC  xB9.7
02212:  BSF    FF2.7
02214:  MOVLB  0
02216:  MOVWF  x90
....................           TxD_Buff[20] = read_eeprom(0x12);//Red11_18;     //18
02218:  MOVFF  FF2,7B9
0221C:  BCF    FF2.7
0221E:  CLRF   FAA
02220:  MOVLW  12
02222:  MOVWF  FA9
02224:  BCF    FA6.6
02226:  BCF    FA6.7
02228:  BSF    FA6.0
0222A:  MOVF   FA8,W
0222C:  MOVLB  7
0222E:  BTFSC  xB9.7
02230:  BSF    FF2.7
02232:  MOVLB  0
02234:  MOVWF  x91
....................           TxD_Buff[21] = read_eeprom(0x13);//Red19_20;     //19
02236:  MOVFF  FF2,7B9
0223A:  BCF    FF2.7
0223C:  CLRF   FAA
0223E:  MOVLW  13
02240:  MOVWF  FA9
02242:  BCF    FA6.6
02244:  BCF    FA6.7
02246:  BSF    FA6.0
02248:  MOVF   FA8,W
0224A:  MOVLB  7
0224C:  BTFSC  xB9.7
0224E:  BSF    FF2.7
02250:  MOVLB  0
02252:  MOVWF  x92
....................           
....................           TxD_Buff[22] = read_eeprom(0x14);//Green1_8;     //20
02254:  MOVFF  FF2,7B9
02258:  BCF    FF2.7
0225A:  CLRF   FAA
0225C:  MOVLW  14
0225E:  MOVWF  FA9
02260:  BCF    FA6.6
02262:  BCF    FA6.7
02264:  BSF    FA6.0
02266:  MOVF   FA8,W
02268:  MOVLB  7
0226A:  BTFSC  xB9.7
0226C:  BSF    FF2.7
0226E:  MOVLB  0
02270:  MOVWF  x93
....................           TxD_Buff[23] = read_eeprom(0x15);//Green9_10;    //21
02272:  MOVFF  FF2,7B9
02276:  BCF    FF2.7
02278:  CLRF   FAA
0227A:  MOVLW  15
0227C:  MOVWF  FA9
0227E:  BCF    FA6.6
02280:  BCF    FA6.7
02282:  BSF    FA6.0
02284:  MOVF   FA8,W
02286:  MOVLB  7
02288:  BTFSC  xB9.7
0228A:  BSF    FF2.7
0228C:  MOVLB  0
0228E:  MOVWF  x94
....................           TxD_Buff[24] = read_eeprom(0x16);//Green11_18;      //22
02290:  MOVFF  FF2,7B9
02294:  BCF    FF2.7
02296:  CLRF   FAA
02298:  MOVLW  16
0229A:  MOVWF  FA9
0229C:  BCF    FA6.6
0229E:  BCF    FA6.7
022A0:  BSF    FA6.0
022A2:  MOVF   FA8,W
022A4:  MOVLB  7
022A6:  BTFSC  xB9.7
022A8:  BSF    FF2.7
022AA:  MOVLB  0
022AC:  MOVWF  x95
....................           TxD_Buff[25] = read_eeprom(0x17);//Green19_20;      //23
022AE:  MOVFF  FF2,7B9
022B2:  BCF    FF2.7
022B4:  CLRF   FAA
022B6:  MOVLW  17
022B8:  MOVWF  FA9
022BA:  BCF    FA6.6
022BC:  BCF    FA6.7
022BE:  BSF    FA6.0
022C0:  MOVF   FA8,W
022C2:  MOVLB  7
022C4:  BTFSC  xB9.7
022C6:  BSF    FF2.7
022C8:  MOVLB  0
022CA:  MOVWF  x96
....................        
....................          TxD_Buff[26] = AutoAck ;            //24
022CC:  MOVFF  6C,97
....................          TxD_Buff[27] = AutoAckTime ;        //25
022D0:  MOVFF  6D,98
....................          TxD_Buff[28] = FlashingRate ;       //26
022D4:  MOVFF  6E,99
....................          TxD_Buff[29] = NoOfPoint ;          //27
022D8:  MOVFF  6F,9A
....................          TxD_Buff[30] = FaultDelayTime ;    //28
022DC:  MOVLW  7B
022DE:  MOVWF  x9B
....................          TxD_Buff[31] = Address ;            //29
022E0:  MOVFF  7B,9C
.................... 
....................          TxD_Buff[32] = FaultDelayTime[1] ;
022E4:  MOVFF  77D,9D
....................          TxD_Buff[33] = FaultDelayTime[2] ;
022E8:  MOVFF  77F,9E
....................          TxD_Buff[34] = FaultDelayTime[3] ;
022EC:  MOVFF  781,9F
....................          TxD_Buff[35] = FaultDelayTime[4] ;
022F0:  MOVFF  783,A0
....................          TxD_Buff[36] = FaultDelayTime[5] ;
022F4:  MOVFF  785,A1
....................          TxD_Buff[37] = FaultDelayTime[6] ;
022F8:  MOVFF  787,A2
....................          TxD_Buff[38] = FaultDelayTime[7] ;
022FC:  MOVFF  789,A3
....................          TxD_Buff[39] = FaultDelayTime[8] ;
02300:  MOVFF  78B,A4
....................          TxD_Buff[40] = FaultDelayTime[9] ;
02304:  MOVFF  78D,A5
....................          TxD_Buff[41] = FaultDelayTime[10] ;
02308:  MOVFF  78F,A6
....................          TxD_Buff[42] = FaultDelayTime[11] ;
0230C:  MOVFF  791,A7
....................          TxD_Buff[43] = FaultDelayTime[12] ;
02310:  MOVFF  793,A8
....................          TxD_Buff[44] = FaultDelayTime[13] ;
02314:  MOVFF  795,A9
....................          TxD_Buff[45] = FaultDelayTime[14] ;
02318:  MOVFF  797,AA
....................          TxD_Buff[46] = FaultDelayTime[15] ;
0231C:  MOVFF  799,AB
....................          TxD_Buff[47] = FaultDelayTime[16] ;
02320:  MOVFF  79B,AC
....................          TxD_Buff[48] = FaultDelayTime[17] ;
02324:  MOVFF  79D,AD
....................          TxD_Buff[49] = FaultDelayTime[18] ;
02328:  MOVFF  79F,AE
....................          TxD_Buff[50] = FaultDelayTime[19] ;
0232C:  MOVFF  7A1,AF
....................          TxD_Buff[51] = FaultDelayTime[20] ;
02330:  MOVFF  7A3,B0
....................          
....................          CRC(TxD_Buff,52)   ; //Cal CRC 49 byte
02334:  MOVLB  7
02336:  CLRF   xBB
02338:  MOVLW  7D
0233A:  MOVWF  xBA
0233C:  MOVLW  34
0233E:  MOVWF  xBC
02340:  MOVLB  0
02342:  RCALL  1D7C
.................... 
....................          TxD_Buff[52] = CRC_Hi ;
02344:  MOVFF  37D,B1
....................          TxD_Buff[53] = CRC_Lo ;
02348:  MOVFF  37C,B2
.................... 
....................          output_bit(P485ctrl,1);
0234C:  BSF    F8A.3
0234E:  BCF    F93.3
....................          delay_ms(10);
02350:  MOVLW  0A
02352:  MOVLB  7
02354:  MOVWF  xB9
02356:  MOVLB  0
02358:  CALL   0662
.................... 
....................          putc(Txd_Buff[0]);
0235C:  MOVF   x7D,W
0235E:  RCALL  1DD2
....................          putc(Txd_Buff[1]);
02360:  MOVF   x7E,W
02362:  RCALL  1DD2
....................          putc(Txd_Buff[2]);
02364:  MOVF   x7F,W
02366:  RCALL  1DD2
....................          putc(Txd_Buff[3]);
02368:  MOVF   x80,W
0236A:  RCALL  1DD2
....................          putc(Txd_Buff[4]);
0236C:  MOVF   x81,W
0236E:  RCALL  1DD2
....................          putc(Txd_Buff[5]);
02370:  MOVF   x82,W
02372:  RCALL  1DD2
....................          putc(Txd_Buff[6]);
02374:  MOVF   x83,W
02376:  RCALL  1DD2
....................          putc(Txd_Buff[7]);
02378:  MOVF   x84,W
0237A:  RCALL  1DD2
....................          putc(Txd_Buff[8]);
0237C:  MOVF   x85,W
0237E:  RCALL  1DD2
....................          putc(Txd_Buff[9]);
02380:  MOVF   x86,W
02382:  RCALL  1DD2
....................          putc(Txd_Buff[10]);
02384:  MOVF   x87,W
02386:  RCALL  1DD2
....................          putc(Txd_Buff[11]);
02388:  MOVF   x88,W
0238A:  RCALL  1DD2
....................          putc(Txd_Buff[12]);
0238C:  MOVF   x89,W
0238E:  RCALL  1DD2
....................          putc(Txd_Buff[13]);
02390:  MOVF   x8A,W
02392:  RCALL  1DD2
....................          putc(Txd_Buff[14]);
02394:  MOVF   x8B,W
02396:  RCALL  1DD2
....................          putc(Txd_Buff[15]);
02398:  MOVF   x8C,W
0239A:  RCALL  1DD2
....................          putc(Txd_Buff[16]);
0239C:  MOVF   x8D,W
0239E:  RCALL  1DD2
....................          putc(Txd_Buff[17]);
023A0:  MOVF   x8E,W
023A2:  RCALL  1DD2
....................          putc(Txd_Buff[18]);
023A4:  MOVF   x8F,W
023A6:  RCALL  1DD2
....................          putc(Txd_Buff[19]);
023A8:  MOVF   x90,W
023AA:  RCALL  1DD2
....................          putc(Txd_Buff[20]);
023AC:  MOVF   x91,W
023AE:  RCALL  1DD2
....................          putc(Txd_Buff[21]);
023B0:  MOVF   x92,W
023B2:  RCALL  1DD2
....................          putc(Txd_Buff[22]);
023B4:  MOVF   x93,W
023B6:  RCALL  1DD2
....................          putc(Txd_Buff[23]);
023B8:  MOVF   x94,W
023BA:  RCALL  1DD2
....................          putc(Txd_Buff[24]);
023BC:  MOVF   x95,W
023BE:  RCALL  1DD2
....................          putc(Txd_Buff[25]);
023C0:  MOVF   x96,W
023C2:  RCALL  1DD2
....................          putc(Txd_Buff[26]);
023C4:  MOVF   x97,W
023C6:  RCALL  1DD2
....................          putc(Txd_Buff[27]);
023C8:  MOVF   x98,W
023CA:  RCALL  1DD2
....................          putc(Txd_Buff[28]);
023CC:  MOVF   x99,W
023CE:  RCALL  1DD2
....................          putc(Txd_Buff[29]);
023D0:  MOVF   x9A,W
023D2:  RCALL  1DD2
....................          putc(Txd_Buff[30]);
023D4:  MOVF   x9B,W
023D6:  RCALL  1DD2
....................          putc(Txd_Buff[31]);
023D8:  MOVF   x9C,W
023DA:  RCALL  1DD2
....................          
....................          putc(Txd_Buff[32]);
023DC:  MOVF   x9D,W
023DE:  RCALL  1DD2
....................          putc(Txd_Buff[33]);
023E0:  MOVF   x9E,W
023E2:  RCALL  1DD2
....................          putc(Txd_Buff[34]);
023E4:  MOVF   x9F,W
023E6:  RCALL  1DD2
....................          putc(Txd_Buff[35]);
023E8:  MOVF   xA0,W
023EA:  RCALL  1DD2
....................          putc(Txd_Buff[36]);
023EC:  MOVF   xA1,W
023EE:  RCALL  1DD2
....................          putc(Txd_Buff[37]);
023F0:  MOVF   xA2,W
023F2:  RCALL  1DD2
....................          putc(Txd_Buff[38]);
023F4:  MOVF   xA3,W
023F6:  RCALL  1DD2
....................          putc(Txd_Buff[39]);
023F8:  MOVF   xA4,W
023FA:  RCALL  1DD2
....................          putc(Txd_Buff[40]);
023FC:  MOVF   xA5,W
023FE:  RCALL  1DD2
....................          putc(Txd_Buff[41]);
02400:  MOVF   xA6,W
02402:  RCALL  1DD2
....................          
....................          putc(Txd_Buff[42]);
02404:  MOVF   xA7,W
02406:  RCALL  1DD2
....................          putc(Txd_Buff[43]);
02408:  MOVF   xA8,W
0240A:  RCALL  1DD2
....................          putc(Txd_Buff[44]);
0240C:  MOVF   xA9,W
0240E:  RCALL  1DD2
....................          putc(Txd_Buff[45]);
02410:  MOVF   xAA,W
02412:  RCALL  1DD2
....................          putc(Txd_Buff[46]);
02414:  MOVF   xAB,W
02416:  RCALL  1DD2
....................          putc(Txd_Buff[47]);
02418:  MOVF   xAC,W
0241A:  RCALL  1DD2
....................          putc(Txd_Buff[48]);
0241C:  MOVF   xAD,W
0241E:  RCALL  1DD2
....................          putc(Txd_Buff[49]);
02420:  MOVF   xAE,W
02422:  RCALL  1DD2
....................          putc(Txd_Buff[50]);
02424:  MOVF   xAF,W
02426:  RCALL  1DD2
....................          putc(Txd_Buff[51]);
02428:  MOVF   xB0,W
0242A:  RCALL  1DD2
....................          
....................          putc(Txd_Buff[52]);
0242C:  MOVF   xB1,W
0242E:  RCALL  1DD2
....................          putc(Txd_Buff[53]);
02430:  MOVF   xB2,W
02432:  RCALL  1DD2
....................        
....................          delay_ms(3);
02434:  MOVLW  03
02436:  MOVLB  7
02438:  MOVWF  xB9
0243A:  MOVLB  0
0243C:  CALL   0662
....................          output_bit(P485ctrl,0);
02440:  BCF    F8A.3
02442:  BCF    F93.3
02444:  MOVLB  1
....................           
....................       }
....................    
.................... 
....................    ///////////////////////////////////////////////////////////////
....................       if(RxD_Buff[0] == Address)
02446:  MOVLB  0
02448:  MOVF   x7B,W
0244A:  MOVLB  1
0244C:  SUBWF  x7C,W
0244E:  BTFSS  FD8.2
02450:  GOTO   415E
....................       {
....................       
....................       if(RxD_Buff[1] == 0x01)///////////// READ COIL /////////////////////
02454:  DECFSZ x7D,W
02456:  BRA    287C
....................       {
....................             //Do Read Coil
....................             Start_Address = RxD_Buff[2] ;
02458:  MOVLB  3
0245A:  CLRF   x81
0245C:  MOVFF  17E,380
....................             Start_Address = (Start_Address << 8) | RxD_Buff[3] ;   //Start Address 16 bit
02460:  MOVFF  380,381
02464:  MOVLB  7
02466:  CLRF   xB9
02468:  MOVF   xB9,W
0246A:  MOVLB  1
0246C:  IORWF  x7F,W
0246E:  MOVLB  3
02470:  MOVWF  x80
02472:  MOVLB  3
....................             No_PointCount = RxD_Buff[4] ;
02474:  CLRF   x83
02476:  MOVFF  180,382
....................             No_PointCount = (No_PointCount << 8) | RxD_Buff[5] ;   //No. of Point 16 bit
0247A:  MOVFF  382,383
0247E:  MOVLB  7
02480:  CLRF   xB9
02482:  MOVF   xB9,W
02484:  MOVLB  1
02486:  IORWF  x81,W
02488:  MOVLB  3
0248A:  MOVWF  x82
0248C:  MOVLB  3
.................... 
....................             if(Start_Address < 0x10 && (Start_Address + No_PointCount) < 0x11)  //Valid point 0-15
0248E:  MOVF   x81,F
02490:  BTFSS  FD8.2
02492:  BRA    280A
02494:  MOVF   x80,W
02496:  SUBLW  0F
02498:  BTFSS  FD8.0
0249A:  BRA    280A
0249C:  MOVF   x82,W
0249E:  ADDWF  x80,W
024A0:  MOVLB  7
024A2:  MOVWF  xB9
024A4:  MOVLB  3
024A6:  MOVF   x83,W
024A8:  ADDWFC x81,W
024AA:  MOVLB  7
024AC:  MOVWF  xBA
024AE:  MOVF   xBA,F
024B0:  BTFSC  FD8.2
024B2:  BRA    24B8
024B4:  MOVLB  3
024B6:  BRA    280A
024B8:  MOVF   xB9,W
024BA:  SUBLW  10
024BC:  BTFSC  FD8.0
024BE:  BRA    24C4
024C0:  MOVLB  3
024C2:  BRA    280A
....................             {
....................                if(No_PointCount < 9) Data_ByteCount = 0x01 ;
024C4:  MOVLB  3
024C6:  MOVF   x83,F
024C8:  BNZ   24D6
024CA:  MOVF   x82,W
024CC:  SUBLW  08
024CE:  BNC   24D6
024D0:  MOVLW  01
024D2:  MOVWF  x84
024D4:  BRA    24FA
....................                else if(No_PointCount < 17) Data_ByteCount = 0x02 ;
024D6:  MOVF   x83,F
024D8:  BNZ   24E6
024DA:  MOVF   x82,W
024DC:  SUBLW  10
024DE:  BNC   24E6
024E0:  MOVLW  02
024E2:  MOVWF  x84
024E4:  BRA    24FA
....................                else if(No_PointCount < 25) Data_ByteCount = 0x03 ;
024E6:  MOVF   x83,F
024E8:  BNZ   24F6
024EA:  MOVF   x82,W
024EC:  SUBLW  18
024EE:  BNC   24F6
024F0:  MOVLW  03
024F2:  MOVWF  x84
024F4:  BRA    24FA
....................                else   Data_ByteCount = 0x01 ; //----Jack
024F6:  MOVLW  01
024F8:  MOVWF  x84
.................... 
....................                if(Data_ByteCount == 0x01)
024FA:  DECFSZ x84,W
024FC:  BRA    2642
....................                {
.................... 
....................                   if(Start_Address < 0x09)
024FE:  MOVF   x81,F
02500:  BNZ   251C
02502:  MOVF   x80,W
02504:  SUBLW  08
02506:  BNC   251C
....................                   {
....................                      //Data_Buff[0] = ~output[0] >> Start_Address ;
....................                      //DataTemp = ~output[1] << (0x08 - Start_Address) ;
....................                      //Data_Buff[0] = (~output[0] >> Start_Address) | DataTemp;   //Low Byte
....................                       Data_Buff[0] = Input1_8 >> Start_Address ;
02508:  MOVFF  4B,385
0250C:  MOVF   x80,W
0250E:  MOVWF  01
02510:  BZ    251A
02512:  BCF    FD8.0
02514:  RRCF   x85,F
02516:  DECFSZ 01,F
02518:  BRA    2512
....................                       //DataTemp = Input9_16 << (0x08 - Start_Address) ;//JJ
....................                       //Data_Buff[0] = (Input1_8 >> Start_Address) | DataTemp;   //Low Byte//JJ
....................                   }
0251A:  BRA    2550
....................                   else if(Start_Address > 0x08 && Start_Address < 0x10)
0251C:  MOVF   x81,F
0251E:  BNZ   2526
02520:  MOVF   x80,W
02522:  SUBLW  08
02524:  BC    2550
02526:  MOVF   x81,F
02528:  BNZ   2550
0252A:  MOVF   x80,W
0252C:  SUBLW  0F
0252E:  BNC   2550
....................                   {
....................                      //Data_Buff[0] = ~output[1] >> (Start_Address - 0x08) ;
....................                      Data_Buff[0] = Input9_16 >> (Start_Address - 0x08) ;
02530:  MOVLW  08
02532:  SUBWF  x80,W
02534:  MOVWF  00
02536:  MOVLW  00
02538:  SUBWFB x81,W
0253A:  MOVWF  03
0253C:  MOVFF  00,01
02540:  MOVFF  4C,385
02544:  MOVF   01,F
02546:  BZ    2550
02548:  BCF    FD8.0
0254A:  RRCF   x85,F
0254C:  DECFSZ 01,F
0254E:  BRA    2548
....................                   }
.................... 
.................... 
....................                   if(No_PointCount == 0x08)
02550:  MOVF   x82,W
02552:  SUBLW  08
02554:  BNZ   255C
02556:  MOVF   x83,F
02558:  BNZ   255C
....................                   {
....................                      Data_Buff[0] = Data_Buff[0] & 0xFF ; //8 Point High Byte
....................                   }
0255A:  BRA    25C6
....................                   else if(No_PointCount == 0x07)
0255C:  MOVF   x82,W
0255E:  SUBLW  07
02560:  BNZ   256A
02562:  MOVF   x83,F
02564:  BNZ   256A
....................                   {
....................                      Data_Buff[0] =    Data_Buff[0] & 0x7F ; //7 Point High Byte
02566:  BCF    x85.7
....................                   }
02568:  BRA    25C6
....................                   else if(No_PointCount == 0x06)
0256A:  MOVF   x82,W
0256C:  SUBLW  06
0256E:  BNZ   257A
02570:  MOVF   x83,F
02572:  BNZ   257A
....................                   {
....................                      Data_Buff[0] =    Data_Buff[0] & 0x3F ; //6 Point High Byte
02574:  MOVLW  3F
02576:  ANDWF  x85,F
....................                   }
02578:  BRA    25C6
....................                   else if(No_PointCount == 0x05)
0257A:  MOVF   x82,W
0257C:  SUBLW  05
0257E:  BNZ   258A
02580:  MOVF   x83,F
02582:  BNZ   258A
....................                   {
....................                      Data_Buff[0] =    Data_Buff[0] & 0x1F ; //5 Point High Byte
02584:  MOVLW  1F
02586:  ANDWF  x85,F
....................                   }
02588:  BRA    25C6
....................                   else if(No_PointCount == 0x04)
0258A:  MOVF   x82,W
0258C:  SUBLW  04
0258E:  BNZ   259A
02590:  MOVF   x83,F
02592:  BNZ   259A
....................                   {
....................                      Data_Buff[0] =    Data_Buff[0] & 0x0F ; //4 Point High Byte
02594:  MOVLW  0F
02596:  ANDWF  x85,F
....................                   }
02598:  BRA    25C6
....................                   else if(No_PointCount == 0x03)
0259A:  MOVF   x82,W
0259C:  SUBLW  03
0259E:  BNZ   25AA
025A0:  MOVF   x83,F
025A2:  BNZ   25AA
....................                   {
....................                      Data_Buff[0] =    Data_Buff[0] & 0x07 ; //3 Point High Byte
025A4:  MOVLW  07
025A6:  ANDWF  x85,F
....................                   }
025A8:  BRA    25C6
....................                   else if(No_PointCount == 0x02)
025AA:  MOVF   x82,W
025AC:  SUBLW  02
025AE:  BNZ   25BA
025B0:  MOVF   x83,F
025B2:  BNZ   25BA
....................                   {
....................                      Data_Buff[0] =    Data_Buff[0] & 0x03 ; //2 Point High Byte
025B4:  MOVLW  03
025B6:  ANDWF  x85,F
....................                   }
025B8:  BRA    25C6
....................                   else if(No_PointCount == 0x01)
025BA:  DECFSZ x82,W
025BC:  BRA    25C6
025BE:  MOVF   x83,F
025C0:  BNZ   25C6
....................                   {
....................                      Data_Buff[0] =    Data_Buff[0] & 0x01 ; //1 Point High Byte
025C2:  MOVLW  01
025C4:  ANDWF  x85,F
....................                   }
.................... 
....................                   TxD_Buff[0] = Address ;         //Address
025C6:  MOVFF  7B,7D
....................                   TxD_Buff[1] = 0x01 ;         //Function Code
025CA:  MOVLW  01
025CC:  MOVLB  0
025CE:  MOVWF  x7E
....................                   TxD_Buff[2] = Data_ByteCount ;   //Byte Count
025D0:  MOVFF  384,7F
....................                   TxD_Buff[3] = Data_Buff[0] ;   //Data
025D4:  MOVFF  385,80
.................... 
....................                   CRC(TxD_Buff,4)   ;            //Cal CRC 5 Byte
025D8:  MOVLB  7
025DA:  CLRF   xBB
025DC:  MOVLW  7D
025DE:  MOVWF  xBA
025E0:  MOVLW  04
025E2:  MOVWF  xBC
025E4:  MOVLB  0
025E6:  CALL   1D7C
.................... 
....................                   TxD_Buff[4] = CRC_Hi ;
025EA:  MOVFF  37D,81
....................                   TxD_Buff[5] = CRC_Lo ;
025EE:  MOVFF  37C,82
.................... 
.................... 
....................                   output_bit(P485ctrl,1);
025F2:  BSF    F8A.3
025F4:  BCF    F93.3
....................                   restart_wdt();
025F6:  CLRWDT
....................                   delay_ms(4);
025F8:  MOVLW  04
025FA:  MOVLB  7
025FC:  MOVWF  xB9
025FE:  MOVLB  0
02600:  CALL   0662
....................                   restart_wdt();
02604:  CLRWDT
.................... 
....................                   putc(TxD_Buff[0]) ;               //Address
02606:  MOVF   x7D,W
02608:  CALL   1DD2
....................                   putc(TxD_Buff[1]) ;               //Function Code
0260C:  MOVF   x7E,W
0260E:  CALL   1DD2
....................                   putc(TxD_Buff[2]) ;               //Byte Count
02612:  MOVF   x7F,W
02614:  CALL   1DD2
....................                   putc(TxD_Buff[3]) ;
02618:  MOVF   x80,W
0261A:  CALL   1DD2
....................                   putc(TxD_Buff[4]) ;
0261E:  MOVF   x81,W
02620:  CALL   1DD2
....................                   putc(TxD_Buff[5]) ;
02624:  MOVF   x82,W
02626:  CALL   1DD2
.................... 
....................                
....................                   restart_wdt();
0262A:  CLRWDT
....................                   delay_ms(3);
0262C:  MOVLW  03
0262E:  MOVLB  7
02630:  MOVWF  xB9
02632:  MOVLB  0
02634:  CALL   0662
....................                   restart_wdt();
02638:  CLRWDT
....................                   output_bit(P485ctrl,0);
0263A:  BCF    F8A.3
0263C:  BCF    F93.3
....................               
....................                }
0263E:  BRA    2806
02640:  MOVLB  3
....................                else if(Data_ByteCount == 0x02)
02642:  MOVF   x84,W
02644:  SUBLW  02
02646:  BTFSS  FD8.2
02648:  BRA    2808
....................                {
.................... 
....................                   Data_Buff[0] = Input1_8 >> Start_Address ;
0264A:  MOVFF  4B,385
0264E:  MOVF   x80,W
02650:  MOVWF  01
02652:  BZ    265C
02654:  BCF    FD8.0
02656:  RRCF   x85,F
02658:  DECFSZ 01,F
0265A:  BRA    2654
....................                   Data_Buff[1] = Input9_16 ;// >> Start_Address ;
0265C:  MOVFF  4C,386
.................... 
.................... 
....................                   if((No_PointCount - 0x07) == 0x08)
02660:  MOVLW  07
02662:  SUBWF  x82,W
02664:  MOVLB  7
02666:  MOVWF  xB9
02668:  MOVLW  00
0266A:  MOVLB  3
0266C:  SUBWFB x83,W
0266E:  MOVLB  7
02670:  MOVWF  xBA
02672:  MOVF   xB9,W
02674:  SUBLW  08
02676:  BNZ   267E
02678:  MOVF   xBA,F
0267A:  BNZ   267E
....................                   {
....................                      Data_Buff[1] = Data_Buff[1] & 0xFF ; //16 Point High Byte
....................                   }
0267C:  BRA    2784
....................                   else if((No_PointCount - 0x07) == 0x07)
0267E:  MOVLW  07
02680:  MOVLB  3
02682:  SUBWF  x82,W
02684:  MOVLB  7
02686:  MOVWF  xB9
02688:  MOVLW  00
0268A:  MOVLB  3
0268C:  SUBWFB x83,W
0268E:  MOVLB  7
02690:  MOVWF  xBA
02692:  MOVF   xB9,W
02694:  SUBLW  07
02696:  BNZ   26A2
02698:  MOVF   xBA,F
0269A:  BNZ   26A2
....................                   {
....................                      Data_Buff[1] =    Data_Buff[1] & 0x7F ; //15 Point High Byte
0269C:  MOVLB  3
0269E:  BCF    x86.7
....................                   }
026A0:  BRA    2782
....................                   else if((No_PointCount - 0x07) == 0x06)
026A2:  MOVLW  07
026A4:  MOVLB  3
026A6:  SUBWF  x82,W
026A8:  MOVLB  7
026AA:  MOVWF  xB9
026AC:  MOVLW  00
026AE:  MOVLB  3
026B0:  SUBWFB x83,W
026B2:  MOVLB  7
026B4:  MOVWF  xBA
026B6:  MOVF   xB9,W
026B8:  SUBLW  06
026BA:  BNZ   26C8
026BC:  MOVF   xBA,F
026BE:  BNZ   26C8
....................                   {
....................                      Data_Buff[1] =    Data_Buff[1] & 0x3F ; //14 Point High Byte
026C0:  MOVLW  3F
026C2:  MOVLB  3
026C4:  ANDWF  x86,F
....................                   }
026C6:  BRA    2782
....................                   else if((No_PointCount - 0x07) == 0x05)
026C8:  MOVLW  07
026CA:  MOVLB  3
026CC:  SUBWF  x82,W
026CE:  MOVLB  7
026D0:  MOVWF  xB9
026D2:  MOVLW  00
026D4:  MOVLB  3
026D6:  SUBWFB x83,W
026D8:  MOVLB  7
026DA:  MOVWF  xBA
026DC:  MOVF   xB9,W
026DE:  SUBLW  05
026E0:  BNZ   26EE
026E2:  MOVF   xBA,F
026E4:  BNZ   26EE
....................                   {
....................                      Data_Buff[1] =    Data_Buff[1] & 0x1F ; //13 Point High Byte
026E6:  MOVLW  1F
026E8:  MOVLB  3
026EA:  ANDWF  x86,F
....................                   }
026EC:  BRA    2782
....................                   else if((No_PointCount - 0x07) == 0x04)
026EE:  MOVLW  07
026F0:  MOVLB  3
026F2:  SUBWF  x82,W
026F4:  MOVLB  7
026F6:  MOVWF  xB9
026F8:  MOVLW  00
026FA:  MOVLB  3
026FC:  SUBWFB x83,W
026FE:  MOVLB  7
02700:  MOVWF  xBA
02702:  MOVF   xB9,W
02704:  SUBLW  04
02706:  BNZ   2714
02708:  MOVF   xBA,F
0270A:  BNZ   2714
....................                   {
....................                      Data_Buff[1] =    Data_Buff[1] & 0x0F ; //12 Point High Byte
0270C:  MOVLW  0F
0270E:  MOVLB  3
02710:  ANDWF  x86,F
....................                   }
02712:  BRA    2782
....................                   else if((No_PointCount - 0x07) == 0x03)
02714:  MOVLW  07
02716:  MOVLB  3
02718:  SUBWF  x82,W
0271A:  MOVLB  7
0271C:  MOVWF  xB9
0271E:  MOVLW  00
02720:  MOVLB  3
02722:  SUBWFB x83,W
02724:  MOVLB  7
02726:  MOVWF  xBA
02728:  MOVF   xB9,W
0272A:  SUBLW  03
0272C:  BNZ   273A
0272E:  MOVF   xBA,F
02730:  BNZ   273A
....................                   {
....................                      Data_Buff[1] =    Data_Buff[1] & 0x07 ; //11 Point High Byte
02732:  MOVLW  07
02734:  MOVLB  3
02736:  ANDWF  x86,F
....................                   }
02738:  BRA    2782
....................                   else if((No_PointCount - 0x07) == 0x02)
0273A:  MOVLW  07
0273C:  MOVLB  3
0273E:  SUBWF  x82,W
02740:  MOVLB  7
02742:  MOVWF  xB9
02744:  MOVLW  00
02746:  MOVLB  3
02748:  SUBWFB x83,W
0274A:  MOVLB  7
0274C:  MOVWF  xBA
0274E:  MOVF   xB9,W
02750:  SUBLW  02
02752:  BNZ   2760
02754:  MOVF   xBA,F
02756:  BNZ   2760
....................                   {
....................                      Data_Buff[1] =    Data_Buff[1] & 0x03 ; //10 Point High Byte
02758:  MOVLW  03
0275A:  MOVLB  3
0275C:  ANDWF  x86,F
....................                   }
0275E:  BRA    2782
....................                   else if((No_PointCount - 0x07) == 0x01)
02760:  MOVLW  07
02762:  MOVLB  3
02764:  SUBWF  x82,W
02766:  MOVLB  7
02768:  MOVWF  xB9
0276A:  MOVLW  00
0276C:  MOVLB  3
0276E:  SUBWFB x83,W
02770:  MOVLB  7
02772:  MOVWF  xBA
02774:  DECFSZ xB9,W
02776:  BRA    2784
02778:  MOVF   xBA,F
0277A:  BNZ   2784
....................                   {
....................                      Data_Buff[1] =    Data_Buff[1] & 0x01 ; //9 Point High Byte
0277C:  MOVLW  01
0277E:  MOVLB  3
02780:  ANDWF  x86,F
02782:  MOVLB  7
....................                   }
.................... 
....................                   TxD_Buff[0] = Address ;         //Address
02784:  MOVFF  7B,7D
....................                   TxD_Buff[1] = 0x01 ;         //Function Code
02788:  MOVLW  01
0278A:  MOVLB  0
0278C:  MOVWF  x7E
....................                   TxD_Buff[2] = Data_ByteCount ;   //Byte Count
0278E:  MOVFF  384,7F
....................                   TxD_Buff[3] = Data_Buff[0] ;      //first byte Data
02792:  MOVFF  385,80
....................                   TxD_Buff[4] = Data_Buff[1] ;      //second byte Data
02796:  MOVFF  386,81
.................... 
....................                   CRC(TxD_Buff,5)   ;            //Cal CRC 5 Byte
0279A:  MOVLB  7
0279C:  CLRF   xBB
0279E:  MOVLW  7D
027A0:  MOVWF  xBA
027A2:  MOVLW  05
027A4:  MOVWF  xBC
027A6:  MOVLB  0
027A8:  CALL   1D7C
.................... 
....................                   TxD_Buff[5] = CRC_Hi ;
027AC:  MOVFF  37D,82
....................                   TxD_Buff[6] = CRC_Lo ;
027B0:  MOVFF  37C,83
.................... 
.................... 
....................                   output_bit(P485ctrl,1);
027B4:  BSF    F8A.3
027B6:  BCF    F93.3
....................                   restart_wdt();
027B8:  CLRWDT
....................                   delay_ms(4);
027BA:  MOVLW  04
027BC:  MOVLB  7
027BE:  MOVWF  xB9
027C0:  MOVLB  0
027C2:  CALL   0662
....................                   restart_wdt();
027C6:  CLRWDT
.................... 
....................                   putc(TxD_Buff[0]) ;               //Address
027C8:  MOVF   x7D,W
027CA:  CALL   1DD2
....................                   putc(TxD_Buff[1]) ;               //Function Code
027CE:  MOVF   x7E,W
027D0:  CALL   1DD2
....................                   putc(TxD_Buff[2]) ;               //Byte Count
027D4:  MOVF   x7F,W
027D6:  CALL   1DD2
....................                   putc(TxD_Buff[3]) ;
027DA:  MOVF   x80,W
027DC:  CALL   1DD2
....................                   putc(TxD_Buff[4]) ;
027E0:  MOVF   x81,W
027E2:  CALL   1DD2
....................                   putc(TxD_Buff[5]) ;
027E6:  MOVF   x82,W
027E8:  CALL   1DD2
....................                   putc(TxD_Buff[6]) ;
027EC:  MOVF   x83,W
027EE:  CALL   1DD2
.................... 
.................... 
....................                   restart_wdt();
027F2:  CLRWDT
....................                   delay_ms(3);
027F4:  MOVLW  03
027F6:  MOVLB  7
027F8:  MOVWF  xB9
027FA:  MOVLB  0
027FC:  CALL   0662
....................                   restart_wdt();
02800:  CLRWDT
....................                   output_bit(P485ctrl,0);
02802:  BCF    F8A.3
02804:  BCF    F93.3
02806:  MOVLB  3
....................               
....................                }
....................             }
02808:  BRA    287A
....................             else
....................             {
....................                //invalid parameter
....................                TxD_Buff[0] = Address ;         //Address
0280A:  MOVFF  7B,7D
....................                TxD_Buff[1] = 0x81 ;         //Function Code
0280E:  MOVLW  81
02810:  MOVLB  0
02812:  MOVWF  x7E
....................                TxD_Buff[2] = 0x02 ;         //illegal data address
02814:  MOVLW  02
02816:  MOVWF  x7F
.................... 
....................                CRC(TxD_Buff,3)   ;            //Cal CRC 3 Byte
02818:  MOVLB  7
0281A:  CLRF   xBB
0281C:  MOVLW  7D
0281E:  MOVWF  xBA
02820:  MOVLW  03
02822:  MOVWF  xBC
02824:  MOVLB  0
02826:  CALL   1D7C
.................... 
....................                TxD_Buff[3] = CRC_Hi ;
0282A:  MOVFF  37D,80
....................                TxD_Buff[4] = CRC_Lo ;
0282E:  MOVFF  37C,81
.................... 
....................                output_bit(P485ctrl,1);
02832:  BSF    F8A.3
02834:  BCF    F93.3
....................                restart_wdt();
02836:  CLRWDT
....................                delay_ms(4);
02838:  MOVLW  04
0283A:  MOVLB  7
0283C:  MOVWF  xB9
0283E:  MOVLB  0
02840:  CALL   0662
....................                restart_wdt();
02844:  CLRWDT
.................... 
....................                putc(TxD_Buff[0]) ;               //Address
02846:  MOVF   x7D,W
02848:  CALL   1DD2
....................                putc(TxD_Buff[1]) ;               //Function Code
0284C:  MOVF   x7E,W
0284E:  CALL   1DD2
....................                putc(TxD_Buff[2]) ;               //Byte Count
02852:  MOVF   x7F,W
02854:  CALL   1DD2
....................                putc(TxD_Buff[3]) ;
02858:  MOVF   x80,W
0285A:  CALL   1DD2
....................                putc(TxD_Buff[4]) ;
0285E:  MOVF   x81,W
02860:  CALL   1DD2
.................... 
.................... 
....................                restart_wdt();
02864:  CLRWDT
....................                delay_ms(3);
02866:  MOVLW  03
02868:  MOVLB  7
0286A:  MOVWF  xB9
0286C:  MOVLB  0
0286E:  CALL   0662
....................                restart_wdt();
02872:  CLRWDT
....................                output_bit(P485ctrl,0);
02874:  BCF    F8A.3
02876:  BCF    F93.3
02878:  MOVLB  3
0287A:  MOVLB  1
....................                
....................             }
....................          }
.................... ////\*/
.................... 
.................... 
....................                  /*-------------jack----*/
....................  
....................       if(RxD_Buff[1] == 0x07)///////////// READ COIL (esp code)////////////
0287C:  MOVF   x7D,W
0287E:  SUBLW  07
02880:  BTFSS  FD8.2
02882:  BRA    29E6
....................       {
....................          alarmtosend();
02884:  MOVLB  0
02886:  GOTO   1DDA
....................          
....................          disable_interrupts(INT_TIMER2);
0288A:  BCF    F9D.1
....................          //----------------------------------jj----------------------------//
....................          
....................             Data_Buff[0] = Input1_8_Send ; //>> Start_Address ;
0288C:  MOVFF  20,385
....................             Data_Buff[1] = Input9_16_Send ;// >> Start_Address ;
02890:  MOVFF  21,386
....................             Data_Buff[2] = Input17_24_Send ;// >> Start_Address ;
02894:  MOVFF  22,387
....................             Data_Buff[3] = Input25_32_Send ;
02898:  MOVFF  23,388
....................             Data_Buff[4] = Input33_40_Send ;
0289C:  MOVFF  24,389
....................             Data_Buff[5] = Input41_48_Send ;
028A0:  MOVFF  25,38A
....................             Data_Buff[6] = Input49_56_Send ;
028A4:  MOVFF  26,38B
....................             Data_Buff[7] = Input57_64_Send ;
028A8:  MOVFF  27,38C
....................            
....................             Data_Buff[8] = Ack1_8_Send ;
028AC:  MOVFF  28,38D
....................             Data_Buff[9] = Ack9_16_Send ;
028B0:  MOVFF  29,38E
....................             Data_Buff[10] = Ack17_24_Send ;
028B4:  MOVFF  2A,38F
....................             Data_Buff[11] = Ack25_32_Send ;
028B8:  MOVFF  2B,390
....................             Data_Buff[12] = Ack33_40_Send ;
028BC:  MOVFF  2C,391
....................             Data_Buff[13] = Ack41_48_Send ;
028C0:  MOVFF  2D,392
....................             Data_Buff[14] = Ack49_56_Send ;
028C4:  MOVFF  2E,393
....................             Data_Buff[15] = Ack57_64_Send ;
028C8:  MOVFF  2F,394
....................    
....................             
....................             
....................             TxD_Buff[0] = Address ;         //Address
028CC:  MOVFF  7B,7D
....................             TxD_Buff[1] = 0x07 ;         //Function Code
028D0:  MOVLW  07
028D2:  MOVWF  x7E
....................             TxD_Buff[2] = Data_ByteCount=0x10;   //Byte Count
028D4:  MOVLW  10
028D6:  MOVLB  3
028D8:  MOVWF  x84
028DA:  MOVFF  384,7F
....................             TxD_Buff[3] = Data_Buff[0] ;      //first byte Data
028DE:  MOVFF  385,80
....................             TxD_Buff[4] = Data_Buff[1] ;      //second byte Data
028E2:  MOVFF  386,81
....................             TxD_Buff[5] = Data_Buff[2] ;  
028E6:  MOVFF  387,82
....................             TxD_Buff[6] = Data_Buff[3] ;
028EA:  MOVFF  388,83
....................             TxD_Buff[7] = Data_Buff[4] ;
028EE:  MOVFF  389,84
....................             TxD_Buff[8] = Data_Buff[5] ;
028F2:  MOVFF  38A,85
....................             TxD_Buff[9] = Data_Buff[6] ;
028F6:  MOVFF  38B,86
....................             TxD_Buff[10] = Data_Buff[7] ;
028FA:  MOVFF  38C,87
....................               
....................            TxD_Buff[11] = Data_Buff[8] ; //Ack1-8
028FE:  MOVFF  38D,88
....................            TxD_Buff[12] = Data_Buff[9] ;
02902:  MOVFF  38E,89
....................            TxD_Buff[13] = Data_Buff[10] ;
02906:  MOVFF  38F,8A
....................            TxD_Buff[14] = Data_Buff[11] ;
0290A:  MOVFF  390,8B
....................            TxD_Buff[15] = Data_Buff[12] ;
0290E:  MOVFF  391,8C
....................            TxD_Buff[16] = Data_Buff[13] ;
02912:  MOVFF  392,8D
....................            TxD_Buff[17] = Data_Buff[14] ;
02916:  MOVFF  393,8E
....................            TxD_Buff[18] = Data_Buff[15] ; //Ack57-64
0291A:  MOVFF  394,8F
.................... 
....................            CRC(TxD_Buff,19);            //Cal CRC 5 Byte
0291E:  MOVLB  7
02920:  CLRF   xBB
02922:  MOVLW  7D
02924:  MOVWF  xBA
02926:  MOVLW  13
02928:  MOVWF  xBC
0292A:  MOVLB  0
0292C:  CALL   1D7C
.................... 
....................           TxD_Buff[19] = CRC_Hi ;
02930:  MOVFF  37D,90
....................           TxD_Buff[20] = CRC_Lo ;
02934:  MOVFF  37C,91
.................... 
....................         
....................          output_bit(P485ctrl,1);
02938:  BSF    F8A.3
0293A:  BCF    F93.3
....................          restart_wdt();
0293C:  CLRWDT
....................          delay_ms(4);
0293E:  MOVLW  04
02940:  MOVLB  7
02942:  MOVWF  xB9
02944:  MOVLB  0
02946:  CALL   0662
....................          restart_wdt();
0294A:  CLRWDT
....................          
....................          
....................          
....................          putc(TxD_Buff[0]) ;               //Address
0294C:  MOVF   x7D,W
0294E:  CALL   1DD2
....................          putc(TxD_Buff[1]) ;               //Function Code
02952:  MOVF   x7E,W
02954:  CALL   1DD2
....................          putc(TxD_Buff[2]) ;               //Byte Count
02958:  MOVF   x7F,W
0295A:  CALL   1DD2
....................          putc(TxD_Buff[3]) ;
0295E:  MOVF   x80,W
02960:  CALL   1DD2
....................          putc(TxD_Buff[4]) ;
02964:  MOVF   x81,W
02966:  CALL   1DD2
....................          putc(TxD_Buff[5]) ;
0296A:  MOVF   x82,W
0296C:  CALL   1DD2
....................          putc(TxD_Buff[6]) ;
02970:  MOVF   x83,W
02972:  CALL   1DD2
....................          putc(TxD_Buff[7]) ;
02976:  MOVF   x84,W
02978:  CALL   1DD2
....................          putc(TxD_Buff[8]) ;
0297C:  MOVF   x85,W
0297E:  CALL   1DD2
....................          putc(TxD_Buff[9]) ;
02982:  MOVF   x86,W
02984:  CALL   1DD2
....................          putc(TxD_Buff[10]) ;
02988:  MOVF   x87,W
0298A:  CALL   1DD2
....................          putc(TxD_Buff[11]) ;
0298E:  MOVF   x88,W
02990:  CALL   1DD2
....................          putc(TxD_Buff[12]) ;
02994:  MOVF   x89,W
02996:  CALL   1DD2
....................          putc(TxD_Buff[13]) ;
0299A:  MOVF   x8A,W
0299C:  CALL   1DD2
....................          putc(TxD_Buff[14]) ;
029A0:  MOVF   x8B,W
029A2:  CALL   1DD2
....................          putc(TxD_Buff[15]) ;
029A6:  MOVF   x8C,W
029A8:  CALL   1DD2
....................          putc(TxD_Buff[16]) ;
029AC:  MOVF   x8D,W
029AE:  CALL   1DD2
....................          putc(TxD_Buff[17]) ;
029B2:  MOVF   x8E,W
029B4:  CALL   1DD2
....................          putc(TxD_Buff[18]) ;
029B8:  MOVF   x8F,W
029BA:  CALL   1DD2
....................          putc(TxD_Buff[19]) ;
029BE:  MOVF   x90,W
029C0:  CALL   1DD2
....................          putc(TxD_Buff[20]) ;
029C4:  MOVF   x91,W
029C6:  CALL   1DD2
.................... 
....................          restart_wdt();
029CA:  CLRWDT
....................          delay_ms(3);
029CC:  MOVLW  03
029CE:  MOVLB  7
029D0:  MOVWF  xB9
029D2:  MOVLB  0
029D4:  CALL   0662
....................          restart_wdt();
029D8:  CLRWDT
....................          output_bit(P485ctrl,0);
029DA:  BCF    F8A.3
029DC:  BCF    F93.3
....................            
....................          /////////////////////////////////////////
....................          
....................         enable_interrupts(INT_TIMER2); 
029DE:  BSF    F9D.1
....................      
....................        }
029E0:  GOTO   40C8
029E4:  MOVLB  1
....................       /////////////////////////////////////////////////////////////////
.................... 
....................        else if(RxD_Buff[1] == 0x05)///////////// FORCE COIL /////////////////////
029E6:  MOVF   x7D,W
029E8:  SUBLW  05
029EA:  BTFSS  FD8.2
029EC:  BRA    2EDA
....................          {
....................             //Do Force Coil
....................             Start_Address = RxD_Buff[2] ;
029EE:  MOVLB  3
029F0:  CLRF   x81
029F2:  MOVFF  17E,380
....................             Start_Address = (Start_Address << 8) | RxD_Buff[3] ;   //Coil Address 16 bit
029F6:  MOVFF  380,381
029FA:  MOVLB  7
029FC:  CLRF   xB9
029FE:  MOVF   xB9,W
02A00:  MOVLB  1
02A02:  IORWF  x7F,W
02A04:  MOVLB  3
02A06:  MOVWF  x80
02A08:  MOVLB  3
....................             No_PointCount = RxD_Buff[4] ;
02A0A:  CLRF   x83
02A0C:  MOVFF  180,382
....................             No_PointCount = (No_PointCount << 8) | RxD_Buff[5] ;   //Force Data 16 bit FF00 = ON, 00FF = OFF
02A10:  MOVFF  382,383
02A14:  MOVLB  7
02A16:  CLRF   xB9
02A18:  MOVF   xB9,W
02A1A:  MOVLB  1
02A1C:  IORWF  x81,W
02A1E:  MOVLB  3
02A20:  MOVWF  x82
02A22:  MOVLB  3
.................... 
....................             if(Start_Address == 0x00)   ////// Acknowlegde //////
02A24:  MOVF   x80,F
02A26:  BNZ   2AC6
02A28:  MOVF   x81,F
02A2A:  BNZ   2AC6
....................             {
....................                if(No_PointCount == 0xFF00)   //ON
02A2C:  MOVF   x82,F
02A2E:  BNZ   2AC4
02A30:  INCFSZ x83,W
02A32:  BRA    2AC4
....................                {
....................                   //Modbus_ACK = 1 ;
....................                   AutoAckFlag = 1;
02A34:  BSF    1C.2
.................... 
....................                   TxD_Buff[0] = Address ;         //Address
02A36:  MOVFF  7B,7D
....................                   TxD_Buff[1] = 0x05 ;         //Function Code
02A3A:  MOVLW  05
02A3C:  MOVLB  0
02A3E:  MOVWF  x7E
....................                   TxD_Buff[2] = RxD_Buff[2] ;      //Coil Address Hi
02A40:  MOVFF  17E,7F
....................                   TxD_Buff[3] = RxD_Buff[3] ;      //Coil Address Lo
02A44:  MOVFF  17F,80
....................                   TxD_Buff[4] = RxD_Buff[4] ;      //Force Data Hi
02A48:  MOVFF  180,81
....................                   TxD_Buff[5] = RxD_Buff[5] ;      //Force Data Lo
02A4C:  MOVFF  181,82
.................... 
....................                   CRC(TxD_Buff,6)   ;            //Cal CRC 6 Byte
02A50:  MOVLB  7
02A52:  CLRF   xBB
02A54:  MOVLW  7D
02A56:  MOVWF  xBA
02A58:  MOVLW  06
02A5A:  MOVWF  xBC
02A5C:  MOVLB  0
02A5E:  CALL   1D7C
.................... 
....................                   TxD_Buff[6] = CRC_Hi ;
02A62:  MOVFF  37D,83
....................                   TxD_Buff[7] = CRC_Lo ;
02A66:  MOVFF  37C,84
.................... 
....................                   output_bit(P485ctrl,1);
02A6A:  BSF    F8A.3
02A6C:  BCF    F93.3
....................                   restart_wdt();
02A6E:  CLRWDT
....................                   delay_ms(4);
02A70:  MOVLW  04
02A72:  MOVLB  7
02A74:  MOVWF  xB9
02A76:  MOVLB  0
02A78:  CALL   0662
....................                   restart_wdt();
02A7C:  CLRWDT
.................... 
....................                   putc(TxD_Buff[0]) ;               //Address
02A7E:  MOVF   x7D,W
02A80:  CALL   1DD2
....................                   putc(TxD_Buff[1]) ;               //Function Code
02A84:  MOVF   x7E,W
02A86:  CALL   1DD2
....................                   putc(TxD_Buff[2]) ;               //Byte Count
02A8A:  MOVF   x7F,W
02A8C:  CALL   1DD2
....................                   putc(TxD_Buff[3]) ;
02A90:  MOVF   x80,W
02A92:  CALL   1DD2
....................                   putc(TxD_Buff[4]) ;
02A96:  MOVF   x81,W
02A98:  CALL   1DD2
....................                   putc(TxD_Buff[5]) ;
02A9C:  MOVF   x82,W
02A9E:  CALL   1DD2
....................                   putc(TxD_Buff[6]) ;
02AA2:  MOVF   x83,W
02AA4:  CALL   1DD2
....................                   putc(TxD_Buff[7]) ;
02AA8:  MOVF   x84,W
02AAA:  CALL   1DD2
.................... 
.................... 
....................                   restart_wdt();
02AAE:  CLRWDT
....................                   delay_ms(3);
02AB0:  MOVLW  03
02AB2:  MOVLB  7
02AB4:  MOVWF  xB9
02AB6:  MOVLB  0
02AB8:  CALL   0662
....................                   restart_wdt();
02ABC:  CLRWDT
....................                   output_bit(P485ctrl,0);
02ABE:  BCF    F8A.3
02AC0:  BCF    F93.3
02AC2:  MOVLB  3
....................               
....................                }
....................             }
02AC4:  BRA    2ED4
....................             else if(Start_Address == 0x01)   ///// Reset //////
02AC6:  DECFSZ x80,W
02AC8:  BRA    2B68
02ACA:  MOVF   x81,F
02ACC:  BNZ   2B68
....................             {
....................                if(No_PointCount == 0xFF00)   //ON
02ACE:  MOVF   x82,F
02AD0:  BNZ   2B66
02AD2:  INCFSZ x83,W
02AD4:  BRA    2B66
....................                {
....................                   //Modbus_RET = 1 ;
....................                   AutoResetFlag = 1;
02AD6:  BSF    1C.3
....................                   
....................                   TxD_Buff[0] = Address ;         //Address
02AD8:  MOVFF  7B,7D
....................                   TxD_Buff[1] = 0x05 ;         //Function Code
02ADC:  MOVLW  05
02ADE:  MOVLB  0
02AE0:  MOVWF  x7E
....................                   TxD_Buff[2] = RxD_Buff[2] ;      //Coil Address Hi
02AE2:  MOVFF  17E,7F
....................                   TxD_Buff[3] = RxD_Buff[3] ;      //Coil Address Lo
02AE6:  MOVFF  17F,80
....................                   TxD_Buff[4] = RxD_Buff[4] ;      //Force Data Hi
02AEA:  MOVFF  180,81
....................                   TxD_Buff[5] = RxD_Buff[5] ;      //Force Data Lo
02AEE:  MOVFF  181,82
.................... 
....................                   CRC(TxD_Buff,6)   ;            //Cal CRC 6 Byte
02AF2:  MOVLB  7
02AF4:  CLRF   xBB
02AF6:  MOVLW  7D
02AF8:  MOVWF  xBA
02AFA:  MOVLW  06
02AFC:  MOVWF  xBC
02AFE:  MOVLB  0
02B00:  CALL   1D7C
.................... 
....................                   TxD_Buff[6] = CRC_Hi ;
02B04:  MOVFF  37D,83
....................                   TxD_Buff[7] = CRC_Lo ;
02B08:  MOVFF  37C,84
.................... 
.................... 
....................               output_bit(P485ctrl,1);
02B0C:  BSF    F8A.3
02B0E:  BCF    F93.3
....................                   restart_wdt();
02B10:  CLRWDT
....................                   delay_ms(4);
02B12:  MOVLW  04
02B14:  MOVLB  7
02B16:  MOVWF  xB9
02B18:  MOVLB  0
02B1A:  CALL   0662
....................                   restart_wdt();
02B1E:  CLRWDT
.................... 
....................                   putc(TxD_Buff[0]) ;               //Address
02B20:  MOVF   x7D,W
02B22:  CALL   1DD2
....................                   putc(TxD_Buff[1]) ;               //Function Code
02B26:  MOVF   x7E,W
02B28:  CALL   1DD2
....................                   putc(TxD_Buff[2]) ;               //Byte Count
02B2C:  MOVF   x7F,W
02B2E:  CALL   1DD2
....................                   putc(TxD_Buff[3]) ;
02B32:  MOVF   x80,W
02B34:  CALL   1DD2
....................                   putc(TxD_Buff[4]) ;
02B38:  MOVF   x81,W
02B3A:  CALL   1DD2
....................                   putc(TxD_Buff[5]) ;
02B3E:  MOVF   x82,W
02B40:  CALL   1DD2
....................                   putc(TxD_Buff[6]) ;
02B44:  MOVF   x83,W
02B46:  CALL   1DD2
....................                   putc(TxD_Buff[7]) ;
02B4A:  MOVF   x84,W
02B4C:  CALL   1DD2
....................                   //putc(TxD_Buff[8]) ;
....................                   //putc(TxD_Buff[9]) ;
.................... 
....................                   restart_wdt();
02B50:  CLRWDT
....................                   delay_ms(3);
02B52:  MOVLW  03
02B54:  MOVLB  7
02B56:  MOVWF  xB9
02B58:  MOVLB  0
02B5A:  CALL   0662
....................                   restart_wdt();
02B5E:  CLRWDT
....................                   output_bit(P485ctrl,0);
02B60:  BCF    F8A.3
02B62:  BCF    F93.3
02B64:  MOVLB  3
....................               
....................                }
....................             }
02B66:  BRA    2ED4
....................             else if(Start_Address == 0x02)   ///// Test //////
02B68:  MOVF   x80,W
02B6A:  SUBLW  02
02B6C:  BTFSS  FD8.2
02B6E:  BRA    2CBA
02B70:  MOVF   x81,F
02B72:  BTFSS  FD8.2
02B74:  BRA    2CBA
....................             {
....................                if(No_PointCount == 0xFF00)   //ON
02B76:  MOVF   x82,F
02B78:  BNZ   2C10
02B7A:  INCFSZ x83,W
02B7C:  BRA    2C10
....................                {
....................                   //Modbus_Lamp_Test = 1 ;
....................                   AutoTestFlag = 1;
02B7E:  BSF    1C.4
.................... 
....................                   TxD_Buff[0] = Address ;         //Address
02B80:  MOVFF  7B,7D
....................                   TxD_Buff[1] = 0x05 ;         //Function Code
02B84:  MOVLW  05
02B86:  MOVLB  0
02B88:  MOVWF  x7E
....................                   TxD_Buff[2] = RxD_Buff[2] ;      //Coil Address Hi
02B8A:  MOVFF  17E,7F
....................                   TxD_Buff[3] = RxD_Buff[3] ;      //Coil Address Lo
02B8E:  MOVFF  17F,80
....................                   TxD_Buff[4] = RxD_Buff[4] ;      //Force Data Hi
02B92:  MOVFF  180,81
....................                   TxD_Buff[5] = RxD_Buff[5] ;      //Force Data Lo
02B96:  MOVFF  181,82
.................... 
....................                   CRC(TxD_Buff,6)   ;            //Cal CRC 6 Byte
02B9A:  MOVLB  7
02B9C:  CLRF   xBB
02B9E:  MOVLW  7D
02BA0:  MOVWF  xBA
02BA2:  MOVLW  06
02BA4:  MOVWF  xBC
02BA6:  MOVLB  0
02BA8:  CALL   1D7C
.................... 
....................                   TxD_Buff[6] = CRC_Hi ;
02BAC:  MOVFF  37D,83
....................                   TxD_Buff[7] = CRC_Lo ;
02BB0:  MOVFF  37C,84
.................... 
....................                   output_bit(P485ctrl,1);
02BB4:  BSF    F8A.3
02BB6:  BCF    F93.3
....................                   restart_wdt();
02BB8:  CLRWDT
....................                   delay_ms(4);
02BBA:  MOVLW  04
02BBC:  MOVLB  7
02BBE:  MOVWF  xB9
02BC0:  MOVLB  0
02BC2:  CALL   0662
....................                   restart_wdt();
02BC6:  CLRWDT
.................... 
....................                   putc(TxD_Buff[0]) ;               //Address
02BC8:  MOVF   x7D,W
02BCA:  CALL   1DD2
....................                   putc(TxD_Buff[1]) ;               //Function Code
02BCE:  MOVF   x7E,W
02BD0:  CALL   1DD2
....................                   putc(TxD_Buff[2]) ;               //Byte Count
02BD4:  MOVF   x7F,W
02BD6:  CALL   1DD2
....................                   putc(TxD_Buff[3]) ;
02BDA:  MOVF   x80,W
02BDC:  CALL   1DD2
....................                   putc(TxD_Buff[4]) ;
02BE0:  MOVF   x81,W
02BE2:  CALL   1DD2
....................                   putc(TxD_Buff[5]) ;
02BE6:  MOVF   x82,W
02BE8:  CALL   1DD2
....................                   putc(TxD_Buff[6]) ;
02BEC:  MOVF   x83,W
02BEE:  CALL   1DD2
....................                   putc(TxD_Buff[7]) ;
02BF2:  MOVF   x84,W
02BF4:  CALL   1DD2
.................... 
....................                   restart_wdt();
02BF8:  CLRWDT
....................                   delay_ms(3);
02BFA:  MOVLW  03
02BFC:  MOVLB  7
02BFE:  MOVWF  xB9
02C00:  MOVLB  0
02C02:  CALL   0662
....................                   restart_wdt();
02C06:  CLRWDT
....................                   output_bit(P485ctrl,0);
02C08:  BCF    F8A.3
02C0A:  BCF    F93.3
....................              
....................                }
02C0C:  BRA    2CB6
02C0E:  MOVLB  3
....................                else if(No_PointCount == 0x00)   //OFF
02C10:  MOVF   x82,F
02C12:  BNZ   2CB8
02C14:  MOVF   x83,F
02C16:  BNZ   2CB8
....................                {
....................                   //Modbus_Lamp_Test = 0 ;
....................                   AutoTestFlag = 0;
02C18:  BCF    1C.4
....................                   Read_input();
02C1A:  MOVLB  0
02C1C:  CALL   146E
....................                   AutoAckFlag = 1;
02C20:  BSF    1C.2
....................                   check_ack();
02C22:  CALL   1F46
....................                   AutoResetFlag = 1;
02C26:  BSF    1C.3
....................                   check_reset();
02C28:  CALL   202A
.................... 
....................                   TxD_Buff[0] = Address ;         //Address
02C2C:  MOVFF  7B,7D
....................                   TxD_Buff[1] = 0x05 ;         //Function Code
02C30:  MOVLW  05
02C32:  MOVWF  x7E
....................                   TxD_Buff[2] = RxD_Buff[2] ;      //Coil Address Hi
02C34:  MOVFF  17E,7F
....................                   TxD_Buff[3] = RxD_Buff[3] ;      //Coil Address Lo
02C38:  MOVFF  17F,80
....................                   TxD_Buff[4] = RxD_Buff[4] ;      //Force Data Hi
02C3C:  MOVFF  180,81
....................                   TxD_Buff[5] = RxD_Buff[5] ;      //Force Data Lo
02C40:  MOVFF  181,82
.................... 
....................                   CRC(TxD_Buff,6)   ;            //Cal CRC 6 Byte
02C44:  MOVLB  7
02C46:  CLRF   xBB
02C48:  MOVLW  7D
02C4A:  MOVWF  xBA
02C4C:  MOVLW  06
02C4E:  MOVWF  xBC
02C50:  MOVLB  0
02C52:  CALL   1D7C
.................... 
....................                   TxD_Buff[6] = CRC_Hi ;
02C56:  MOVFF  37D,83
....................                   TxD_Buff[7] = CRC_Lo ;
02C5A:  MOVFF  37C,84
.................... 
....................                   output_bit(P485ctrl,1);
02C5E:  BSF    F8A.3
02C60:  BCF    F93.3
....................                   restart_wdt();
02C62:  CLRWDT
....................                   delay_ms(4);
02C64:  MOVLW  04
02C66:  MOVLB  7
02C68:  MOVWF  xB9
02C6A:  MOVLB  0
02C6C:  CALL   0662
....................                   restart_wdt();
02C70:  CLRWDT
.................... 
....................                   putc(TxD_Buff[0]) ;               //Address
02C72:  MOVF   x7D,W
02C74:  CALL   1DD2
....................                   putc(TxD_Buff[1]) ;               //Function Code
02C78:  MOVF   x7E,W
02C7A:  CALL   1DD2
....................                   putc(TxD_Buff[2]) ;               //Byte Count
02C7E:  MOVF   x7F,W
02C80:  CALL   1DD2
....................                   putc(TxD_Buff[3]) ;
02C84:  MOVF   x80,W
02C86:  CALL   1DD2
....................                   putc(TxD_Buff[4]) ;
02C8A:  MOVF   x81,W
02C8C:  CALL   1DD2
....................                   putc(TxD_Buff[5]) ;
02C90:  MOVF   x82,W
02C92:  CALL   1DD2
....................                   putc(TxD_Buff[6]) ;
02C96:  MOVF   x83,W
02C98:  CALL   1DD2
....................                   putc(TxD_Buff[7]) ;
02C9C:  MOVF   x84,W
02C9E:  CALL   1DD2
....................                   //putc(TxD_Buff[8]) ;
....................                   //putc(TxD_Buff[9]) ;
.................... 
....................                   restart_wdt();
02CA2:  CLRWDT
....................                   delay_ms(3);
02CA4:  MOVLW  03
02CA6:  MOVLB  7
02CA8:  MOVWF  xB9
02CAA:  MOVLB  0
02CAC:  CALL   0662
....................                   restart_wdt();
02CB0:  CLRWDT
....................                   output_bit(P485ctrl,0);
02CB2:  BCF    F8A.3
02CB4:  BCF    F93.3
02CB6:  MOVLB  3
....................                   
....................                }
....................             }
02CB8:  BRA    2ED4
....................             else if(Start_Address == 0x03)   ///// Function Test //////
02CBA:  MOVF   x80,W
02CBC:  SUBLW  03
02CBE:  BTFSS  FD8.2
02CC0:  BRA    2E0C
02CC2:  MOVF   x81,F
02CC4:  BTFSS  FD8.2
02CC6:  BRA    2E0C
....................             {
....................                if(No_PointCount == 0xFF00)   //ON
02CC8:  MOVF   x82,F
02CCA:  BNZ   2D62
02CCC:  INCFSZ x83,W
02CCE:  BRA    2D62
....................                {
....................                   //Modbus_Lamp_Test = 1 ;
....................                   test_fault = 1 ;
02CD0:  BSF    1C.5
.................... 
....................                   TxD_Buff[0] = Address ;         //Address
02CD2:  MOVFF  7B,7D
....................                   TxD_Buff[1] = 0x05 ;         //Function Code
02CD6:  MOVLW  05
02CD8:  MOVLB  0
02CDA:  MOVWF  x7E
....................                   TxD_Buff[2] = RxD_Buff[2] ;      //Coil Address Hi
02CDC:  MOVFF  17E,7F
....................                   TxD_Buff[3] = RxD_Buff[3] ;      //Coil Address Lo
02CE0:  MOVFF  17F,80
....................                   TxD_Buff[4] = RxD_Buff[4] ;      //Force Data Hi
02CE4:  MOVFF  180,81
....................                   TxD_Buff[5] = RxD_Buff[5] ;      //Force Data Lo
02CE8:  MOVFF  181,82
.................... 
....................                   CRC(TxD_Buff,6)   ;            //Cal CRC 6 Byte
02CEC:  MOVLB  7
02CEE:  CLRF   xBB
02CF0:  MOVLW  7D
02CF2:  MOVWF  xBA
02CF4:  MOVLW  06
02CF6:  MOVWF  xBC
02CF8:  MOVLB  0
02CFA:  CALL   1D7C
.................... 
....................                   TxD_Buff[6] = CRC_Hi ;
02CFE:  MOVFF  37D,83
....................                   TxD_Buff[7] = CRC_Lo ;
02D02:  MOVFF  37C,84
.................... 
....................                  output_bit(P485ctrl,1);
02D06:  BSF    F8A.3
02D08:  BCF    F93.3
....................                   restart_wdt();
02D0A:  CLRWDT
....................                   delay_ms(4);
02D0C:  MOVLW  04
02D0E:  MOVLB  7
02D10:  MOVWF  xB9
02D12:  MOVLB  0
02D14:  CALL   0662
....................                   restart_wdt();
02D18:  CLRWDT
.................... 
....................                   putc(TxD_Buff[0]) ;               //Address
02D1A:  MOVF   x7D,W
02D1C:  CALL   1DD2
....................                   putc(TxD_Buff[1]) ;               //Function Code
02D20:  MOVF   x7E,W
02D22:  CALL   1DD2
....................                   putc(TxD_Buff[2]) ;               //Byte Count
02D26:  MOVF   x7F,W
02D28:  CALL   1DD2
....................                   putc(TxD_Buff[3]) ;
02D2C:  MOVF   x80,W
02D2E:  CALL   1DD2
....................                   putc(TxD_Buff[4]) ;
02D32:  MOVF   x81,W
02D34:  CALL   1DD2
....................                   putc(TxD_Buff[5]) ;
02D38:  MOVF   x82,W
02D3A:  CALL   1DD2
....................                   putc(TxD_Buff[6]) ;
02D3E:  MOVF   x83,W
02D40:  CALL   1DD2
....................                   putc(TxD_Buff[7]) ;
02D44:  MOVF   x84,W
02D46:  CALL   1DD2
....................                   //putc(TxD_Buff[8]) ;
....................                   //putc(TxD_Buff[9]) ;
.................... 
....................                   restart_wdt();
02D4A:  CLRWDT
....................                   delay_ms(10);
02D4C:  MOVLW  0A
02D4E:  MOVLB  7
02D50:  MOVWF  xB9
02D52:  MOVLB  0
02D54:  CALL   0662
....................                   restart_wdt();
02D58:  CLRWDT
....................                   output_bit(P485ctrl,0);
02D5A:  BCF    F8A.3
02D5C:  BCF    F93.3
....................                }
02D5E:  BRA    2E08
02D60:  MOVLB  3
....................                else if(No_PointCount == 0x00)   //OFF
02D62:  MOVF   x82,F
02D64:  BNZ   2E0A
02D66:  MOVF   x83,F
02D68:  BNZ   2E0A
....................                {
....................                   //Modbus_Lamp_Test = 0 ;
....................                   test_fault = 0;
02D6A:  BCF    1C.5
....................                   Read_input();
02D6C:  MOVLB  0
02D6E:  CALL   146E
....................                   AutoAckFlag = 1;
02D72:  BSF    1C.2
....................                   check_ack();
02D74:  CALL   1F46
....................                   AutoResetFlag = 1;
02D78:  BSF    1C.3
....................                   check_reset();
02D7A:  CALL   202A
.................... 
....................                   TxD_Buff[0] = Address ;         //Address
02D7E:  MOVFF  7B,7D
....................                   TxD_Buff[1] = 0x05 ;         //Function Code
02D82:  MOVLW  05
02D84:  MOVWF  x7E
....................                   TxD_Buff[2] = RxD_Buff[2] ;      //Coil Address Hi
02D86:  MOVFF  17E,7F
....................                   TxD_Buff[3] = RxD_Buff[3] ;      //Coil Address Lo
02D8A:  MOVFF  17F,80
....................                   TxD_Buff[4] = RxD_Buff[4] ;      //Force Data Hi
02D8E:  MOVFF  180,81
....................                   TxD_Buff[5] = RxD_Buff[5] ;      //Force Data Lo
02D92:  MOVFF  181,82
.................... 
....................                   CRC(TxD_Buff,6)   ;            //Cal CRC 6 Byte
02D96:  MOVLB  7
02D98:  CLRF   xBB
02D9A:  MOVLW  7D
02D9C:  MOVWF  xBA
02D9E:  MOVLW  06
02DA0:  MOVWF  xBC
02DA2:  MOVLB  0
02DA4:  CALL   1D7C
.................... 
....................                   TxD_Buff[6] = CRC_Hi ;
02DA8:  MOVFF  37D,83
....................                   TxD_Buff[7] = CRC_Lo ;
02DAC:  MOVFF  37C,84
.................... 
....................                   output_bit(P485ctrl,1);
02DB0:  BSF    F8A.3
02DB2:  BCF    F93.3
....................                   restart_wdt();
02DB4:  CLRWDT
....................                   delay_ms(4);
02DB6:  MOVLW  04
02DB8:  MOVLB  7
02DBA:  MOVWF  xB9
02DBC:  MOVLB  0
02DBE:  CALL   0662
....................                   restart_wdt();
02DC2:  CLRWDT
.................... 
....................                   putc(TxD_Buff[0]) ;               //Address
02DC4:  MOVF   x7D,W
02DC6:  CALL   1DD2
....................                   putc(TxD_Buff[1]) ;               //Function Code
02DCA:  MOVF   x7E,W
02DCC:  CALL   1DD2
....................                   putc(TxD_Buff[2]) ;               //Byte Count
02DD0:  MOVF   x7F,W
02DD2:  CALL   1DD2
....................                   putc(TxD_Buff[3]) ;
02DD6:  MOVF   x80,W
02DD8:  CALL   1DD2
....................                   putc(TxD_Buff[4]) ;
02DDC:  MOVF   x81,W
02DDE:  CALL   1DD2
....................                   putc(TxD_Buff[5]) ;
02DE2:  MOVF   x82,W
02DE4:  CALL   1DD2
....................                   putc(TxD_Buff[6]) ;
02DE8:  MOVF   x83,W
02DEA:  CALL   1DD2
....................                   putc(TxD_Buff[7]) ;
02DEE:  MOVF   x84,W
02DF0:  CALL   1DD2
....................                   //putc(TxD_Buff[8]) ;
....................                   //putc(TxD_Buff[9]) ;
.................... 
....................                   restart_wdt();
02DF4:  CLRWDT
....................                   delay_ms(3);
02DF6:  MOVLW  03
02DF8:  MOVLB  7
02DFA:  MOVWF  xB9
02DFC:  MOVLB  0
02DFE:  CALL   0662
....................                   restart_wdt();
02E02:  CLRWDT
....................                   output_bit(P485ctrl,0);
02E04:  BCF    F8A.3
02E06:  BCF    F93.3
02E08:  MOVLB  3
....................                   
....................                }
....................             }
02E0A:  BRA    2ED4
....................             else if(Start_Address == 0x64)   ///// Change Modbus Addr //////
02E0C:  MOVF   x80,W
02E0E:  SUBLW  64
02E10:  BNZ   2ED4
02E12:  MOVF   x81,F
02E14:  BNZ   2ED4
....................             {
....................                Address = No_PointCount;
02E16:  MOVFF  382,7B
....................                write_eeprom(0x1D,Address);   //Communication Address
02E1A:  MOVF   FF2,W
02E1C:  MOVWF  00
02E1E:  BCF    FF2.7
02E20:  CLRF   FAA
02E22:  MOVLW  1D
02E24:  MOVWF  FA9
02E26:  MOVFF  7B,FA8
02E2A:  BCF    FA6.6
02E2C:  BCF    FA6.7
02E2E:  BSF    FA6.2
02E30:  MOVLB  F
02E32:  MOVLW  55
02E34:  MOVWF  FA7
02E36:  MOVLW  AA
02E38:  MOVWF  FA7
02E3A:  BSF    FA6.1
02E3C:  BTFSC  FA6.1
02E3E:  BRA    2E3C
02E40:  BCF    FA6.2
02E42:  MOVF   00,W
02E44:  IORWF  FF2,F
....................                
....................                TxD_Buff[0] = Address ;         //Address
02E46:  MOVFF  7B,7D
....................                TxD_Buff[1] = 0x05 ;         //Function Code
02E4A:  MOVLW  05
02E4C:  MOVLB  0
02E4E:  MOVWF  x7E
....................                TxD_Buff[2] = RxD_Buff[2] ;      //Coil Address Hi
02E50:  MOVFF  17E,7F
....................                TxD_Buff[3] = RxD_Buff[3] ;      //Coil Address Lo
02E54:  MOVFF  17F,80
....................                TxD_Buff[4] = RxD_Buff[4] ;      //Force Data Hi
02E58:  MOVFF  180,81
....................                TxD_Buff[5] = RxD_Buff[5] ;      //Force Data Lo
02E5C:  MOVFF  181,82
.................... 
....................                CRC(TxD_Buff,6)   ;            //Cal CRC 6 Byte
02E60:  MOVLB  7
02E62:  CLRF   xBB
02E64:  MOVLW  7D
02E66:  MOVWF  xBA
02E68:  MOVLW  06
02E6A:  MOVWF  xBC
02E6C:  MOVLB  0
02E6E:  CALL   1D7C
.................... 
....................                TxD_Buff[6] = CRC_Hi ;
02E72:  MOVFF  37D,83
....................                TxD_Buff[7] = CRC_Lo ;
02E76:  MOVFF  37C,84
.................... 
....................                output_bit(P485ctrl,1);
02E7A:  BSF    F8A.3
02E7C:  BCF    F93.3
....................                restart_wdt();
02E7E:  CLRWDT
....................                delay_ms(4);
02E80:  MOVLW  04
02E82:  MOVLB  7
02E84:  MOVWF  xB9
02E86:  MOVLB  0
02E88:  CALL   0662
....................                restart_wdt();
02E8C:  CLRWDT
.................... 
....................                putc(TxD_Buff[0]) ;               //Address
02E8E:  MOVF   x7D,W
02E90:  CALL   1DD2
....................                putc(TxD_Buff[1]) ;               //Function Code
02E94:  MOVF   x7E,W
02E96:  CALL   1DD2
....................                putc(TxD_Buff[2]) ;               //Byte Count
02E9A:  MOVF   x7F,W
02E9C:  CALL   1DD2
....................                putc(TxD_Buff[3]) ;
02EA0:  MOVF   x80,W
02EA2:  CALL   1DD2
....................                putc(TxD_Buff[4]) ;
02EA6:  MOVF   x81,W
02EA8:  CALL   1DD2
....................                putc(TxD_Buff[5]) ;
02EAC:  MOVF   x82,W
02EAE:  CALL   1DD2
....................                putc(TxD_Buff[6]) ;
02EB2:  MOVF   x83,W
02EB4:  CALL   1DD2
....................                putc(TxD_Buff[7]) ;
02EB8:  MOVF   x84,W
02EBA:  CALL   1DD2
....................                //putc(TxD_Buff[8]) ;
....................                //putc(TxD_Buff[9]) ;
.................... 
....................                restart_wdt();
02EBE:  CLRWDT
....................                delay_ms(3);
02EC0:  MOVLW  03
02EC2:  MOVLB  7
02EC4:  MOVWF  xB9
02EC6:  MOVLB  0
02EC8:  CALL   0662
....................                restart_wdt();
02ECC:  CLRWDT
....................                output_bit(P485ctrl,0);
02ECE:  BCF    F8A.3
02ED0:  BCF    F93.3
02ED2:  MOVLB  3
.................... 
.................... 
....................                //save_addr();
....................             }
....................          }
02ED4:  GOTO   40CA
02ED8:  MOVLB  1
....................          //--------------------------------------------------//
.................... 
....................          else if(RxD_Buff[1] == 0x21)///////////// WRITE SETTING /////////////////////
02EDA:  MOVF   x7D,W
02EDC:  SUBLW  21
02EDE:  BTFSS  FD8.2
02EE0:  GOTO   3848
....................          {
.................... 
....................             write_eeprom(0x00,0x0F);
02EE4:  MOVF   FF2,W
02EE6:  MOVWF  00
02EE8:  BCF    FF2.7
02EEA:  CLRF   FAA
02EEC:  CLRF   FA9
02EEE:  MOVLW  0F
02EF0:  MOVWF  FA8
02EF2:  BCF    FA6.6
02EF4:  BCF    FA6.7
02EF6:  BSF    FA6.2
02EF8:  MOVLB  F
02EFA:  MOVLW  55
02EFC:  MOVWF  FA7
02EFE:  MOVLW  AA
02F00:  MOVWF  FA7
02F02:  BSF    FA6.1
02F04:  BTFSC  FA6.1
02F06:  BRA    2F04
02F08:  BCF    FA6.2
02F0A:  MOVF   00,W
02F0C:  IORWF  FF2,F
.................... 
....................             write_eeprom(0x01,RxD_Buff[3]);   //Inputt Type
02F0E:  MOVFF  FF2,00
02F12:  BCF    FF2.7
02F14:  CLRF   FAA
02F16:  MOVLW  01
02F18:  MOVWF  FA9
02F1A:  MOVFF  17F,FA8
02F1E:  BCF    FA6.6
02F20:  BCF    FA6.7
02F22:  BSF    FA6.2
02F24:  MOVLW  55
02F26:  MOVWF  FA7
02F28:  MOVLW  AA
02F2A:  MOVWF  FA7
02F2C:  BSF    FA6.1
02F2E:  BTFSC  FA6.1
02F30:  BRA    2F2E
02F32:  BCF    FA6.2
02F34:  MOVF   00,W
02F36:  IORWF  FF2,F
....................             write_eeprom(0x02,RxD_Buff[4]);
02F38:  MOVFF  FF2,00
02F3C:  BCF    FF2.7
02F3E:  CLRF   FAA
02F40:  MOVLW  02
02F42:  MOVWF  FA9
02F44:  MOVFF  180,FA8
02F48:  BCF    FA6.6
02F4A:  BCF    FA6.7
02F4C:  BSF    FA6.2
02F4E:  MOVLW  55
02F50:  MOVWF  FA7
02F52:  MOVLW  AA
02F54:  MOVWF  FA7
02F56:  BSF    FA6.1
02F58:  BTFSC  FA6.1
02F5A:  BRA    2F58
02F5C:  BCF    FA6.2
02F5E:  MOVF   00,W
02F60:  IORWF  FF2,F
....................             write_eeprom(0x03,RxD_Buff[5]);
02F62:  MOVFF  FF2,00
02F66:  BCF    FF2.7
02F68:  CLRF   FAA
02F6A:  MOVLW  03
02F6C:  MOVWF  FA9
02F6E:  MOVFF  181,FA8
02F72:  BCF    FA6.6
02F74:  BCF    FA6.7
02F76:  BSF    FA6.2
02F78:  MOVLW  55
02F7A:  MOVWF  FA7
02F7C:  MOVLW  AA
02F7E:  MOVWF  FA7
02F80:  BSF    FA6.1
02F82:  BTFSC  FA6.1
02F84:  BRA    2F82
02F86:  BCF    FA6.2
02F88:  MOVF   00,W
02F8A:  IORWF  FF2,F
.................... 
....................             write_eeprom(0x04,RxD_Buff[6]);   //Fault Type
02F8C:  MOVFF  FF2,00
02F90:  BCF    FF2.7
02F92:  CLRF   FAA
02F94:  MOVLW  04
02F96:  MOVWF  FA9
02F98:  MOVFF  182,FA8
02F9C:  BCF    FA6.6
02F9E:  BCF    FA6.7
02FA0:  BSF    FA6.2
02FA2:  MOVLW  55
02FA4:  MOVWF  FA7
02FA6:  MOVLW  AA
02FA8:  MOVWF  FA7
02FAA:  BSF    FA6.1
02FAC:  BTFSC  FA6.1
02FAE:  BRA    2FAC
02FB0:  BCF    FA6.2
02FB2:  MOVF   00,W
02FB4:  IORWF  FF2,F
....................             write_eeprom(0x05,RxD_Buff[7]);
02FB6:  MOVFF  FF2,00
02FBA:  BCF    FF2.7
02FBC:  CLRF   FAA
02FBE:  MOVLW  05
02FC0:  MOVWF  FA9
02FC2:  MOVFF  183,FA8
02FC6:  BCF    FA6.6
02FC8:  BCF    FA6.7
02FCA:  BSF    FA6.2
02FCC:  MOVLW  55
02FCE:  MOVWF  FA7
02FD0:  MOVLW  AA
02FD2:  MOVWF  FA7
02FD4:  BSF    FA6.1
02FD6:  BTFSC  FA6.1
02FD8:  BRA    2FD6
02FDA:  BCF    FA6.2
02FDC:  MOVF   00,W
02FDE:  IORWF  FF2,F
....................             write_eeprom(0x06,RxD_Buff[8]);
02FE0:  MOVFF  FF2,00
02FE4:  BCF    FF2.7
02FE6:  CLRF   FAA
02FE8:  MOVLW  06
02FEA:  MOVWF  FA9
02FEC:  MOVFF  184,FA8
02FF0:  BCF    FA6.6
02FF2:  BCF    FA6.7
02FF4:  BSF    FA6.2
02FF6:  MOVLW  55
02FF8:  MOVWF  FA7
02FFA:  MOVLW  AA
02FFC:  MOVWF  FA7
02FFE:  BSF    FA6.1
03000:  BTFSC  FA6.1
03002:  BRA    3000
03004:  BCF    FA6.2
03006:  MOVF   00,W
03008:  IORWF  FF2,F
.................... 
....................             write_eeprom(0x07,RxD_Buff[9]);   //Output Type
0300A:  MOVFF  FF2,00
0300E:  BCF    FF2.7
03010:  CLRF   FAA
03012:  MOVLW  07
03014:  MOVWF  FA9
03016:  MOVFF  185,FA8
0301A:  BCF    FA6.6
0301C:  BCF    FA6.7
0301E:  BSF    FA6.2
03020:  MOVLW  55
03022:  MOVWF  FA7
03024:  MOVLW  AA
03026:  MOVWF  FA7
03028:  BSF    FA6.1
0302A:  BTFSC  FA6.1
0302C:  BRA    302A
0302E:  BCF    FA6.2
03030:  MOVF   00,W
03032:  IORWF  FF2,F
....................             write_eeprom(0x08,RxD_Buff[10]);
03034:  MOVFF  FF2,00
03038:  BCF    FF2.7
0303A:  CLRF   FAA
0303C:  MOVLW  08
0303E:  MOVWF  FA9
03040:  MOVFF  186,FA8
03044:  BCF    FA6.6
03046:  BCF    FA6.7
03048:  BSF    FA6.2
0304A:  MOVLW  55
0304C:  MOVWF  FA7
0304E:  MOVLW  AA
03050:  MOVWF  FA7
03052:  BSF    FA6.1
03054:  BTFSC  FA6.1
03056:  BRA    3054
03058:  BCF    FA6.2
0305A:  MOVF   00,W
0305C:  IORWF  FF2,F
....................             write_eeprom(0x09,RxD_Buff[11]);
0305E:  MOVFF  FF2,00
03062:  BCF    FF2.7
03064:  CLRF   FAA
03066:  MOVLW  09
03068:  MOVWF  FA9
0306A:  MOVFF  187,FA8
0306E:  BCF    FA6.6
03070:  BCF    FA6.7
03072:  BSF    FA6.2
03074:  MOVLW  55
03076:  MOVWF  FA7
03078:  MOVLW  AA
0307A:  MOVWF  FA7
0307C:  BSF    FA6.1
0307E:  BTFSC  FA6.1
03080:  BRA    307E
03082:  BCF    FA6.2
03084:  MOVF   00,W
03086:  IORWF  FF2,F
.................... 
....................             write_eeprom(0x0A,RxD_Buff[12]);   //Output Both
03088:  MOVFF  FF2,00
0308C:  BCF    FF2.7
0308E:  CLRF   FAA
03090:  MOVLW  0A
03092:  MOVWF  FA9
03094:  MOVFF  188,FA8
03098:  BCF    FA6.6
0309A:  BCF    FA6.7
0309C:  BSF    FA6.2
0309E:  MOVLW  55
030A0:  MOVWF  FA7
030A2:  MOVLW  AA
030A4:  MOVWF  FA7
030A6:  BSF    FA6.1
030A8:  BTFSC  FA6.1
030AA:  BRA    30A8
030AC:  BCF    FA6.2
030AE:  MOVF   00,W
030B0:  IORWF  FF2,F
....................             write_eeprom(0x0B,RxD_Buff[13]);
030B2:  MOVFF  FF2,00
030B6:  BCF    FF2.7
030B8:  CLRF   FAA
030BA:  MOVLW  0B
030BC:  MOVWF  FA9
030BE:  MOVFF  189,FA8
030C2:  BCF    FA6.6
030C4:  BCF    FA6.7
030C6:  BSF    FA6.2
030C8:  MOVLW  55
030CA:  MOVWF  FA7
030CC:  MOVLW  AA
030CE:  MOVWF  FA7
030D0:  BSF    FA6.1
030D2:  BTFSC  FA6.1
030D4:  BRA    30D2
030D6:  BCF    FA6.2
030D8:  MOVF   00,W
030DA:  IORWF  FF2,F
....................             write_eeprom(0x0C,RxD_Buff[14]);
030DC:  MOVFF  FF2,00
030E0:  BCF    FF2.7
030E2:  CLRF   FAA
030E4:  MOVLW  0C
030E6:  MOVWF  FA9
030E8:  MOVFF  18A,FA8
030EC:  BCF    FA6.6
030EE:  BCF    FA6.7
030F0:  BSF    FA6.2
030F2:  MOVLW  55
030F4:  MOVWF  FA7
030F6:  MOVLW  AA
030F8:  MOVWF  FA7
030FA:  BSF    FA6.1
030FC:  BTFSC  FA6.1
030FE:  BRA    30FC
03100:  BCF    FA6.2
03102:  MOVF   00,W
03104:  IORWF  FF2,F
.................... 
....................             write_eeprom(0x0D,RxD_Buff[15]);   //Alarm / Indicator
03106:  MOVFF  FF2,00
0310A:  BCF    FF2.7
0310C:  CLRF   FAA
0310E:  MOVLW  0D
03110:  MOVWF  FA9
03112:  MOVFF  18B,FA8
03116:  BCF    FA6.6
03118:  BCF    FA6.7
0311A:  BSF    FA6.2
0311C:  MOVLW  55
0311E:  MOVWF  FA7
03120:  MOVLW  AA
03122:  MOVWF  FA7
03124:  BSF    FA6.1
03126:  BTFSC  FA6.1
03128:  BRA    3126
0312A:  BCF    FA6.2
0312C:  MOVF   00,W
0312E:  IORWF  FF2,F
....................             write_eeprom(0x0E,RxD_Buff[16]);
03130:  MOVFF  FF2,00
03134:  BCF    FF2.7
03136:  CLRF   FAA
03138:  MOVLW  0E
0313A:  MOVWF  FA9
0313C:  MOVFF  18C,FA8
03140:  BCF    FA6.6
03142:  BCF    FA6.7
03144:  BSF    FA6.2
03146:  MOVLW  55
03148:  MOVWF  FA7
0314A:  MOVLW  AA
0314C:  MOVWF  FA7
0314E:  BSF    FA6.1
03150:  BTFSC  FA6.1
03152:  BRA    3150
03154:  BCF    FA6.2
03156:  MOVF   00,W
03158:  IORWF  FF2,F
....................             write_eeprom(0x0F,RxD_Buff[17]);
0315A:  MOVFF  FF2,00
0315E:  BCF    FF2.7
03160:  CLRF   FAA
03162:  MOVLW  0F
03164:  MOVWF  FA9
03166:  MOVFF  18D,FA8
0316A:  BCF    FA6.6
0316C:  BCF    FA6.7
0316E:  BSF    FA6.2
03170:  MOVLW  55
03172:  MOVWF  FA7
03174:  MOVLW  AA
03176:  MOVWF  FA7
03178:  BSF    FA6.1
0317A:  BTFSC  FA6.1
0317C:  BRA    317A
0317E:  BCF    FA6.2
03180:  MOVF   00,W
03182:  IORWF  FF2,F
....................          
....................             // LED Colour Config
....................             write_eeprom(0x10,RxD_Buff[18]); //Red1_8
03184:  MOVFF  FF2,00
03188:  BCF    FF2.7
0318A:  CLRF   FAA
0318C:  MOVLW  10
0318E:  MOVWF  FA9
03190:  MOVFF  18E,FA8
03194:  BCF    FA6.6
03196:  BCF    FA6.7
03198:  BSF    FA6.2
0319A:  MOVLW  55
0319C:  MOVWF  FA7
0319E:  MOVLW  AA
031A0:  MOVWF  FA7
031A2:  BSF    FA6.1
031A4:  BTFSC  FA6.1
031A6:  BRA    31A4
031A8:  BCF    FA6.2
031AA:  MOVF   00,W
031AC:  IORWF  FF2,F
....................             write_eeprom(0x11,RxD_Buff[19]); //Red9_10
031AE:  MOVFF  FF2,00
031B2:  BCF    FF2.7
031B4:  CLRF   FAA
031B6:  MOVLW  11
031B8:  MOVWF  FA9
031BA:  MOVFF  18F,FA8
031BE:  BCF    FA6.6
031C0:  BCF    FA6.7
031C2:  BSF    FA6.2
031C4:  MOVLW  55
031C6:  MOVWF  FA7
031C8:  MOVLW  AA
031CA:  MOVWF  FA7
031CC:  BSF    FA6.1
031CE:  BTFSC  FA6.1
031D0:  BRA    31CE
031D2:  BCF    FA6.2
031D4:  MOVF   00,W
031D6:  IORWF  FF2,F
....................             write_eeprom(0x12,RxD_Buff[20]); //Red11_18
031D8:  MOVFF  FF2,00
031DC:  BCF    FF2.7
031DE:  CLRF   FAA
031E0:  MOVLW  12
031E2:  MOVWF  FA9
031E4:  MOVFF  190,FA8
031E8:  BCF    FA6.6
031EA:  BCF    FA6.7
031EC:  BSF    FA6.2
031EE:  MOVLW  55
031F0:  MOVWF  FA7
031F2:  MOVLW  AA
031F4:  MOVWF  FA7
031F6:  BSF    FA6.1
031F8:  BTFSC  FA6.1
031FA:  BRA    31F8
031FC:  BCF    FA6.2
031FE:  MOVF   00,W
03200:  IORWF  FF2,F
....................             write_eeprom(0x13,RxD_Buff[21]); //Red19_20
03202:  MOVFF  FF2,00
03206:  BCF    FF2.7
03208:  CLRF   FAA
0320A:  MOVLW  13
0320C:  MOVWF  FA9
0320E:  MOVFF  191,FA8
03212:  BCF    FA6.6
03214:  BCF    FA6.7
03216:  BSF    FA6.2
03218:  MOVLW  55
0321A:  MOVWF  FA7
0321C:  MOVLW  AA
0321E:  MOVWF  FA7
03220:  BSF    FA6.1
03222:  BTFSC  FA6.1
03224:  BRA    3222
03226:  BCF    FA6.2
03228:  MOVF   00,W
0322A:  IORWF  FF2,F
....................             write_eeprom(0x14,RxD_Buff[22]); //Green1_8
0322C:  MOVFF  FF2,00
03230:  BCF    FF2.7
03232:  CLRF   FAA
03234:  MOVLW  14
03236:  MOVWF  FA9
03238:  MOVFF  192,FA8
0323C:  BCF    FA6.6
0323E:  BCF    FA6.7
03240:  BSF    FA6.2
03242:  MOVLW  55
03244:  MOVWF  FA7
03246:  MOVLW  AA
03248:  MOVWF  FA7
0324A:  BSF    FA6.1
0324C:  BTFSC  FA6.1
0324E:  BRA    324C
03250:  BCF    FA6.2
03252:  MOVF   00,W
03254:  IORWF  FF2,F
....................             write_eeprom(0x15,RxD_Buff[23]); //Green9_10
03256:  MOVFF  FF2,00
0325A:  BCF    FF2.7
0325C:  CLRF   FAA
0325E:  MOVLW  15
03260:  MOVWF  FA9
03262:  MOVFF  193,FA8
03266:  BCF    FA6.6
03268:  BCF    FA6.7
0326A:  BSF    FA6.2
0326C:  MOVLW  55
0326E:  MOVWF  FA7
03270:  MOVLW  AA
03272:  MOVWF  FA7
03274:  BSF    FA6.1
03276:  BTFSC  FA6.1
03278:  BRA    3276
0327A:  BCF    FA6.2
0327C:  MOVF   00,W
0327E:  IORWF  FF2,F
....................             write_eeprom(0x16,RxD_Buff[24]); //Green11_18
03280:  MOVFF  FF2,00
03284:  BCF    FF2.7
03286:  CLRF   FAA
03288:  MOVLW  16
0328A:  MOVWF  FA9
0328C:  MOVFF  194,FA8
03290:  BCF    FA6.6
03292:  BCF    FA6.7
03294:  BSF    FA6.2
03296:  MOVLW  55
03298:  MOVWF  FA7
0329A:  MOVLW  AA
0329C:  MOVWF  FA7
0329E:  BSF    FA6.1
032A0:  BTFSC  FA6.1
032A2:  BRA    32A0
032A4:  BCF    FA6.2
032A6:  MOVF   00,W
032A8:  IORWF  FF2,F
....................             write_eeprom(0x17,RxD_Buff[25]); //Green19_20
032AA:  MOVFF  FF2,00
032AE:  BCF    FF2.7
032B0:  CLRF   FAA
032B2:  MOVLW  17
032B4:  MOVWF  FA9
032B6:  MOVFF  195,FA8
032BA:  BCF    FA6.6
032BC:  BCF    FA6.7
032BE:  BSF    FA6.2
032C0:  MOVLW  55
032C2:  MOVWF  FA7
032C4:  MOVLW  AA
032C6:  MOVWF  FA7
032C8:  BSF    FA6.1
032CA:  BTFSC  FA6.1
032CC:  BRA    32CA
032CE:  BCF    FA6.2
032D0:  MOVF   00,W
032D2:  IORWF  FF2,F
....................                
....................             write_eeprom(0x18,RxD_Buff[26]);   //Auto acknowledge
032D4:  MOVFF  FF2,00
032D8:  BCF    FF2.7
032DA:  CLRF   FAA
032DC:  MOVLW  18
032DE:  MOVWF  FA9
032E0:  MOVFF  196,FA8
032E4:  BCF    FA6.6
032E6:  BCF    FA6.7
032E8:  BSF    FA6.2
032EA:  MOVLW  55
032EC:  MOVWF  FA7
032EE:  MOVLW  AA
032F0:  MOVWF  FA7
032F2:  BSF    FA6.1
032F4:  BTFSC  FA6.1
032F6:  BRA    32F4
032F8:  BCF    FA6.2
032FA:  MOVF   00,W
032FC:  IORWF  FF2,F
....................             write_eeprom(0x19,RxD_Buff[27]);   //Auto acknowledge Time
032FE:  MOVFF  FF2,00
03302:  BCF    FF2.7
03304:  CLRF   FAA
03306:  MOVLW  19
03308:  MOVWF  FA9
0330A:  MOVFF  197,FA8
0330E:  BCF    FA6.6
03310:  BCF    FA6.7
03312:  BSF    FA6.2
03314:  MOVLW  55
03316:  MOVWF  FA7
03318:  MOVLW  AA
0331A:  MOVWF  FA7
0331C:  BSF    FA6.1
0331E:  BTFSC  FA6.1
03320:  BRA    331E
03322:  BCF    FA6.2
03324:  MOVF   00,W
03326:  IORWF  FF2,F
....................             write_eeprom(0x1A,RxD_Buff[28]);   //Flashing Rate
03328:  MOVFF  FF2,00
0332C:  BCF    FF2.7
0332E:  CLRF   FAA
03330:  MOVLW  1A
03332:  MOVWF  FA9
03334:  MOVFF  198,FA8
03338:  BCF    FA6.6
0333A:  BCF    FA6.7
0333C:  BSF    FA6.2
0333E:  MOVLW  55
03340:  MOVWF  FA7
03342:  MOVLW  AA
03344:  MOVWF  FA7
03346:  BSF    FA6.1
03348:  BTFSC  FA6.1
0334A:  BRA    3348
0334C:  BCF    FA6.2
0334E:  MOVF   00,W
03350:  IORWF  FF2,F
....................             write_eeprom(0x1B,RxD_Buff[29]);   //No of point
03352:  MOVFF  FF2,00
03356:  BCF    FF2.7
03358:  CLRF   FAA
0335A:  MOVLW  1B
0335C:  MOVWF  FA9
0335E:  MOVFF  199,FA8
03362:  BCF    FA6.6
03364:  BCF    FA6.7
03366:  BSF    FA6.2
03368:  MOVLW  55
0336A:  MOVWF  FA7
0336C:  MOVLW  AA
0336E:  MOVWF  FA7
03370:  BSF    FA6.1
03372:  BTFSC  FA6.1
03374:  BRA    3372
03376:  BCF    FA6.2
03378:  MOVF   00,W
0337A:  IORWF  FF2,F
....................             write_eeprom(0x1C,RxD_Buff[30]);   //All Fault Delay Time
0337C:  MOVFF  FF2,00
03380:  BCF    FF2.7
03382:  CLRF   FAA
03384:  MOVLW  1C
03386:  MOVWF  FA9
03388:  MOVFF  19A,FA8
0338C:  BCF    FA6.6
0338E:  BCF    FA6.7
03390:  BSF    FA6.2
03392:  MOVLW  55
03394:  MOVWF  FA7
03396:  MOVLW  AA
03398:  MOVWF  FA7
0339A:  BSF    FA6.1
0339C:  BTFSC  FA6.1
0339E:  BRA    339C
033A0:  BCF    FA6.2
033A2:  MOVF   00,W
033A4:  IORWF  FF2,F
....................             write_eeprom(0x1D,RxD_Buff[31]);   //Communication Address
033A6:  MOVFF  FF2,00
033AA:  BCF    FF2.7
033AC:  CLRF   FAA
033AE:  MOVLW  1D
033B0:  MOVWF  FA9
033B2:  MOVFF  19B,FA8
033B6:  BCF    FA6.6
033B8:  BCF    FA6.7
033BA:  BSF    FA6.2
033BC:  MOVLW  55
033BE:  MOVWF  FA7
033C0:  MOVLW  AA
033C2:  MOVWF  FA7
033C4:  BSF    FA6.1
033C6:  BTFSC  FA6.1
033C8:  BRA    33C6
033CA:  BCF    FA6.2
033CC:  MOVF   00,W
033CE:  IORWF  FF2,F
.................... 
....................             write_eeprom(0x1E,RxD_Buff[32]);   //Fault Delay Time1
033D0:  MOVFF  FF2,00
033D4:  BCF    FF2.7
033D6:  CLRF   FAA
033D8:  MOVLW  1E
033DA:  MOVWF  FA9
033DC:  MOVFF  19C,FA8
033E0:  BCF    FA6.6
033E2:  BCF    FA6.7
033E4:  BSF    FA6.2
033E6:  MOVLW  55
033E8:  MOVWF  FA7
033EA:  MOVLW  AA
033EC:  MOVWF  FA7
033EE:  BSF    FA6.1
033F0:  BTFSC  FA6.1
033F2:  BRA    33F0
033F4:  BCF    FA6.2
033F6:  MOVF   00,W
033F8:  IORWF  FF2,F
....................             write_eeprom(0x1F,RxD_Buff[33]);   //Fault Delay Time2
033FA:  MOVFF  FF2,00
033FE:  BCF    FF2.7
03400:  CLRF   FAA
03402:  MOVLW  1F
03404:  MOVWF  FA9
03406:  MOVFF  19D,FA8
0340A:  BCF    FA6.6
0340C:  BCF    FA6.7
0340E:  BSF    FA6.2
03410:  MOVLW  55
03412:  MOVWF  FA7
03414:  MOVLW  AA
03416:  MOVWF  FA7
03418:  BSF    FA6.1
0341A:  BTFSC  FA6.1
0341C:  BRA    341A
0341E:  BCF    FA6.2
03420:  MOVF   00,W
03422:  IORWF  FF2,F
....................             write_eeprom(0x20,RxD_Buff[34]);   //Fault Delay Time3
03424:  MOVFF  FF2,00
03428:  BCF    FF2.7
0342A:  CLRF   FAA
0342C:  MOVLW  20
0342E:  MOVWF  FA9
03430:  MOVFF  19E,FA8
03434:  BCF    FA6.6
03436:  BCF    FA6.7
03438:  BSF    FA6.2
0343A:  MOVLW  55
0343C:  MOVWF  FA7
0343E:  MOVLW  AA
03440:  MOVWF  FA7
03442:  BSF    FA6.1
03444:  BTFSC  FA6.1
03446:  BRA    3444
03448:  BCF    FA6.2
0344A:  MOVF   00,W
0344C:  IORWF  FF2,F
....................             write_eeprom(0x21,RxD_Buff[35]);   //Fault Delay Time4
0344E:  MOVFF  FF2,00
03452:  BCF    FF2.7
03454:  CLRF   FAA
03456:  MOVLW  21
03458:  MOVWF  FA9
0345A:  MOVFF  19F,FA8
0345E:  BCF    FA6.6
03460:  BCF    FA6.7
03462:  BSF    FA6.2
03464:  MOVLW  55
03466:  MOVWF  FA7
03468:  MOVLW  AA
0346A:  MOVWF  FA7
0346C:  BSF    FA6.1
0346E:  BTFSC  FA6.1
03470:  BRA    346E
03472:  BCF    FA6.2
03474:  MOVF   00,W
03476:  IORWF  FF2,F
....................             write_eeprom(0x22,RxD_Buff[36]);   //Fault Delay Time5
03478:  MOVFF  FF2,00
0347C:  BCF    FF2.7
0347E:  CLRF   FAA
03480:  MOVLW  22
03482:  MOVWF  FA9
03484:  MOVFF  1A0,FA8
03488:  BCF    FA6.6
0348A:  BCF    FA6.7
0348C:  BSF    FA6.2
0348E:  MOVLW  55
03490:  MOVWF  FA7
03492:  MOVLW  AA
03494:  MOVWF  FA7
03496:  BSF    FA6.1
03498:  BTFSC  FA6.1
0349A:  BRA    3498
0349C:  BCF    FA6.2
0349E:  MOVF   00,W
034A0:  IORWF  FF2,F
....................             write_eeprom(0x23,RxD_Buff[37]);   //Fault Delay Time6
034A2:  MOVFF  FF2,00
034A6:  BCF    FF2.7
034A8:  CLRF   FAA
034AA:  MOVLW  23
034AC:  MOVWF  FA9
034AE:  MOVFF  1A1,FA8
034B2:  BCF    FA6.6
034B4:  BCF    FA6.7
034B6:  BSF    FA6.2
034B8:  MOVLW  55
034BA:  MOVWF  FA7
034BC:  MOVLW  AA
034BE:  MOVWF  FA7
034C0:  BSF    FA6.1
034C2:  BTFSC  FA6.1
034C4:  BRA    34C2
034C6:  BCF    FA6.2
034C8:  MOVF   00,W
034CA:  IORWF  FF2,F
....................             write_eeprom(0x24,RxD_Buff[38]);   //Fault Delay Time7
034CC:  MOVFF  FF2,00
034D0:  BCF    FF2.7
034D2:  CLRF   FAA
034D4:  MOVLW  24
034D6:  MOVWF  FA9
034D8:  MOVFF  1A2,FA8
034DC:  BCF    FA6.6
034DE:  BCF    FA6.7
034E0:  BSF    FA6.2
034E2:  MOVLW  55
034E4:  MOVWF  FA7
034E6:  MOVLW  AA
034E8:  MOVWF  FA7
034EA:  BSF    FA6.1
034EC:  BTFSC  FA6.1
034EE:  BRA    34EC
034F0:  BCF    FA6.2
034F2:  MOVF   00,W
034F4:  IORWF  FF2,F
....................             write_eeprom(0x25,RxD_Buff[39]);   //Fault Delay Time8
034F6:  MOVFF  FF2,00
034FA:  BCF    FF2.7
034FC:  CLRF   FAA
034FE:  MOVLW  25
03500:  MOVWF  FA9
03502:  MOVFF  1A3,FA8
03506:  BCF    FA6.6
03508:  BCF    FA6.7
0350A:  BSF    FA6.2
0350C:  MOVLW  55
0350E:  MOVWF  FA7
03510:  MOVLW  AA
03512:  MOVWF  FA7
03514:  BSF    FA6.1
03516:  BTFSC  FA6.1
03518:  BRA    3516
0351A:  BCF    FA6.2
0351C:  MOVF   00,W
0351E:  IORWF  FF2,F
....................             write_eeprom(0x26,RxD_Buff[40]);   //Fault Delay Time9
03520:  MOVFF  FF2,00
03524:  BCF    FF2.7
03526:  CLRF   FAA
03528:  MOVLW  26
0352A:  MOVWF  FA9
0352C:  MOVFF  1A4,FA8
03530:  BCF    FA6.6
03532:  BCF    FA6.7
03534:  BSF    FA6.2
03536:  MOVLW  55
03538:  MOVWF  FA7
0353A:  MOVLW  AA
0353C:  MOVWF  FA7
0353E:  BSF    FA6.1
03540:  BTFSC  FA6.1
03542:  BRA    3540
03544:  BCF    FA6.2
03546:  MOVF   00,W
03548:  IORWF  FF2,F
....................             write_eeprom(0x27,RxD_Buff[41]);   //Fault Delay Time10
0354A:  MOVFF  FF2,00
0354E:  BCF    FF2.7
03550:  CLRF   FAA
03552:  MOVLW  27
03554:  MOVWF  FA9
03556:  MOVFF  1A5,FA8
0355A:  BCF    FA6.6
0355C:  BCF    FA6.7
0355E:  BSF    FA6.2
03560:  MOVLW  55
03562:  MOVWF  FA7
03564:  MOVLW  AA
03566:  MOVWF  FA7
03568:  BSF    FA6.1
0356A:  BTFSC  FA6.1
0356C:  BRA    356A
0356E:  BCF    FA6.2
03570:  MOVF   00,W
03572:  IORWF  FF2,F
....................             write_eeprom(0x28,RxD_Buff[42]);   //Fault Delay Time11
03574:  MOVFF  FF2,00
03578:  BCF    FF2.7
0357A:  CLRF   FAA
0357C:  MOVLW  28
0357E:  MOVWF  FA9
03580:  MOVFF  1A6,FA8
03584:  BCF    FA6.6
03586:  BCF    FA6.7
03588:  BSF    FA6.2
0358A:  MOVLW  55
0358C:  MOVWF  FA7
0358E:  MOVLW  AA
03590:  MOVWF  FA7
03592:  BSF    FA6.1
03594:  BTFSC  FA6.1
03596:  BRA    3594
03598:  BCF    FA6.2
0359A:  MOVF   00,W
0359C:  IORWF  FF2,F
....................             write_eeprom(0x29,RxD_Buff[43]);   //Fault Delay Time12
0359E:  MOVFF  FF2,00
035A2:  BCF    FF2.7
035A4:  CLRF   FAA
035A6:  MOVLW  29
035A8:  MOVWF  FA9
035AA:  MOVFF  1A7,FA8
035AE:  BCF    FA6.6
035B0:  BCF    FA6.7
035B2:  BSF    FA6.2
035B4:  MOVLW  55
035B6:  MOVWF  FA7
035B8:  MOVLW  AA
035BA:  MOVWF  FA7
035BC:  BSF    FA6.1
035BE:  BTFSC  FA6.1
035C0:  BRA    35BE
035C2:  BCF    FA6.2
035C4:  MOVF   00,W
035C6:  IORWF  FF2,F
....................             write_eeprom(0x2A,RxD_Buff[44]);   //Fault Delay Time13
035C8:  MOVFF  FF2,00
035CC:  BCF    FF2.7
035CE:  CLRF   FAA
035D0:  MOVLW  2A
035D2:  MOVWF  FA9
035D4:  MOVFF  1A8,FA8
035D8:  BCF    FA6.6
035DA:  BCF    FA6.7
035DC:  BSF    FA6.2
035DE:  MOVLW  55
035E0:  MOVWF  FA7
035E2:  MOVLW  AA
035E4:  MOVWF  FA7
035E6:  BSF    FA6.1
035E8:  BTFSC  FA6.1
035EA:  BRA    35E8
035EC:  BCF    FA6.2
035EE:  MOVF   00,W
035F0:  IORWF  FF2,F
....................             write_eeprom(0x2B,RxD_Buff[45]);   //Fault Delay Time14
035F2:  MOVFF  FF2,00
035F6:  BCF    FF2.7
035F8:  CLRF   FAA
035FA:  MOVLW  2B
035FC:  MOVWF  FA9
035FE:  MOVFF  1A9,FA8
03602:  BCF    FA6.6
03604:  BCF    FA6.7
03606:  BSF    FA6.2
03608:  MOVLW  55
0360A:  MOVWF  FA7
0360C:  MOVLW  AA
0360E:  MOVWF  FA7
03610:  BSF    FA6.1
03612:  BTFSC  FA6.1
03614:  BRA    3612
03616:  BCF    FA6.2
03618:  MOVF   00,W
0361A:  IORWF  FF2,F
....................             write_eeprom(0x2C,RxD_Buff[46]);   //Fault Delay Time15
0361C:  MOVFF  FF2,00
03620:  BCF    FF2.7
03622:  CLRF   FAA
03624:  MOVLW  2C
03626:  MOVWF  FA9
03628:  MOVFF  1AA,FA8
0362C:  BCF    FA6.6
0362E:  BCF    FA6.7
03630:  BSF    FA6.2
03632:  MOVLW  55
03634:  MOVWF  FA7
03636:  MOVLW  AA
03638:  MOVWF  FA7
0363A:  BSF    FA6.1
0363C:  BTFSC  FA6.1
0363E:  BRA    363C
03640:  BCF    FA6.2
03642:  MOVF   00,W
03644:  IORWF  FF2,F
....................             write_eeprom(0x2D,RxD_Buff[47]);   //Fault Delay Time16
03646:  MOVFF  FF2,00
0364A:  BCF    FF2.7
0364C:  CLRF   FAA
0364E:  MOVLW  2D
03650:  MOVWF  FA9
03652:  MOVFF  1AB,FA8
03656:  BCF    FA6.6
03658:  BCF    FA6.7
0365A:  BSF    FA6.2
0365C:  MOVLW  55
0365E:  MOVWF  FA7
03660:  MOVLW  AA
03662:  MOVWF  FA7
03664:  BSF    FA6.1
03666:  BTFSC  FA6.1
03668:  BRA    3666
0366A:  BCF    FA6.2
0366C:  MOVF   00,W
0366E:  IORWF  FF2,F
....................             write_eeprom(0x2E,RxD_Buff[48]);   //Fault Delay Time17
03670:  MOVFF  FF2,00
03674:  BCF    FF2.7
03676:  CLRF   FAA
03678:  MOVLW  2E
0367A:  MOVWF  FA9
0367C:  MOVFF  1AC,FA8
03680:  BCF    FA6.6
03682:  BCF    FA6.7
03684:  BSF    FA6.2
03686:  MOVLW  55
03688:  MOVWF  FA7
0368A:  MOVLW  AA
0368C:  MOVWF  FA7
0368E:  BSF    FA6.1
03690:  BTFSC  FA6.1
03692:  BRA    3690
03694:  BCF    FA6.2
03696:  MOVF   00,W
03698:  IORWF  FF2,F
....................             write_eeprom(0x2F,RxD_Buff[49]);   //Fault Delay Time18
0369A:  MOVFF  FF2,00
0369E:  BCF    FF2.7
036A0:  CLRF   FAA
036A2:  MOVLW  2F
036A4:  MOVWF  FA9
036A6:  MOVFF  1AD,FA8
036AA:  BCF    FA6.6
036AC:  BCF    FA6.7
036AE:  BSF    FA6.2
036B0:  MOVLW  55
036B2:  MOVWF  FA7
036B4:  MOVLW  AA
036B6:  MOVWF  FA7
036B8:  BSF    FA6.1
036BA:  BTFSC  FA6.1
036BC:  BRA    36BA
036BE:  BCF    FA6.2
036C0:  MOVF   00,W
036C2:  IORWF  FF2,F
....................             write_eeprom(0x30,RxD_Buff[50]);   //Fault Delay Time19
036C4:  MOVFF  FF2,00
036C8:  BCF    FF2.7
036CA:  CLRF   FAA
036CC:  MOVLW  30
036CE:  MOVWF  FA9
036D0:  MOVFF  1AE,FA8
036D4:  BCF    FA6.6
036D6:  BCF    FA6.7
036D8:  BSF    FA6.2
036DA:  MOVLW  55
036DC:  MOVWF  FA7
036DE:  MOVLW  AA
036E0:  MOVWF  FA7
036E2:  BSF    FA6.1
036E4:  BTFSC  FA6.1
036E6:  BRA    36E4
036E8:  BCF    FA6.2
036EA:  MOVF   00,W
036EC:  IORWF  FF2,F
....................             write_eeprom(0x31,RxD_Buff[51]);   //Fault Delay Time20
036EE:  MOVFF  FF2,00
036F2:  BCF    FF2.7
036F4:  CLRF   FAA
036F6:  MOVLW  31
036F8:  MOVWF  FA9
036FA:  MOVFF  1AF,FA8
036FE:  BCF    FA6.6
03700:  BCF    FA6.7
03702:  BSF    FA6.2
03704:  MOVLW  55
03706:  MOVWF  FA7
03708:  MOVLW  AA
0370A:  MOVWF  FA7
0370C:  BSF    FA6.1
0370E:  BTFSC  FA6.1
03710:  BRA    370E
03712:  BCF    FA6.2
03714:  MOVF   00,W
03716:  IORWF  FF2,F
....................             
....................             int16  a = 0; 
....................             unsigned char  phonenum;
03718:  MOVLB  7
0371A:  CLRF   xB1
0371C:  CLRF   xB0
....................             for(; ; a++)
....................             {
....................                restart_wdt();
0371E:  CLRWDT
....................                phonenum = RxD_Buff[52 + a];
03720:  MOVLW  B0
03722:  ADDWF  xB0,W
03724:  MOVWF  FE9
03726:  MOVLW  01
03728:  ADDWFC xB1,W
0372A:  MOVWF  FEA
0372C:  MOVFF  FEF,7B2
....................                if((phonenum == 0x0D) || (a > 15))
03730:  MOVF   xB2,W
03732:  SUBLW  0D
03734:  BZ    3740
03736:  MOVF   xB1,F
03738:  BNZ   3740
0373A:  MOVF   xB0,W
0373C:  SUBLW  0F
0373E:  BC    378E
....................                {
....................                   sms_phonenumber[a] =  '\0' ;
03740:  MOVLW  8B
03742:  ADDWF  xB0,W
03744:  MOVWF  FE9
03746:  MOVLW  05
03748:  ADDWFC xB1,W
0374A:  MOVWF  FEA
0374C:  CLRF   FEF
....................                   write_eeprom(0x32+a,phonenum);
0374E:  MOVLW  32
03750:  ADDWF  xB0,W
03752:  MOVWF  xB9
03754:  MOVLW  00
03756:  ADDWFC xB1,W
03758:  MOVWF  xBA
0375A:  MOVF   FF2,W
0375C:  MOVWF  00
0375E:  BCF    FF2.7
03760:  MOVFF  7BA,FAA
03764:  MOVFF  7B9,FA9
03768:  MOVFF  7B2,FA8
0376C:  BCF    FA6.6
0376E:  BCF    FA6.7
03770:  BSF    FA6.2
03772:  MOVLB  F
03774:  MOVLW  55
03776:  MOVWF  FA7
03778:  MOVLW  AA
0377A:  MOVWF  FA7
0377C:  BSF    FA6.1
0377E:  BTFSC  FA6.1
03780:  BRA    377E
03782:  BCF    FA6.2
03784:  MOVF   00,W
03786:  IORWF  FF2,F
....................                   break;
03788:  BRA    37E4
....................                }
0378A:  BRA    37D8
0378C:  MOVLB  7
....................                else
....................                {
....................                   sms_phonenumber[a] = phonenum;
0378E:  MOVLW  8B
03790:  ADDWF  xB0,W
03792:  MOVWF  FE9
03794:  MOVLW  05
03796:  ADDWFC xB1,W
03798:  MOVWF  FEA
0379A:  MOVFF  7B2,FEF
....................                   
....................                   write_eeprom(0x32+a,phonenum);
0379E:  MOVLW  32
037A0:  ADDWF  xB0,W
037A2:  MOVWF  xB9
037A4:  MOVLW  00
037A6:  ADDWFC xB1,W
037A8:  MOVWF  xBA
037AA:  MOVF   FF2,W
037AC:  MOVWF  00
037AE:  BCF    FF2.7
037B0:  MOVFF  7BA,FAA
037B4:  MOVFF  7B9,FA9
037B8:  MOVFF  7B2,FA8
037BC:  BCF    FA6.6
037BE:  BCF    FA6.7
037C0:  BSF    FA6.2
037C2:  MOVLB  F
037C4:  MOVLW  55
037C6:  MOVWF  FA7
037C8:  MOVLW  AA
037CA:  MOVWF  FA7
037CC:  BSF    FA6.1
037CE:  BTFSC  FA6.1
037D0:  BRA    37CE
037D2:  BCF    FA6.2
037D4:  MOVF   00,W
037D6:  IORWF  FF2,F
....................                }
037D8:  MOVLB  7
037DA:  INCF   xB0,F
037DC:  BTFSC  FD8.2
037DE:  INCF   xB1,F
037E0:  BRA    371E
037E2:  MOVLB  F
....................             }
.................... 
....................                         
....................             TxD_Buff[0] = Address ;         //Address
037E4:  MOVFF  7B,7D
....................             TxD_Buff[1] = 0x21 ;            //return function code
037E8:  MOVLW  21
037EA:  MOVLB  0
037EC:  MOVWF  x7E
.................... 
....................             CRC(TxD_Buff,2)   ;            //Cal CRC 2 byte
037EE:  MOVLB  7
037F0:  CLRF   xBB
037F2:  MOVLW  7D
037F4:  MOVWF  xBA
037F6:  MOVLW  02
037F8:  MOVWF  xBC
037FA:  MOVLB  0
037FC:  CALL   1D7C
.................... 
....................             TxD_Buff[2] = CRC_Hi ;
03800:  MOVFF  37D,7F
....................             TxD_Buff[3] = CRC_Lo ;
03804:  MOVFF  37C,80
.................... 
....................             output_bit(P485ctrl,1);
03808:  BSF    F8A.3
0380A:  BCF    F93.3
....................             delay_ms(10);
0380C:  MOVLW  0A
0380E:  MOVLB  7
03810:  MOVWF  xB9
03812:  MOVLB  0
03814:  CALL   0662
.................... 
....................             putc(Txd_Buff[0]);
03818:  MOVF   x7D,W
0381A:  CALL   1DD2
....................             putc(Txd_Buff[1]);
0381E:  MOVF   x7E,W
03820:  CALL   1DD2
....................             putc(Txd_Buff[2]);
03824:  MOVF   x7F,W
03826:  CALL   1DD2
....................             putc(Txd_Buff[3]);
0382A:  MOVF   x80,W
0382C:  CALL   1DD2
.................... 
....................             delay_ms(3);
03830:  MOVLW  03
03832:  MOVLB  7
03834:  MOVWF  xB9
03836:  MOVLB  0
03838:  CALL   0662
....................             output_bit(P485ctrl,0);
0383C:  BCF    F8A.3
0383E:  BCF    F93.3
....................             
....................             reset_cpu();
03840:  RESET
....................             //Read_Config(); //jj
....................          }
03842:  GOTO   40C8
03846:  MOVLB  1
....................          
....................          else if(RxD_Buff[1] == 0x22)///////////// WRITE Faultname /////////////////////
03848:  MOVF   x7D,W
0384A:  SUBLW  22
0384C:  BTFSS  FD8.2
0384E:  GOTO   40C8
....................          {
....................             
....................             //SMS_Massage
....................             int16  i =4,j=0,k=0; //i =4 are first data from RxD_Buff[]
03852:  MOVLB  7
03854:  CLRF   xB4
03856:  MOVLW  04
03858:  MOVWF  xB3
0385A:  CLRF   xB6
0385C:  CLRF   xB5
0385E:  CLRF   xB8
03860:  CLRF   xB7
....................             for(; ; i++,j++)
....................             {
....................                restart_wdt();
03862:  CLRWDT
....................                if((RxD_Buff[i] == 0x0D) || (j > 30))
03864:  MOVLW  7C
03866:  ADDWF  xB3,W
03868:  MOVWF  FE9
0386A:  MOVLW  01
0386C:  ADDWFC xB4,W
0386E:  MOVWF  FEA
03870:  MOVF   FEF,W
03872:  SUBLW  0D
03874:  BZ    3880
03876:  MOVF   xB6,F
03878:  BNZ   3880
0387A:  MOVF   xB5,W
0387C:  SUBLW  1E
0387E:  BC    38C0
....................                {
....................                   write_eeprom(0x5D+i,0x0D);
03880:  MOVLW  5D
03882:  ADDWF  xB3,W
03884:  MOVWF  xB9
03886:  MOVLW  00
03888:  ADDWFC xB4,W
0388A:  MOVWF  xBA
0388C:  MOVF   FF2,W
0388E:  MOVWF  00
03890:  BCF    FF2.7
03892:  MOVFF  7BA,FAA
03896:  MOVFF  7B9,FA9
0389A:  MOVLW  0D
0389C:  MOVWF  FA8
0389E:  BCF    FA6.6
038A0:  BCF    FA6.7
038A2:  BSF    FA6.2
038A4:  MOVLB  F
038A6:  MOVLW  55
038A8:  MOVWF  FA7
038AA:  MOVLW  AA
038AC:  MOVWF  FA7
038AE:  BSF    FA6.1
038B0:  BTFSC  FA6.1
038B2:  BRA    38B0
038B4:  BCF    FA6.2
038B6:  MOVF   00,W
038B8:  IORWF  FF2,F
....................                   break;
038BA:  BRA    394A
....................                }
038BC:  BRA    3932
038BE:  MOVLB  7
....................                else
....................                {
....................                   SMS_Massage1[j] = RxD_Buff[i];
038C0:  MOVLW  9A
038C2:  ADDWF  xB5,W
038C4:  MOVWF  01
038C6:  MOVLW  05
038C8:  ADDWFC xB6,W
038CA:  MOVWF  03
038CC:  MOVLW  7C
038CE:  ADDWF  xB3,W
038D0:  MOVWF  FE9
038D2:  MOVLW  01
038D4:  ADDWFC xB4,W
038D6:  MOVWF  FEA
038D8:  MOVFF  FEF,7BB
038DC:  MOVFF  03,FEA
038E0:  MOVFF  01,FE9
038E4:  MOVFF  7BB,FEF
....................                   
....................                   write_eeprom(0x5D+i,RxD_Buff[i]);
038E8:  MOVLW  5D
038EA:  ADDWF  xB3,W
038EC:  MOVWF  xB9
038EE:  MOVLW  00
038F0:  ADDWFC xB4,W
038F2:  MOVWF  xBA
038F4:  MOVLW  7C
038F6:  ADDWF  xB3,W
038F8:  MOVWF  FE9
038FA:  MOVLW  01
038FC:  ADDWFC xB4,W
038FE:  MOVWF  FEA
03900:  MOVFF  FEF,7BB
03904:  MOVF   FF2,W
03906:  MOVWF  00
03908:  BCF    FF2.7
0390A:  MOVFF  7BA,FAA
0390E:  MOVFF  7B9,FA9
03912:  MOVFF  7BB,FA8
03916:  BCF    FA6.6
03918:  BCF    FA6.7
0391A:  BSF    FA6.2
0391C:  MOVLB  F
0391E:  MOVLW  55
03920:  MOVWF  FA7
03922:  MOVLW  AA
03924:  MOVWF  FA7
03926:  BSF    FA6.1
03928:  BTFSC  FA6.1
0392A:  BRA    3928
0392C:  BCF    FA6.2
0392E:  MOVF   00,W
03930:  IORWF  FF2,F
....................                }
03932:  MOVLB  7
03934:  MOVFF  7B4,03
03938:  MOVF   xB3,W
0393A:  INCF   xB3,F
0393C:  BTFSC  FD8.2
0393E:  INCF   xB4,F
03940:  INCF   xB5,F
03942:  BTFSC  FD8.2
03944:  INCF   xB6,F
03946:  BRA    3862
03948:  MOVLB  F
....................             }
....................             SMS_Massage1[j] = '\0' ; // end string
0394A:  MOVLW  9A
0394C:  MOVLB  7
0394E:  ADDWF  xB5,W
03950:  MOVWF  FE9
03952:  MOVLW  05
03954:  ADDWFC xB6,W
03956:  MOVWF  FEA
03958:  CLRF   FEF
....................             
....................             j=0;
0395A:  CLRF   xB6
0395C:  CLRF   xB5
....................             i++;
0395E:  INCF   xB3,F
03960:  BTFSC  FD8.2
03962:  INCF   xB4,F
....................             
....................             for(; ; i++,j++)
....................             {
....................                restart_wdt();
03964:  CLRWDT
....................                if((RxD_Buff[i] == 0x0D) || (j > 30))
03966:  MOVLW  7C
03968:  ADDWF  xB3,W
0396A:  MOVWF  FE9
0396C:  MOVLW  01
0396E:  ADDWFC xB4,W
03970:  MOVWF  FEA
03972:  MOVF   FEF,W
03974:  SUBLW  0D
03976:  BZ    3982
03978:  MOVF   xB6,F
0397A:  BNZ   3982
0397C:  MOVF   xB5,W
0397E:  SUBLW  1E
03980:  BC    39C2
....................                {  
....................                   write_eeprom(0x5D+i,0x0D);
03982:  MOVLW  5D
03984:  ADDWF  xB3,W
03986:  MOVWF  xB9
03988:  MOVLW  00
0398A:  ADDWFC xB4,W
0398C:  MOVWF  xBA
0398E:  MOVF   FF2,W
03990:  MOVWF  00
03992:  BCF    FF2.7
03994:  MOVFF  7BA,FAA
03998:  MOVFF  7B9,FA9
0399C:  MOVLW  0D
0399E:  MOVWF  FA8
039A0:  BCF    FA6.6
039A2:  BCF    FA6.7
039A4:  BSF    FA6.2
039A6:  MOVLB  F
039A8:  MOVLW  55
039AA:  MOVWF  FA7
039AC:  MOVLW  AA
039AE:  MOVWF  FA7
039B0:  BSF    FA6.1
039B2:  BTFSC  FA6.1
039B4:  BRA    39B2
039B6:  BCF    FA6.2
039B8:  MOVF   00,W
039BA:  IORWF  FF2,F
....................                   break;
039BC:  BRA    3A4C
....................                }
039BE:  BRA    3A34
039C0:  MOVLB  7
....................                else
....................                {
....................                   SMS_Massage2[j] = RxD_Buff[i];
039C2:  MOVLW  BA
039C4:  ADDWF  xB5,W
039C6:  MOVWF  01
039C8:  MOVLW  05
039CA:  ADDWFC xB6,W
039CC:  MOVWF  03
039CE:  MOVLW  7C
039D0:  ADDWF  xB3,W
039D2:  MOVWF  FE9
039D4:  MOVLW  01
039D6:  ADDWFC xB4,W
039D8:  MOVWF  FEA
039DA:  MOVFF  FEF,7BB
039DE:  MOVFF  03,FEA
039E2:  MOVFF  01,FE9
039E6:  MOVFF  7BB,FEF
....................                   write_eeprom(0x5D+i,RxD_Buff[i]);
039EA:  MOVLW  5D
039EC:  ADDWF  xB3,W
039EE:  MOVWF  xB9
039F0:  MOVLW  00
039F2:  ADDWFC xB4,W
039F4:  MOVWF  xBA
039F6:  MOVLW  7C
039F8:  ADDWF  xB3,W
039FA:  MOVWF  FE9
039FC:  MOVLW  01
039FE:  ADDWFC xB4,W
03A00:  MOVWF  FEA
03A02:  MOVFF  FEF,7BB
03A06:  MOVF   FF2,W
03A08:  MOVWF  00
03A0A:  BCF    FF2.7
03A0C:  MOVFF  7BA,FAA
03A10:  MOVFF  7B9,FA9
03A14:  MOVFF  7BB,FA8
03A18:  BCF    FA6.6
03A1A:  BCF    FA6.7
03A1C:  BSF    FA6.2
03A1E:  MOVLB  F
03A20:  MOVLW  55
03A22:  MOVWF  FA7
03A24:  MOVLW  AA
03A26:  MOVWF  FA7
03A28:  BSF    FA6.1
03A2A:  BTFSC  FA6.1
03A2C:  BRA    3A2A
03A2E:  BCF    FA6.2
03A30:  MOVF   00,W
03A32:  IORWF  FF2,F
....................                }
03A34:  MOVLB  7
03A36:  MOVFF  7B4,03
03A3A:  MOVF   xB3,W
03A3C:  INCF   xB3,F
03A3E:  BTFSC  FD8.2
03A40:  INCF   xB4,F
03A42:  INCF   xB5,F
03A44:  BTFSC  FD8.2
03A46:  INCF   xB6,F
03A48:  BRA    3964
03A4A:  MOVLB  F
....................             }
....................             SMS_Massage2[j] = '\0' ; // end string
03A4C:  MOVLW  BA
03A4E:  MOVLB  7
03A50:  ADDWF  xB5,W
03A52:  MOVWF  FE9
03A54:  MOVLW  05
03A56:  ADDWFC xB6,W
03A58:  MOVWF  FEA
03A5A:  CLRF   FEF
....................             
....................             j=0;
03A5C:  CLRF   xB6
03A5E:  CLRF   xB5
....................             i++;
03A60:  INCF   xB3,F
03A62:  BTFSC  FD8.2
03A64:  INCF   xB4,F
....................             
....................             for(; ; i++,j++)
....................             {
....................                restart_wdt();
03A66:  CLRWDT
....................                if((RxD_Buff[i] == 0x0D) || (j > 30))
03A68:  MOVLW  7C
03A6A:  ADDWF  xB3,W
03A6C:  MOVWF  FE9
03A6E:  MOVLW  01
03A70:  ADDWFC xB4,W
03A72:  MOVWF  FEA
03A74:  MOVF   FEF,W
03A76:  SUBLW  0D
03A78:  BZ    3A84
03A7A:  MOVF   xB6,F
03A7C:  BNZ   3A84
03A7E:  MOVF   xB5,W
03A80:  SUBLW  1E
03A82:  BC    3AC4
....................                {
....................                   write_eeprom(0x5D+i,0x0D);
03A84:  MOVLW  5D
03A86:  ADDWF  xB3,W
03A88:  MOVWF  xB9
03A8A:  MOVLW  00
03A8C:  ADDWFC xB4,W
03A8E:  MOVWF  xBA
03A90:  MOVF   FF2,W
03A92:  MOVWF  00
03A94:  BCF    FF2.7
03A96:  MOVFF  7BA,FAA
03A9A:  MOVFF  7B9,FA9
03A9E:  MOVLW  0D
03AA0:  MOVWF  FA8
03AA2:  BCF    FA6.6
03AA4:  BCF    FA6.7
03AA6:  BSF    FA6.2
03AA8:  MOVLB  F
03AAA:  MOVLW  55
03AAC:  MOVWF  FA7
03AAE:  MOVLW  AA
03AB0:  MOVWF  FA7
03AB2:  BSF    FA6.1
03AB4:  BTFSC  FA6.1
03AB6:  BRA    3AB4
03AB8:  BCF    FA6.2
03ABA:  MOVF   00,W
03ABC:  IORWF  FF2,F
....................                   break;
03ABE:  BRA    3B4E
....................                }
03AC0:  BRA    3B36
03AC2:  MOVLB  7
....................                else
....................                {
....................                   SMS_Massage3[j] = RxD_Buff[i];
03AC4:  MOVLW  DA
03AC6:  ADDWF  xB5,W
03AC8:  MOVWF  01
03ACA:  MOVLW  05
03ACC:  ADDWFC xB6,W
03ACE:  MOVWF  03
03AD0:  MOVLW  7C
03AD2:  ADDWF  xB3,W
03AD4:  MOVWF  FE9
03AD6:  MOVLW  01
03AD8:  ADDWFC xB4,W
03ADA:  MOVWF  FEA
03ADC:  MOVFF  FEF,7BB
03AE0:  MOVFF  03,FEA
03AE4:  MOVFF  01,FE9
03AE8:  MOVFF  7BB,FEF
....................                   write_eeprom(0x5D+i,RxD_Buff[i]);
03AEC:  MOVLW  5D
03AEE:  ADDWF  xB3,W
03AF0:  MOVWF  xB9
03AF2:  MOVLW  00
03AF4:  ADDWFC xB4,W
03AF6:  MOVWF  xBA
03AF8:  MOVLW  7C
03AFA:  ADDWF  xB3,W
03AFC:  MOVWF  FE9
03AFE:  MOVLW  01
03B00:  ADDWFC xB4,W
03B02:  MOVWF  FEA
03B04:  MOVFF  FEF,7BB
03B08:  MOVF   FF2,W
03B0A:  MOVWF  00
03B0C:  BCF    FF2.7
03B0E:  MOVFF  7BA,FAA
03B12:  MOVFF  7B9,FA9
03B16:  MOVFF  7BB,FA8
03B1A:  BCF    FA6.6
03B1C:  BCF    FA6.7
03B1E:  BSF    FA6.2
03B20:  MOVLB  F
03B22:  MOVLW  55
03B24:  MOVWF  FA7
03B26:  MOVLW  AA
03B28:  MOVWF  FA7
03B2A:  BSF    FA6.1
03B2C:  BTFSC  FA6.1
03B2E:  BRA    3B2C
03B30:  BCF    FA6.2
03B32:  MOVF   00,W
03B34:  IORWF  FF2,F
....................                }
03B36:  MOVLB  7
03B38:  MOVFF  7B4,03
03B3C:  MOVF   xB3,W
03B3E:  INCF   xB3,F
03B40:  BTFSC  FD8.2
03B42:  INCF   xB4,F
03B44:  INCF   xB5,F
03B46:  BTFSC  FD8.2
03B48:  INCF   xB6,F
03B4A:  BRA    3A66
03B4C:  MOVLB  F
....................             }
....................             SMS_Massage3[j] = '\0' ; // end string
03B4E:  MOVLW  DA
03B50:  MOVLB  7
03B52:  ADDWF  xB5,W
03B54:  MOVWF  FE9
03B56:  MOVLW  05
03B58:  ADDWFC xB6,W
03B5A:  MOVWF  FEA
03B5C:  CLRF   FEF
....................             
....................             j=0;
03B5E:  CLRF   xB6
03B60:  CLRF   xB5
....................             i++;
03B62:  INCF   xB3,F
03B64:  BTFSC  FD8.2
03B66:  INCF   xB4,F
....................             
....................             for(; ; i++,j++)
....................             {
....................                restart_wdt();
03B68:  CLRWDT
....................                if((RxD_Buff[i] == 0x0D) || (j > 30))
03B6A:  MOVLW  7C
03B6C:  ADDWF  xB3,W
03B6E:  MOVWF  FE9
03B70:  MOVLW  01
03B72:  ADDWFC xB4,W
03B74:  MOVWF  FEA
03B76:  MOVF   FEF,W
03B78:  SUBLW  0D
03B7A:  BZ    3B86
03B7C:  MOVF   xB6,F
03B7E:  BNZ   3B86
03B80:  MOVF   xB5,W
03B82:  SUBLW  1E
03B84:  BC    3BC6
....................                {
....................                   write_eeprom(0x5D+i,0x0D);
03B86:  MOVLW  5D
03B88:  ADDWF  xB3,W
03B8A:  MOVWF  xB9
03B8C:  MOVLW  00
03B8E:  ADDWFC xB4,W
03B90:  MOVWF  xBA
03B92:  MOVF   FF2,W
03B94:  MOVWF  00
03B96:  BCF    FF2.7
03B98:  MOVFF  7BA,FAA
03B9C:  MOVFF  7B9,FA9
03BA0:  MOVLW  0D
03BA2:  MOVWF  FA8
03BA4:  BCF    FA6.6
03BA6:  BCF    FA6.7
03BA8:  BSF    FA6.2
03BAA:  MOVLB  F
03BAC:  MOVLW  55
03BAE:  MOVWF  FA7
03BB0:  MOVLW  AA
03BB2:  MOVWF  FA7
03BB4:  BSF    FA6.1
03BB6:  BTFSC  FA6.1
03BB8:  BRA    3BB6
03BBA:  BCF    FA6.2
03BBC:  MOVF   00,W
03BBE:  IORWF  FF2,F
....................                   break;
03BC0:  BRA    3C50
....................                }
03BC2:  BRA    3C38
03BC4:  MOVLB  7
....................                else
....................                {
....................                   SMS_Massage4[j] = RxD_Buff[i];
03BC6:  MOVLW  FA
03BC8:  ADDWF  xB5,W
03BCA:  MOVWF  01
03BCC:  MOVLW  05
03BCE:  ADDWFC xB6,W
03BD0:  MOVWF  03
03BD2:  MOVLW  7C
03BD4:  ADDWF  xB3,W
03BD6:  MOVWF  FE9
03BD8:  MOVLW  01
03BDA:  ADDWFC xB4,W
03BDC:  MOVWF  FEA
03BDE:  MOVFF  FEF,7BB
03BE2:  MOVFF  03,FEA
03BE6:  MOVFF  01,FE9
03BEA:  MOVFF  7BB,FEF
....................                   write_eeprom(0x5D+i,RxD_Buff[i]);
03BEE:  MOVLW  5D
03BF0:  ADDWF  xB3,W
03BF2:  MOVWF  xB9
03BF4:  MOVLW  00
03BF6:  ADDWFC xB4,W
03BF8:  MOVWF  xBA
03BFA:  MOVLW  7C
03BFC:  ADDWF  xB3,W
03BFE:  MOVWF  FE9
03C00:  MOVLW  01
03C02:  ADDWFC xB4,W
03C04:  MOVWF  FEA
03C06:  MOVFF  FEF,7BB
03C0A:  MOVF   FF2,W
03C0C:  MOVWF  00
03C0E:  BCF    FF2.7
03C10:  MOVFF  7BA,FAA
03C14:  MOVFF  7B9,FA9
03C18:  MOVFF  7BB,FA8
03C1C:  BCF    FA6.6
03C1E:  BCF    FA6.7
03C20:  BSF    FA6.2
03C22:  MOVLB  F
03C24:  MOVLW  55
03C26:  MOVWF  FA7
03C28:  MOVLW  AA
03C2A:  MOVWF  FA7
03C2C:  BSF    FA6.1
03C2E:  BTFSC  FA6.1
03C30:  BRA    3C2E
03C32:  BCF    FA6.2
03C34:  MOVF   00,W
03C36:  IORWF  FF2,F
....................                }
03C38:  MOVLB  7
03C3A:  MOVFF  7B4,03
03C3E:  MOVF   xB3,W
03C40:  INCF   xB3,F
03C42:  BTFSC  FD8.2
03C44:  INCF   xB4,F
03C46:  INCF   xB5,F
03C48:  BTFSC  FD8.2
03C4A:  INCF   xB6,F
03C4C:  BRA    3B68
03C4E:  MOVLB  F
....................             }
....................             SMS_Massage4[j] = '\0' ; // end string
03C50:  MOVLW  FA
03C52:  MOVLB  7
03C54:  ADDWF  xB5,W
03C56:  MOVWF  FE9
03C58:  MOVLW  05
03C5A:  ADDWFC xB6,W
03C5C:  MOVWF  FEA
03C5E:  CLRF   FEF
....................             
....................             j=0;
03C60:  CLRF   xB6
03C62:  CLRF   xB5
....................             i++;
03C64:  INCF   xB3,F
03C66:  BTFSC  FD8.2
03C68:  INCF   xB4,F
....................             
....................             for(; ; i++,j++)
....................             {
....................                restart_wdt();
03C6A:  CLRWDT
....................                if((RxD_Buff[i] == 0x0D) || (j > 30))
03C6C:  MOVLW  7C
03C6E:  ADDWF  xB3,W
03C70:  MOVWF  FE9
03C72:  MOVLW  01
03C74:  ADDWFC xB4,W
03C76:  MOVWF  FEA
03C78:  MOVF   FEF,W
03C7A:  SUBLW  0D
03C7C:  BZ    3C88
03C7E:  MOVF   xB6,F
03C80:  BNZ   3C88
03C82:  MOVF   xB5,W
03C84:  SUBLW  1E
03C86:  BC    3CC8
....................                {
....................                   write_eeprom(0x5D+i,0x0D);
03C88:  MOVLW  5D
03C8A:  ADDWF  xB3,W
03C8C:  MOVWF  xB9
03C8E:  MOVLW  00
03C90:  ADDWFC xB4,W
03C92:  MOVWF  xBA
03C94:  MOVF   FF2,W
03C96:  MOVWF  00
03C98:  BCF    FF2.7
03C9A:  MOVFF  7BA,FAA
03C9E:  MOVFF  7B9,FA9
03CA2:  MOVLW  0D
03CA4:  MOVWF  FA8
03CA6:  BCF    FA6.6
03CA8:  BCF    FA6.7
03CAA:  BSF    FA6.2
03CAC:  MOVLB  F
03CAE:  MOVLW  55
03CB0:  MOVWF  FA7
03CB2:  MOVLW  AA
03CB4:  MOVWF  FA7
03CB6:  BSF    FA6.1
03CB8:  BTFSC  FA6.1
03CBA:  BRA    3CB8
03CBC:  BCF    FA6.2
03CBE:  MOVF   00,W
03CC0:  IORWF  FF2,F
....................                   break;
03CC2:  BRA    3D52
....................                }
03CC4:  BRA    3D3A
03CC6:  MOVLB  7
....................                else
....................                {
....................                   SMS_Massage5[j] = RxD_Buff[i];
03CC8:  MOVLW  1A
03CCA:  ADDWF  xB5,W
03CCC:  MOVWF  01
03CCE:  MOVLW  06
03CD0:  ADDWFC xB6,W
03CD2:  MOVWF  03
03CD4:  MOVLW  7C
03CD6:  ADDWF  xB3,W
03CD8:  MOVWF  FE9
03CDA:  MOVLW  01
03CDC:  ADDWFC xB4,W
03CDE:  MOVWF  FEA
03CE0:  MOVFF  FEF,7BB
03CE4:  MOVFF  03,FEA
03CE8:  MOVFF  01,FE9
03CEC:  MOVFF  7BB,FEF
....................                   write_eeprom(0x5D+i,RxD_Buff[i]);
03CF0:  MOVLW  5D
03CF2:  ADDWF  xB3,W
03CF4:  MOVWF  xB9
03CF6:  MOVLW  00
03CF8:  ADDWFC xB4,W
03CFA:  MOVWF  xBA
03CFC:  MOVLW  7C
03CFE:  ADDWF  xB3,W
03D00:  MOVWF  FE9
03D02:  MOVLW  01
03D04:  ADDWFC xB4,W
03D06:  MOVWF  FEA
03D08:  MOVFF  FEF,7BB
03D0C:  MOVF   FF2,W
03D0E:  MOVWF  00
03D10:  BCF    FF2.7
03D12:  MOVFF  7BA,FAA
03D16:  MOVFF  7B9,FA9
03D1A:  MOVFF  7BB,FA8
03D1E:  BCF    FA6.6
03D20:  BCF    FA6.7
03D22:  BSF    FA6.2
03D24:  MOVLB  F
03D26:  MOVLW  55
03D28:  MOVWF  FA7
03D2A:  MOVLW  AA
03D2C:  MOVWF  FA7
03D2E:  BSF    FA6.1
03D30:  BTFSC  FA6.1
03D32:  BRA    3D30
03D34:  BCF    FA6.2
03D36:  MOVF   00,W
03D38:  IORWF  FF2,F
....................                }
03D3A:  MOVLB  7
03D3C:  MOVFF  7B4,03
03D40:  MOVF   xB3,W
03D42:  INCF   xB3,F
03D44:  BTFSC  FD8.2
03D46:  INCF   xB4,F
03D48:  INCF   xB5,F
03D4A:  BTFSC  FD8.2
03D4C:  INCF   xB6,F
03D4E:  BRA    3C6A
03D50:  MOVLB  F
....................             }
....................             SMS_Massage5[j] = '\0' ; // end string
03D52:  MOVLW  1A
03D54:  MOVLB  7
03D56:  ADDWF  xB5,W
03D58:  MOVWF  FE9
03D5A:  MOVLW  06
03D5C:  ADDWFC xB6,W
03D5E:  MOVWF  FEA
03D60:  CLRF   FEF
....................             
....................             j=0;
03D62:  CLRF   xB6
03D64:  CLRF   xB5
....................             i++;
03D66:  INCF   xB3,F
03D68:  BTFSC  FD8.2
03D6A:  INCF   xB4,F
....................             
....................             for(; ; i++,j++)
....................             {
....................                restart_wdt();
03D6C:  CLRWDT
....................                if((RxD_Buff[i] == 0x0D) || (j > 30))
03D6E:  MOVLW  7C
03D70:  ADDWF  xB3,W
03D72:  MOVWF  FE9
03D74:  MOVLW  01
03D76:  ADDWFC xB4,W
03D78:  MOVWF  FEA
03D7A:  MOVF   FEF,W
03D7C:  SUBLW  0D
03D7E:  BZ    3D8A
03D80:  MOVF   xB6,F
03D82:  BNZ   3D8A
03D84:  MOVF   xB5,W
03D86:  SUBLW  1E
03D88:  BC    3DCA
....................                {
....................                   write_eeprom(0x5D+i,0x0D);
03D8A:  MOVLW  5D
03D8C:  ADDWF  xB3,W
03D8E:  MOVWF  xB9
03D90:  MOVLW  00
03D92:  ADDWFC xB4,W
03D94:  MOVWF  xBA
03D96:  MOVF   FF2,W
03D98:  MOVWF  00
03D9A:  BCF    FF2.7
03D9C:  MOVFF  7BA,FAA
03DA0:  MOVFF  7B9,FA9
03DA4:  MOVLW  0D
03DA6:  MOVWF  FA8
03DA8:  BCF    FA6.6
03DAA:  BCF    FA6.7
03DAC:  BSF    FA6.2
03DAE:  MOVLB  F
03DB0:  MOVLW  55
03DB2:  MOVWF  FA7
03DB4:  MOVLW  AA
03DB6:  MOVWF  FA7
03DB8:  BSF    FA6.1
03DBA:  BTFSC  FA6.1
03DBC:  BRA    3DBA
03DBE:  BCF    FA6.2
03DC0:  MOVF   00,W
03DC2:  IORWF  FF2,F
....................                   break;
03DC4:  BRA    3E58
....................                }
03DC6:  BRA    3E40
03DC8:  MOVLB  7
....................                else
....................                {
....................                   write_eeprom(0x5D+i,RxD_Buff[i]);
03DCA:  MOVLW  5D
03DCC:  ADDWF  xB3,W
03DCE:  MOVWF  xB9
03DD0:  MOVLW  00
03DD2:  ADDWFC xB4,W
03DD4:  MOVWF  xBA
03DD6:  MOVLW  7C
03DD8:  ADDWF  xB3,W
03DDA:  MOVWF  FE9
03DDC:  MOVLW  01
03DDE:  ADDWFC xB4,W
03DE0:  MOVWF  FEA
03DE2:  MOVFF  FEF,7BB
03DE6:  MOVF   FF2,W
03DE8:  MOVWF  00
03DEA:  BCF    FF2.7
03DEC:  MOVFF  7BA,FAA
03DF0:  MOVFF  7B9,FA9
03DF4:  MOVFF  7BB,FA8
03DF8:  BCF    FA6.6
03DFA:  BCF    FA6.7
03DFC:  BSF    FA6.2
03DFE:  MOVLB  F
03E00:  MOVLW  55
03E02:  MOVWF  FA7
03E04:  MOVLW  AA
03E06:  MOVWF  FA7
03E08:  BSF    FA6.1
03E0A:  BTFSC  FA6.1
03E0C:  BRA    3E0A
03E0E:  BCF    FA6.2
03E10:  MOVF   00,W
03E12:  IORWF  FF2,F
....................                   SMS_Massage6[j] = RxD_Buff[i];
03E14:  MOVLW  3A
03E16:  MOVLB  7
03E18:  ADDWF  xB5,W
03E1A:  MOVWF  01
03E1C:  MOVLW  06
03E1E:  ADDWFC xB6,W
03E20:  MOVWF  03
03E22:  MOVLW  7C
03E24:  ADDWF  xB3,W
03E26:  MOVWF  FE9
03E28:  MOVLW  01
03E2A:  ADDWFC xB4,W
03E2C:  MOVWF  FEA
03E2E:  MOVFF  FEF,7BB
03E32:  MOVFF  03,FEA
03E36:  MOVFF  01,FE9
03E3A:  MOVFF  7BB,FEF
03E3E:  MOVLB  F
....................                }
03E40:  MOVLB  7
03E42:  MOVFF  7B4,03
03E46:  MOVF   xB3,W
03E48:  INCF   xB3,F
03E4A:  BTFSC  FD8.2
03E4C:  INCF   xB4,F
03E4E:  INCF   xB5,F
03E50:  BTFSC  FD8.2
03E52:  INCF   xB6,F
03E54:  BRA    3D6C
03E56:  MOVLB  F
....................             }
....................             SMS_Massage6[j] = '\0' ; // end string
03E58:  MOVLW  3A
03E5A:  MOVLB  7
03E5C:  ADDWF  xB5,W
03E5E:  MOVWF  FE9
03E60:  MOVLW  06
03E62:  ADDWFC xB6,W
03E64:  MOVWF  FEA
03E66:  CLRF   FEF
....................             
....................             j=0;
03E68:  CLRF   xB6
03E6A:  CLRF   xB5
....................             i++;
03E6C:  INCF   xB3,F
03E6E:  BTFSC  FD8.2
03E70:  INCF   xB4,F
....................             
....................             for(; ; i++,j++)
....................             {
....................                restart_wdt();
03E72:  CLRWDT
....................                if((RxD_Buff[i] == 0x0D) || (j > 30))
03E74:  MOVLW  7C
03E76:  ADDWF  xB3,W
03E78:  MOVWF  FE9
03E7A:  MOVLW  01
03E7C:  ADDWFC xB4,W
03E7E:  MOVWF  FEA
03E80:  MOVF   FEF,W
03E82:  SUBLW  0D
03E84:  BZ    3E90
03E86:  MOVF   xB6,F
03E88:  BNZ   3E90
03E8A:  MOVF   xB5,W
03E8C:  SUBLW  1E
03E8E:  BC    3ED0
....................                {
....................                   write_eeprom(0x5D+i,0x0D);
03E90:  MOVLW  5D
03E92:  ADDWF  xB3,W
03E94:  MOVWF  xB9
03E96:  MOVLW  00
03E98:  ADDWFC xB4,W
03E9A:  MOVWF  xBA
03E9C:  MOVF   FF2,W
03E9E:  MOVWF  00
03EA0:  BCF    FF2.7
03EA2:  MOVFF  7BA,FAA
03EA6:  MOVFF  7B9,FA9
03EAA:  MOVLW  0D
03EAC:  MOVWF  FA8
03EAE:  BCF    FA6.6
03EB0:  BCF    FA6.7
03EB2:  BSF    FA6.2
03EB4:  MOVLB  F
03EB6:  MOVLW  55
03EB8:  MOVWF  FA7
03EBA:  MOVLW  AA
03EBC:  MOVWF  FA7
03EBE:  BSF    FA6.1
03EC0:  BTFSC  FA6.1
03EC2:  BRA    3EC0
03EC4:  BCF    FA6.2
03EC6:  MOVF   00,W
03EC8:  IORWF  FF2,F
....................                   break;
03ECA:  BRA    3F5A
....................                }
03ECC:  BRA    3F42
03ECE:  MOVLB  7
....................                else
....................                {
....................                   SMS_Massage7[j] = RxD_Buff[i];
03ED0:  MOVLW  5A
03ED2:  ADDWF  xB5,W
03ED4:  MOVWF  01
03ED6:  MOVLW  06
03ED8:  ADDWFC xB6,W
03EDA:  MOVWF  03
03EDC:  MOVLW  7C
03EDE:  ADDWF  xB3,W
03EE0:  MOVWF  FE9
03EE2:  MOVLW  01
03EE4:  ADDWFC xB4,W
03EE6:  MOVWF  FEA
03EE8:  MOVFF  FEF,7BB
03EEC:  MOVFF  03,FEA
03EF0:  MOVFF  01,FE9
03EF4:  MOVFF  7BB,FEF
....................                   write_eeprom(0x5D+i,RxD_Buff[i]);
03EF8:  MOVLW  5D
03EFA:  ADDWF  xB3,W
03EFC:  MOVWF  xB9
03EFE:  MOVLW  00
03F00:  ADDWFC xB4,W
03F02:  MOVWF  xBA
03F04:  MOVLW  7C
03F06:  ADDWF  xB3,W
03F08:  MOVWF  FE9
03F0A:  MOVLW  01
03F0C:  ADDWFC xB4,W
03F0E:  MOVWF  FEA
03F10:  MOVFF  FEF,7BB
03F14:  MOVF   FF2,W
03F16:  MOVWF  00
03F18:  BCF    FF2.7
03F1A:  MOVFF  7BA,FAA
03F1E:  MOVFF  7B9,FA9
03F22:  MOVFF  7BB,FA8
03F26:  BCF    FA6.6
03F28:  BCF    FA6.7
03F2A:  BSF    FA6.2
03F2C:  MOVLB  F
03F2E:  MOVLW  55
03F30:  MOVWF  FA7
03F32:  MOVLW  AA
03F34:  MOVWF  FA7
03F36:  BSF    FA6.1
03F38:  BTFSC  FA6.1
03F3A:  BRA    3F38
03F3C:  BCF    FA6.2
03F3E:  MOVF   00,W
03F40:  IORWF  FF2,F
....................                }
03F42:  MOVLB  7
03F44:  MOVFF  7B4,03
03F48:  MOVF   xB3,W
03F4A:  INCF   xB3,F
03F4C:  BTFSC  FD8.2
03F4E:  INCF   xB4,F
03F50:  INCF   xB5,F
03F52:  BTFSC  FD8.2
03F54:  INCF   xB6,F
03F56:  BRA    3E72
03F58:  MOVLB  F
....................             }
....................             SMS_Massage7[j] = '\0' ; // end string
03F5A:  MOVLW  5A
03F5C:  MOVLB  7
03F5E:  ADDWF  xB5,W
03F60:  MOVWF  FE9
03F62:  MOVLW  06
03F64:  ADDWFC xB6,W
03F66:  MOVWF  FEA
03F68:  CLRF   FEF
....................             
....................             j=0;
03F6A:  CLRF   xB6
03F6C:  CLRF   xB5
....................             i++;
03F6E:  INCF   xB3,F
03F70:  BTFSC  FD8.2
03F72:  INCF   xB4,F
....................             
....................             for(; ; i++,j++)
....................             {
....................                restart_wdt();
03F74:  CLRWDT
....................                if((RxD_Buff[i] == 0x0D) || (j > 30))
03F76:  MOVLW  7C
03F78:  ADDWF  xB3,W
03F7A:  MOVWF  FE9
03F7C:  MOVLW  01
03F7E:  ADDWFC xB4,W
03F80:  MOVWF  FEA
03F82:  MOVF   FEF,W
03F84:  SUBLW  0D
03F86:  BZ    3F92
03F88:  MOVF   xB6,F
03F8A:  BNZ   3F92
03F8C:  MOVF   xB5,W
03F8E:  SUBLW  1E
03F90:  BC    3FD2
....................                {
....................                   write_eeprom(0x5D+i,0x0D);
03F92:  MOVLW  5D
03F94:  ADDWF  xB3,W
03F96:  MOVWF  xB9
03F98:  MOVLW  00
03F9A:  ADDWFC xB4,W
03F9C:  MOVWF  xBA
03F9E:  MOVF   FF2,W
03FA0:  MOVWF  00
03FA2:  BCF    FF2.7
03FA4:  MOVFF  7BA,FAA
03FA8:  MOVFF  7B9,FA9
03FAC:  MOVLW  0D
03FAE:  MOVWF  FA8
03FB0:  BCF    FA6.6
03FB2:  BCF    FA6.7
03FB4:  BSF    FA6.2
03FB6:  MOVLB  F
03FB8:  MOVLW  55
03FBA:  MOVWF  FA7
03FBC:  MOVLW  AA
03FBE:  MOVWF  FA7
03FC0:  BSF    FA6.1
03FC2:  BTFSC  FA6.1
03FC4:  BRA    3FC2
03FC6:  BCF    FA6.2
03FC8:  MOVF   00,W
03FCA:  IORWF  FF2,F
....................                   break;
03FCC:  BRA    405C
....................                }
03FCE:  BRA    4044
03FD0:  MOVLB  7
....................                else
....................                {
....................                   SMS_Massage8[j] = RxD_Buff[i];
03FD2:  MOVLW  7A
03FD4:  ADDWF  xB5,W
03FD6:  MOVWF  01
03FD8:  MOVLW  06
03FDA:  ADDWFC xB6,W
03FDC:  MOVWF  03
03FDE:  MOVLW  7C
03FE0:  ADDWF  xB3,W
03FE2:  MOVWF  FE9
03FE4:  MOVLW  01
03FE6:  ADDWFC xB4,W
03FE8:  MOVWF  FEA
03FEA:  MOVFF  FEF,7BB
03FEE:  MOVFF  03,FEA
03FF2:  MOVFF  01,FE9
03FF6:  MOVFF  7BB,FEF
....................                   write_eeprom(0x5D+i,RxD_Buff[i]);
03FFA:  MOVLW  5D
03FFC:  ADDWF  xB3,W
03FFE:  MOVWF  xB9
04000:  MOVLW  00
04002:  ADDWFC xB4,W
04004:  MOVWF  xBA
04006:  MOVLW  7C
04008:  ADDWF  xB3,W
0400A:  MOVWF  FE9
0400C:  MOVLW  01
0400E:  ADDWFC xB4,W
04010:  MOVWF  FEA
04012:  MOVFF  FEF,7BB
04016:  MOVF   FF2,W
04018:  MOVWF  00
0401A:  BCF    FF2.7
0401C:  MOVFF  7BA,FAA
04020:  MOVFF  7B9,FA9
04024:  MOVFF  7BB,FA8
04028:  BCF    FA6.6
0402A:  BCF    FA6.7
0402C:  BSF    FA6.2
0402E:  MOVLB  F
04030:  MOVLW  55
04032:  MOVWF  FA7
04034:  MOVLW  AA
04036:  MOVWF  FA7
04038:  BSF    FA6.1
0403A:  BTFSC  FA6.1
0403C:  BRA    403A
0403E:  BCF    FA6.2
04040:  MOVF   00,W
04042:  IORWF  FF2,F
....................                }
04044:  MOVLB  7
04046:  MOVFF  7B4,03
0404A:  MOVF   xB3,W
0404C:  INCF   xB3,F
0404E:  BTFSC  FD8.2
04050:  INCF   xB4,F
04052:  INCF   xB5,F
04054:  BTFSC  FD8.2
04056:  INCF   xB6,F
04058:  BRA    3F74
0405A:  MOVLB  F
....................             }
....................             SMS_Massage8[j] = '\0' ; // end string
0405C:  MOVLW  7A
0405E:  MOVLB  7
04060:  ADDWF  xB5,W
04062:  MOVWF  FE9
04064:  MOVLW  06
04066:  ADDWFC xB6,W
04068:  MOVWF  FEA
0406A:  CLRF   FEF
....................             
....................          
....................             TxD_Buff[0] = Address ;         //Address
0406C:  MOVFF  7B,7D
....................             TxD_Buff[1] = 0x22 ;            //return function code
04070:  MOVLW  22
04072:  MOVLB  0
04074:  MOVWF  x7E
.................... 
....................             CRC(TxD_Buff,2)   ;            //Cal CRC 2 byte
04076:  MOVLB  7
04078:  CLRF   xBB
0407A:  MOVLW  7D
0407C:  MOVWF  xBA
0407E:  MOVLW  02
04080:  MOVWF  xBC
04082:  MOVLB  0
04084:  CALL   1D7C
.................... 
....................             TxD_Buff[2] = CRC_Hi ;
04088:  MOVFF  37D,7F
....................             TxD_Buff[3] = CRC_Lo ;
0408C:  MOVFF  37C,80
.................... 
....................             output_bit(P485ctrl,1);
04090:  BSF    F8A.3
04092:  BCF    F93.3
....................             delay_ms(10);
04094:  MOVLW  0A
04096:  MOVLB  7
04098:  MOVWF  xB9
0409A:  MOVLB  0
0409C:  CALL   0662
.................... 
....................             putc(Txd_Buff[0]);
040A0:  MOVF   x7D,W
040A2:  CALL   1DD2
....................             putc(Txd_Buff[1]);
040A6:  MOVF   x7E,W
040A8:  CALL   1DD2
....................             putc(Txd_Buff[2]);
040AC:  MOVF   x7F,W
040AE:  CALL   1DD2
....................             putc(Txd_Buff[3]);
040B2:  MOVF   x80,W
040B4:  CALL   1DD2
.................... 
....................             delay_ms(3);
040B8:  MOVLW  03
040BA:  MOVLB  7
040BC:  MOVWF  xB9
040BE:  MOVLB  0
040C0:  CALL   0662
....................             output_bit(P485ctrl,0);
040C4:  BCF    F8A.3
040C6:  BCF    F93.3
040C8:  MOVLB  3
....................          }
....................    ////////////////////////////// WRITE Faultname //////////////////////////
....................          
....................          
....................          if(RxD_Buff[1] == 0x03)///////////// READ HOLDING REGGISTER /////////////////////
040CA:  MOVLB  1
040CC:  MOVF   x7D,W
040CE:  SUBLW  03
040D0:  BNZ   415E
....................          {
.................... 
....................             Data_Buff[0] = 0x00;// dummy data
040D2:  MOVLB  3
040D4:  CLRF   x85
....................             Data_Buff[1] = Input1_8;
040D6:  MOVFF  4B,386
....................             
....................             
....................             TxD_Buff[0] = Address ;         //Address
040DA:  MOVFF  7B,7D
....................             TxD_Buff[1] = 0x03 ;           //Function Code
040DE:  MOVLW  03
040E0:  MOVLB  0
040E2:  MOVWF  x7E
....................             TxD_Buff[2] = 0x02 ;          //Byte Count
040E4:  MOVLW  02
040E6:  MOVWF  x7F
....................             TxD_Buff[3] = Data_Buff[0];   //first byte Data
040E8:  MOVFF  385,80
....................             TxD_Buff[4] = Data_Buff[1];   //first byte Data
040EC:  MOVFF  386,81
.................... 
....................             CRC(TxD_Buff,5)   ;            //Cal CRC 5 Byte
040F0:  MOVLB  7
040F2:  CLRF   xBB
040F4:  MOVLW  7D
040F6:  MOVWF  xBA
040F8:  MOVLW  05
040FA:  MOVWF  xBC
040FC:  MOVLB  0
040FE:  CALL   1D7C
.................... 
....................             TxD_Buff[5] = CRC_Hi ;
04102:  MOVFF  37D,82
....................             TxD_Buff[6] = CRC_Lo ;
04106:  MOVFF  37C,83
.................... 
.................... 
....................             output_bit(P485ctrl,1);
0410A:  BSF    F8A.3
0410C:  BCF    F93.3
....................             restart_wdt();
0410E:  CLRWDT
....................             delay_ms(4);
04110:  MOVLW  04
04112:  MOVLB  7
04114:  MOVWF  xB9
04116:  MOVLB  0
04118:  CALL   0662
....................             restart_wdt();
0411C:  CLRWDT
.................... 
....................             putc(TxD_Buff[0]) ;               //Address
0411E:  MOVF   x7D,W
04120:  CALL   1DD2
....................             putc(TxD_Buff[1]) ;               //Function Code
04124:  MOVF   x7E,W
04126:  CALL   1DD2
....................             putc(TxD_Buff[2]) ;               //Byte Count
0412A:  MOVF   x7F,W
0412C:  CALL   1DD2
....................             putc(TxD_Buff[3]) ;
04130:  MOVF   x80,W
04132:  CALL   1DD2
....................             putc(TxD_Buff[4]) ;
04136:  MOVF   x81,W
04138:  CALL   1DD2
....................             putc(TxD_Buff[5]) ;
0413C:  MOVF   x82,W
0413E:  CALL   1DD2
....................             putc(TxD_Buff[6]) ;
04142:  MOVF   x83,W
04144:  CALL   1DD2
.................... 
....................             restart_wdt();
04148:  CLRWDT
....................             delay_ms(3);
0414A:  MOVLW  03
0414C:  MOVLB  7
0414E:  MOVWF  xB9
04150:  MOVLB  0
04152:  CALL   0662
....................             restart_wdt();
04156:  CLRWDT
....................             output_bit(P485ctrl,0);
04158:  BCF    F8A.3
0415A:  BCF    F93.3
0415C:  MOVLB  1
.................... 
....................          }
....................        
.................... 
....................       }  //if(RxD_Buff[1] == address)
.................... 
....................       Send_check_Time = 500; //5 Second
0415E:  MOVLW  01
04160:  MOVLB  3
04162:  MOVWF  x7F
04164:  MOVLW  F4
04166:  MOVWF  x7E
....................    } // if crc
.................... 
....................    recieve_completed = 0 ;
04168:  BCF    32.5
....................    sequence = end_sq ;
0416A:  MOVFF  71,7A
....................    T_timeout = 0x00;
0416E:  MOVLB  5
04170:  CLRF   x87
....................    RxD_DataLen = 0x00 ;
04172:  MOVLB  0
04174:  CLRF   x7C
....................    output_bit(P485ctrl,0);
04176:  BCF    F8A.3
04178:  BCF    F93.3
0417A:  GOTO   5EE2 (RETURN)
.................... }
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////
.................... 
.................... void Read_Input(void)
.................... {
....................    //if(NoOfPoint >= 10)
....................    //{
....................       // if(NoOfPoint >= 20)
....................    //{   
....................      
....................       ///////////////////////--Edit--///////////////////
....................       MCP23s17_Ip_dat = IO_INPUT_A(IO_DEVICE_1);
*
0146E:  MOVLW  02
01470:  MOVLB  7
01472:  MOVWF  xBA
01474:  MOVLB  0
01476:  BRA    1338
01478:  MOVFF  01,585
....................           
....................       if (AutoTestFlag)  // TEST FROM MODBUS
0147C:  BTFSS  1C.4
0147E:  BRA    1486
....................       {
....................          MCP23s17_Ip_dat = ~MCP23s17_Ip_dat;
01480:  MOVLB  5
01482:  COMF   x85,F
01484:  MOVLB  0
....................          
....................       }
....................       
....................      // FaultNow[11] = MCP23s17_Ip_dat;
....................       FaultNow[1] = MCP23s17_Ip_dat >> 1;
01486:  BCF    FD8.0
01488:  MOVLB  5
0148A:  RRCF   x85,W
0148C:  MOVLB  7
0148E:  BCF    x50.1
01490:  BTFSC  FE8.0
01492:  BSF    x50.1
....................       FaultNow[2] = MCP23s17_Ip_dat >> 2;
01494:  MOVLB  5
01496:  RRCF   x85,W
01498:  MOVWF  00
0149A:  RRCF   00,F
0149C:  MOVLW  3F
0149E:  ANDWF  00,F
014A0:  MOVLB  7
014A2:  BCF    x50.2
014A4:  BTFSC  00.0
014A6:  BSF    x50.2
....................       FaultNow[3] = MCP23s17_Ip_dat >> 3;
014A8:  MOVLB  5
014AA:  RRCF   x85,W
014AC:  MOVWF  00
014AE:  RRCF   00,F
014B0:  RRCF   00,F
014B2:  MOVLW  1F
014B4:  ANDWF  00,F
014B6:  MOVLB  7
014B8:  BCF    x50.3
014BA:  BTFSC  00.0
014BC:  BSF    x50.3
....................       FaultNow[4] = MCP23s17_Ip_dat >> 4;
014BE:  MOVLB  5
014C0:  SWAPF  x85,W
014C2:  MOVWF  00
014C4:  MOVLW  0F
014C6:  ANDWF  00,F
014C8:  MOVLB  7
014CA:  BCF    x50.4
014CC:  BTFSC  00.0
014CE:  BSF    x50.4
....................       FaultNow[5] = MCP23s17_Ip_dat >> 5;
014D0:  MOVLB  5
014D2:  SWAPF  x85,W
014D4:  MOVWF  00
014D6:  RRCF   00,F
014D8:  MOVLW  07
014DA:  ANDWF  00,F
014DC:  MOVLB  7
014DE:  BCF    x50.5
014E0:  BTFSC  00.0
014E2:  BSF    x50.5
....................       FaultNow[6] = MCP23s17_Ip_dat >> 6;
014E4:  MOVLB  5
014E6:  SWAPF  x85,W
014E8:  MOVWF  00
014EA:  RRCF   00,F
014EC:  RRCF   00,F
014EE:  MOVLW  03
014F0:  ANDWF  00,F
014F2:  MOVLB  7
014F4:  BCF    x50.6
014F6:  BTFSC  00.0
014F8:  BSF    x50.6
....................       FaultNow[7] = MCP23s17_Ip_dat >> 7;
014FA:  CLRF   00
014FC:  MOVLB  5
014FE:  BTFSC  x85.7
01500:  BSF    00.0
01502:  MOVLB  7
01504:  BCF    x50.7
01506:  BTFSC  00.0
01508:  BSF    x50.7
....................       
....................       MCP23s17_Ip_dat = IO_INPUT_B(IO_DEVICE_1);
0150A:  MOVLW  02
0150C:  MOVWF  xBA
0150E:  MOVLB  0
01510:  BRA    1356
01512:  MOVFF  01,585
....................       
....................       if (AutoTestFlag)  // TEST FROM MODBUS
01516:  BTFSS  1C.4
01518:  BRA    1520
....................       {
....................          MCP23s17_Ip_dat = ~MCP23s17_Ip_dat;
0151A:  MOVLB  5
0151C:  COMF   x85,F
0151E:  MOVLB  0
....................       }
....................       
....................       FaultNow[8] = MCP23s17_Ip_dat;
01520:  MOVLB  7
01522:  BCF    x51.0
01524:  MOVLB  5
01526:  BTFSS  x85.0
01528:  BRA    1530
0152A:  MOVLB  7
0152C:  BSF    x51.0
0152E:  MOVLB  5
....................       
.................... 
....................       ///////////////---Anal Fault---//////////////////
....................       unsigned char i;
....................       for( i=1; i<=8; i++)
01530:  MOVLW  01
01532:  MOVLB  7
01534:  MOVWF  xB9
01536:  MOVF   xB9,W
01538:  SUBLW  08
0153A:  BTFSS  FD8.0
0153C:  BRA    19E6
....................       {
....................          if(FaultNCNO[i] ==NO)
0153E:  MOVFF  7B9,7BD
01542:  MOVLW  07
01544:  MOVWF  xBF
01546:  MOVLW  A4
01548:  MOVWF  xBE
0154A:  MOVLB  0
0154C:  RCALL  1374
0154E:  MOVF   01,W
01550:  ANDLW  01
01552:  SUBLW  01
01554:  BTFSS  FD8.2
01556:  BRA    178E
....................          {
....................              if(FaultNow[i]==0)
01558:  MOVFF  7B9,7BD
0155C:  MOVLW  07
0155E:  MOVLB  7
01560:  MOVWF  xBF
01562:  MOVLW  50
01564:  MOVWF  xBE
01566:  MOVLB  0
01568:  RCALL  1374
0156A:  MOVF   01,W
0156C:  ANDLW  01
0156E:  BTFSS  FD8.2
01570:  BRA    1680
....................              {   
....................                if(FaultAgo[i]==0)
01572:  MOVFF  7B9,7BD
01576:  MOVLW  07
01578:  MOVLB  7
0157A:  MOVWF  xBF
0157C:  MOVLW  4D
0157E:  MOVWF  xBE
01580:  MOVLB  0
01582:  RCALL  1374
01584:  MOVF   01,W
01586:  ANDLW  01
01588:  BTFSS  FD8.2
0158A:  BRA    1664
....................                {
....................                    ReleaseTime[i]++;
0158C:  BCF    FD8.0
0158E:  MOVLB  7
01590:  RLCF   xB9,W
01592:  CLRF   03
01594:  ADDLW  53
01596:  MOVWF  FE9
01598:  MOVLW  07
0159A:  ADDWFC 03,W
0159C:  MOVWF  FEA
0159E:  MOVLW  01
015A0:  ADDWF  FEE,F
015A2:  BNC   15A6
015A4:  INCF   FEF,F
....................                   
....................                    if(ReleaseTime[i]>=((FaultDelayTime[i]*75)+15)) //time per loop are 368 microSec. (1.89*10=200ms)
015A6:  BCF    FD8.0
015A8:  RLCF   xB9,W
015AA:  CLRF   03
015AC:  ADDLW  53
015AE:  MOVWF  FE9
015B0:  MOVLW  07
015B2:  ADDWFC 03,W
015B4:  MOVWF  FEA
015B6:  MOVFF  FEC,7BB
015BA:  MOVF   FED,F
015BC:  MOVFF  FEF,7BA
015C0:  BCF    FD8.0
015C2:  RLCF   xB9,W
015C4:  CLRF   03
015C6:  ADDLW  7B
015C8:  MOVWF  FE9
015CA:  MOVLW  07
015CC:  ADDWFC 03,W
015CE:  MOVWF  FEA
015D0:  MOVFF  FEC,7BF
015D4:  MOVF   FED,F
015D6:  MOVFF  FEF,7BE
015DA:  CLRF   xC1
015DC:  MOVLW  4B
015DE:  MOVWF  xC0
015E0:  MOVLB  0
015E2:  RCALL  13AA
015E4:  MOVFF  02,7BD
015E8:  MOVFF  01,7BC
015EC:  MOVLW  0F
015EE:  MOVLB  7
015F0:  ADDWF  01,W
015F2:  MOVWF  01
015F4:  MOVLW  00
015F6:  ADDWFC 02,W
015F8:  MOVWF  03
015FA:  MOVF   03,W
015FC:  SUBWF  xBB,W
015FE:  BNC   1660
01600:  BNZ   1608
01602:  MOVF   01,W
01604:  SUBWF  xBA,W
01606:  BNC   1660
....................                    {   
....................                      ReleaseTime[i] = 0;
01608:  BCF    FD8.0
0160A:  RLCF   xB9,W
0160C:  CLRF   03
0160E:  ADDLW  53
01610:  MOVWF  FE9
01612:  MOVLW  07
01614:  ADDWFC 03,W
01616:  MOVWF  FEA
01618:  CLRF   FEC
0161A:  MOVF   FED,F
0161C:  CLRF   FEF
....................                      switch(i)
0161E:  MOVLW  01
01620:  SUBWF  xB9,W
01622:  ADDLW  F8
01624:  BC    1660
01626:  ADDLW  08
01628:  MOVLB  0
0162A:  GOTO   1A6A
....................                      {
....................                         case 1:
....................                            Inputt.B1 = 0; 
0162E:  MOVLB  7
01630:  BCF    x3E.0
....................                         break;
01632:  BRA    1660
....................                         case 2:
....................                            Inputt.B2 = 0; 
01634:  MOVLB  7
01636:  BCF    x3E.1
....................                         break;
01638:  BRA    1660
....................                         case 3:
....................                            Inputt.B3 = 0; 
0163A:  MOVLB  7
0163C:  BCF    x3E.2
....................                         break;
0163E:  BRA    1660
....................                         case 4:
....................                            Inputt.B4 = 0; 
01640:  MOVLB  7
01642:  BCF    x3E.3
....................                         break;
01644:  BRA    1660
....................                         case 5:
....................                            Inputt.B5 = 0; 
01646:  MOVLB  7
01648:  BCF    x3E.4
....................                         break;
0164A:  BRA    1660
....................                         case 6:
....................                            Inputt.B6 = 0; 
0164C:  MOVLB  7
0164E:  BCF    x3E.5
....................                         break;
01650:  BRA    1660
....................                         case 7:
....................                            Inputt.B7 = 0; 
01652:  MOVLB  7
01654:  BCF    x3E.6
....................                          break;
01656:  BRA    1660
....................                          case 8:
....................                            Inputt.B8 = 0; 
01658:  MOVLB  7
0165A:  BCF    x3E.7
....................                         break;
0165C:  BRA    1660
0165E:  MOVLB  7
....................            
....................                      }                 
....................                    }
....................                }
01660:  BRA    167C
01662:  MOVLB  0
....................                else
....................                {
....................                   ReleaseTime[i] = 0;
01664:  BCF    FD8.0
01666:  MOVLB  7
01668:  RLCF   xB9,W
0166A:  CLRF   03
0166C:  ADDLW  53
0166E:  MOVWF  FE9
01670:  MOVLW  07
01672:  ADDWFC 03,W
01674:  MOVWF  FEA
01676:  CLRF   FEC
01678:  MOVF   FED,F
0167A:  CLRF   FEF
....................                }
....................              }
0167C:  BRA    178C
0167E:  MOVLB  0
....................              else //if(FaultNow[i]==1
....................              {
....................                if(FaultAgo[i]==1)
01680:  MOVFF  7B9,7BD
01684:  MOVLW  07
01686:  MOVLB  7
01688:  MOVWF  xBF
0168A:  MOVLW  4D
0168C:  MOVWF  xBE
0168E:  MOVLB  0
01690:  RCALL  1374
01692:  MOVF   01,W
01694:  ANDLW  01
01696:  SUBLW  01
01698:  BTFSS  FD8.2
0169A:  BRA    1774
....................                {
....................                    ReleaseTime[i]++;
0169C:  BCF    FD8.0
0169E:  MOVLB  7
016A0:  RLCF   xB9,W
016A2:  CLRF   03
016A4:  ADDLW  53
016A6:  MOVWF  FE9
016A8:  MOVLW  07
016AA:  ADDWFC 03,W
016AC:  MOVWF  FEA
016AE:  MOVLW  01
016B0:  ADDWF  FEE,F
016B2:  BNC   16B6
016B4:  INCF   FEF,F
....................                   
....................                    if(ReleaseTime[i]>=((FaultDelayTime[i]*75)+15)) //time per loop are 368 microSec. (1.89*10=200ms)
016B6:  BCF    FD8.0
016B8:  RLCF   xB9,W
016BA:  CLRF   03
016BC:  ADDLW  53
016BE:  MOVWF  FE9
016C0:  MOVLW  07
016C2:  ADDWFC 03,W
016C4:  MOVWF  FEA
016C6:  MOVFF  FEC,7BB
016CA:  MOVF   FED,F
016CC:  MOVFF  FEF,7BA
016D0:  BCF    FD8.0
016D2:  RLCF   xB9,W
016D4:  CLRF   03
016D6:  ADDLW  7B
016D8:  MOVWF  FE9
016DA:  MOVLW  07
016DC:  ADDWFC 03,W
016DE:  MOVWF  FEA
016E0:  MOVFF  FEC,7BF
016E4:  MOVF   FED,F
016E6:  MOVFF  FEF,7BE
016EA:  CLRF   xC1
016EC:  MOVLW  4B
016EE:  MOVWF  xC0
016F0:  MOVLB  0
016F2:  RCALL  13AA
016F4:  MOVFF  02,7BD
016F8:  MOVFF  01,7BC
016FC:  MOVLW  0F
016FE:  MOVLB  7
01700:  ADDWF  01,W
01702:  MOVWF  01
01704:  MOVLW  00
01706:  ADDWFC 02,W
01708:  MOVWF  03
0170A:  MOVF   03,W
0170C:  SUBWF  xBB,W
0170E:  BNC   1770
01710:  BNZ   1718
01712:  MOVF   01,W
01714:  SUBWF  xBA,W
01716:  BNC   1770
....................                    {   
....................                      ReleaseTime[i] = 1;
01718:  BCF    FD8.0
0171A:  RLCF   xB9,W
0171C:  CLRF   03
0171E:  ADDLW  53
01720:  MOVWF  FE9
01722:  MOVLW  07
01724:  ADDWFC 03,W
01726:  MOVWF  FEA
01728:  CLRF   FEC
0172A:  MOVF   FED,F
0172C:  MOVLW  01
0172E:  MOVWF  FEF
....................                      switch(i)
01730:  SUBWF  xB9,W
01732:  ADDLW  F8
01734:  BC    1770
01736:  ADDLW  08
01738:  MOVLB  0
0173A:  GOTO   1A94
....................                      {
....................                         case 1:
....................                            Inputt.B1 = 1; 
0173E:  MOVLB  7
01740:  BSF    x3E.0
....................                         break;
01742:  BRA    1770
....................                         case 2:
....................                            Inputt.B2 = 1; 
01744:  MOVLB  7
01746:  BSF    x3E.1
....................                         break;
01748:  BRA    1770
....................                         case 3:
....................                            Inputt.B3 = 1; 
0174A:  MOVLB  7
0174C:  BSF    x3E.2
....................                         break;
0174E:  BRA    1770
....................                         case 4:
....................                            Inputt.B4 = 1; 
01750:  MOVLB  7
01752:  BSF    x3E.3
....................                         break;
01754:  BRA    1770
....................                         case 5:
....................                            Inputt.B5 = 1; 
01756:  MOVLB  7
01758:  BSF    x3E.4
....................                         break;
0175A:  BRA    1770
....................                         case 6:
....................                            Inputt.B6 = 1; 
0175C:  MOVLB  7
0175E:  BSF    x3E.5
....................                         break;
01760:  BRA    1770
....................                         case 7:
....................                            Inputt.B7 = 1; 
01762:  MOVLB  7
01764:  BSF    x3E.6
....................                          break;
01766:  BRA    1770
....................                          case 8:
....................                            Inputt.B8 = 1; 
01768:  MOVLB  7
0176A:  BSF    x3E.7
....................                         break;
0176C:  BRA    1770
0176E:  MOVLB  7
....................          
....................                      }                 
....................                    }
....................                }
01770:  BRA    178C
01772:  MOVLB  0
....................                else
....................                {
....................                   ReleaseTime[i] = 0;
01774:  BCF    FD8.0
01776:  MOVLB  7
01778:  RLCF   xB9,W
0177A:  CLRF   03
0177C:  ADDLW  53
0177E:  MOVWF  FE9
01780:  MOVLW  07
01782:  ADDWFC 03,W
01784:  MOVWF  FEA
01786:  CLRF   FEC
01788:  MOVF   FED,F
0178A:  CLRF   FEF
....................                }
....................              
.................... 
....................              }
....................           }
0178C:  BRA    19DE
....................           else if(FaultNCNO[i] ==NC)
0178E:  MOVFF  7B9,7BD
01792:  MOVLW  07
01794:  MOVLB  7
01796:  MOVWF  xBF
01798:  MOVLW  A4
0179A:  MOVWF  xBE
0179C:  MOVLB  0
0179E:  RCALL  1374
017A0:  MOVF   01,W
017A2:  ANDLW  01
017A4:  BTFSS  FD8.2
017A6:  BRA    19E0
....................           {
....................              if(FaultNow[i]==1)
017A8:  MOVFF  7B9,7BD
017AC:  MOVLW  07
017AE:  MOVLB  7
017B0:  MOVWF  xBF
017B2:  MOVLW  50
017B4:  MOVWF  xBE
017B6:  MOVLB  0
017B8:  RCALL  1374
017BA:  MOVF   01,W
017BC:  ANDLW  01
017BE:  SUBLW  01
017C0:  BTFSS  FD8.2
017C2:  BRA    18D4
....................              {
....................                if(FaultAgo[i]==1)
017C4:  MOVFF  7B9,7BD
017C8:  MOVLW  07
017CA:  MOVLB  7
017CC:  MOVWF  xBF
017CE:  MOVLW  4D
017D0:  MOVWF  xBE
017D2:  MOVLB  0
017D4:  RCALL  1374
017D6:  MOVF   01,W
017D8:  ANDLW  01
017DA:  SUBLW  01
017DC:  BTFSS  FD8.2
017DE:  BRA    18B8
....................                {
....................                    ReleaseTime[i]++;
017E0:  BCF    FD8.0
017E2:  MOVLB  7
017E4:  RLCF   xB9,W
017E6:  CLRF   03
017E8:  ADDLW  53
017EA:  MOVWF  FE9
017EC:  MOVLW  07
017EE:  ADDWFC 03,W
017F0:  MOVWF  FEA
017F2:  MOVLW  01
017F4:  ADDWF  FEE,F
017F6:  BNC   17FA
017F8:  INCF   FEF,F
....................                    if(ReleaseTime[i]>=((FaultDelayTime[i]*75)+15)) //time per loop are 368 microSec. (1.89*10=200ms)
017FA:  BCF    FD8.0
017FC:  RLCF   xB9,W
017FE:  CLRF   03
01800:  ADDLW  53
01802:  MOVWF  FE9
01804:  MOVLW  07
01806:  ADDWFC 03,W
01808:  MOVWF  FEA
0180A:  MOVFF  FEC,7BB
0180E:  MOVF   FED,F
01810:  MOVFF  FEF,7BA
01814:  BCF    FD8.0
01816:  RLCF   xB9,W
01818:  CLRF   03
0181A:  ADDLW  7B
0181C:  MOVWF  FE9
0181E:  MOVLW  07
01820:  ADDWFC 03,W
01822:  MOVWF  FEA
01824:  MOVFF  FEC,7BF
01828:  MOVF   FED,F
0182A:  MOVFF  FEF,7BE
0182E:  CLRF   xC1
01830:  MOVLW  4B
01832:  MOVWF  xC0
01834:  MOVLB  0
01836:  RCALL  13AA
01838:  MOVFF  02,7BD
0183C:  MOVFF  01,7BC
01840:  MOVLW  0F
01842:  MOVLB  7
01844:  ADDWF  01,W
01846:  MOVWF  01
01848:  MOVLW  00
0184A:  ADDWFC 02,W
0184C:  MOVWF  03
0184E:  MOVF   03,W
01850:  SUBWF  xBB,W
01852:  BNC   18B4
01854:  BNZ   185C
01856:  MOVF   01,W
01858:  SUBWF  xBA,W
0185A:  BNC   18B4
....................                    {   
....................                      ReleaseTime[i] = 0;
0185C:  BCF    FD8.0
0185E:  RLCF   xB9,W
01860:  CLRF   03
01862:  ADDLW  53
01864:  MOVWF  FE9
01866:  MOVLW  07
01868:  ADDWFC 03,W
0186A:  MOVWF  FEA
0186C:  CLRF   FEC
0186E:  MOVF   FED,F
01870:  CLRF   FEF
....................                      switch(i)
01872:  MOVLW  01
01874:  SUBWF  xB9,W
01876:  ADDLW  F8
01878:  BC    18B4
0187A:  ADDLW  08
0187C:  MOVLB  0
0187E:  GOTO   1ABE
....................                      {
....................                         case 1:
....................                            Inputt.B1 = 1; 
01882:  MOVLB  7
01884:  BSF    x3E.0
....................                         break;
01886:  BRA    18B4
....................                         case 2:
....................                            Inputt.B2 = 1; 
01888:  MOVLB  7
0188A:  BSF    x3E.1
....................                         break;
0188C:  BRA    18B4
....................                         case 3:
....................                            Inputt.B3 = 1; 
0188E:  MOVLB  7
01890:  BSF    x3E.2
....................                         break;
01892:  BRA    18B4
....................                         case 4:
....................                            Inputt.B4 = 1; 
01894:  MOVLB  7
01896:  BSF    x3E.3
....................                         break;
01898:  BRA    18B4
....................                         case 5:
....................                            Inputt.B5 = 1; 
0189A:  MOVLB  7
0189C:  BSF    x3E.4
....................                         break;
0189E:  BRA    18B4
....................                         case 6:
....................                            Inputt.B6 = 1; 
018A0:  MOVLB  7
018A2:  BSF    x3E.5
....................                         break;
018A4:  BRA    18B4
....................                         case 7:
....................                            Inputt.B7 = 1; 
018A6:  MOVLB  7
018A8:  BSF    x3E.6
....................                          break;
018AA:  BRA    18B4
....................                          case 8:
....................                            Inputt.B8 = 1; 
018AC:  MOVLB  7
018AE:  BSF    x3E.7
....................                         break;
018B0:  BRA    18B4
018B2:  MOVLB  7
....................                                            
....................                      }                 
....................                   }
....................                }
018B4:  BRA    18D0
018B6:  MOVLB  0
....................                else
....................                {
....................                   ReleaseTime[i] = 0;
018B8:  BCF    FD8.0
018BA:  MOVLB  7
018BC:  RLCF   xB9,W
018BE:  CLRF   03
018C0:  ADDLW  53
018C2:  MOVWF  FE9
018C4:  MOVLW  07
018C6:  ADDWFC 03,W
018C8:  MOVWF  FEA
018CA:  CLRF   FEC
018CC:  MOVF   FED,F
018CE:  CLRF   FEF
....................                }
....................              }
018D0:  BRA    19DE
018D2:  MOVLB  0
....................              else //if(FaultNow[i]==0
....................              {
....................                if(FaultAgo[i]==0)
018D4:  MOVFF  7B9,7BD
018D8:  MOVLW  07
018DA:  MOVLB  7
018DC:  MOVWF  xBF
018DE:  MOVLW  4D
018E0:  MOVWF  xBE
018E2:  MOVLB  0
018E4:  RCALL  1374
018E6:  MOVF   01,W
018E8:  ANDLW  01
018EA:  BTFSS  FD8.2
018EC:  BRA    19C6
....................                {
....................                    ReleaseTime[i]++;
018EE:  BCF    FD8.0
018F0:  MOVLB  7
018F2:  RLCF   xB9,W
018F4:  CLRF   03
018F6:  ADDLW  53
018F8:  MOVWF  FE9
018FA:  MOVLW  07
018FC:  ADDWFC 03,W
018FE:  MOVWF  FEA
01900:  MOVLW  01
01902:  ADDWF  FEE,F
01904:  BNC   1908
01906:  INCF   FEF,F
....................                   
....................                    if(ReleaseTime[i]>=((FaultDelayTime[i]*75)+15)) //time per loop are 368 microSec. (1.89*10=200ms)
01908:  BCF    FD8.0
0190A:  RLCF   xB9,W
0190C:  CLRF   03
0190E:  ADDLW  53
01910:  MOVWF  FE9
01912:  MOVLW  07
01914:  ADDWFC 03,W
01916:  MOVWF  FEA
01918:  MOVFF  FEC,7BB
0191C:  MOVF   FED,F
0191E:  MOVFF  FEF,7BA
01922:  BCF    FD8.0
01924:  RLCF   xB9,W
01926:  CLRF   03
01928:  ADDLW  7B
0192A:  MOVWF  FE9
0192C:  MOVLW  07
0192E:  ADDWFC 03,W
01930:  MOVWF  FEA
01932:  MOVFF  FEC,7BF
01936:  MOVF   FED,F
01938:  MOVFF  FEF,7BE
0193C:  CLRF   xC1
0193E:  MOVLW  4B
01940:  MOVWF  xC0
01942:  MOVLB  0
01944:  RCALL  13AA
01946:  MOVFF  02,7BD
0194A:  MOVFF  01,7BC
0194E:  MOVLW  0F
01950:  MOVLB  7
01952:  ADDWF  01,W
01954:  MOVWF  01
01956:  MOVLW  00
01958:  ADDWFC 02,W
0195A:  MOVWF  03
0195C:  MOVF   03,W
0195E:  SUBWF  xBB,W
01960:  BNC   19C2
01962:  BNZ   196A
01964:  MOVF   01,W
01966:  SUBWF  xBA,W
01968:  BNC   19C2
....................                    {   
....................                      ReleaseTime[i] = 0;
0196A:  BCF    FD8.0
0196C:  RLCF   xB9,W
0196E:  CLRF   03
01970:  ADDLW  53
01972:  MOVWF  FE9
01974:  MOVLW  07
01976:  ADDWFC 03,W
01978:  MOVWF  FEA
0197A:  CLRF   FEC
0197C:  MOVF   FED,F
0197E:  CLRF   FEF
....................                      switch(i)
01980:  MOVLW  01
01982:  SUBWF  xB9,W
01984:  ADDLW  F8
01986:  BC    19C2
01988:  ADDLW  08
0198A:  MOVLB  0
0198C:  GOTO   1AE8
....................                      {
....................                         case 1:
....................                            Inputt.B1 = 0; 
01990:  MOVLB  7
01992:  BCF    x3E.0
....................                         break;
01994:  BRA    19C2
....................                         case 2:
....................                            Inputt.B2 = 0; 
01996:  MOVLB  7
01998:  BCF    x3E.1
....................                         break;
0199A:  BRA    19C2
....................                         case 3:
....................                            Inputt.B3 = 0; 
0199C:  MOVLB  7
0199E:  BCF    x3E.2
....................                         break;
019A0:  BRA    19C2
....................                         case 4:
....................                            Inputt.B4 = 0; 
019A2:  MOVLB  7
019A4:  BCF    x3E.3
....................                         break;
019A6:  BRA    19C2
....................                         case 5:
....................                            Inputt.B5 = 0; 
019A8:  MOVLB  7
019AA:  BCF    x3E.4
....................                         break;
019AC:  BRA    19C2
....................                         case 6:
....................                            Inputt.B6 = 0; 
019AE:  MOVLB  7
019B0:  BCF    x3E.5
....................                         break;
019B2:  BRA    19C2
....................                         case 7:
....................                            Inputt.B7 = 0; 
019B4:  MOVLB  7
019B6:  BCF    x3E.6
....................                          break;
019B8:  BRA    19C2
....................                          case 8:
....................                            Inputt.B8 = 0; 
019BA:  MOVLB  7
019BC:  BCF    x3E.7
....................                         break;
019BE:  BRA    19C2
019C0:  MOVLB  7
....................               
....................                      }                 
....................                    }
....................                }
019C2:  BRA    19DE
019C4:  MOVLB  0
....................                else
....................                {
....................                   ReleaseTime[i] = 0;
019C6:  BCF    FD8.0
019C8:  MOVLB  7
019CA:  RLCF   xB9,W
019CC:  CLRF   03
019CE:  ADDLW  53
019D0:  MOVWF  FE9
019D2:  MOVLW  07
019D4:  ADDWFC 03,W
019D6:  MOVWF  FEA
019D8:  CLRF   FEC
019DA:  MOVF   FED,F
019DC:  CLRF   FEF
019DE:  MOVLB  0
....................                }
.................... 
....................              }
....................           }
019E0:  MOVLB  7
019E2:  INCF   xB9,F
019E4:  BRA    1536
....................       }
....................       
....................       StoreReleaseFault();
019E6:  MOVLB  0
019E8:  BRA    1410
.................... 
....................    
....................       Input1_8 = 0x00;
019EA:  CLRF   4B
....................       Input1_8 = Input1_8 | ~Inputt.B8;
019EC:  MOVLW  00
019EE:  MOVLB  7
019F0:  BTFSS  x3E.7
019F2:  MOVLW  01
019F4:  IORWF  4B,F
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B7;
019F6:  BCF    FD8.0
019F8:  RLCF   4B,W
019FA:  MOVWF  xBA
019FC:  MOVLW  00
019FE:  BTFSS  x3E.6
01A00:  MOVLW  01
01A02:  IORWF  xBA,W
01A04:  MOVWF  4B
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B6;
01A06:  BCF    FD8.0
01A08:  RLCF   4B,W
01A0A:  MOVWF  xBA
01A0C:  MOVLW  00
01A0E:  BTFSS  x3E.5
01A10:  MOVLW  01
01A12:  IORWF  xBA,W
01A14:  MOVWF  4B
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B5;
01A16:  BCF    FD8.0
01A18:  RLCF   4B,W
01A1A:  MOVWF  xBA
01A1C:  MOVLW  00
01A1E:  BTFSS  x3E.4
01A20:  MOVLW  01
01A22:  IORWF  xBA,W
01A24:  MOVWF  4B
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B4;
01A26:  BCF    FD8.0
01A28:  RLCF   4B,W
01A2A:  MOVWF  xBA
01A2C:  MOVLW  00
01A2E:  BTFSS  x3E.3
01A30:  MOVLW  01
01A32:  IORWF  xBA,W
01A34:  MOVWF  4B
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B3;
01A36:  BCF    FD8.0
01A38:  RLCF   4B,W
01A3A:  MOVWF  xBA
01A3C:  MOVLW  00
01A3E:  BTFSS  x3E.2
01A40:  MOVLW  01
01A42:  IORWF  xBA,W
01A44:  MOVWF  4B
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B2;
01A46:  BCF    FD8.0
01A48:  RLCF   4B,W
01A4A:  MOVWF  xBA
01A4C:  MOVLW  00
01A4E:  BTFSS  x3E.1
01A50:  MOVLW  01
01A52:  IORWF  xBA,W
01A54:  MOVWF  4B
....................       Input1_8 = (Input1_8 << 1) | ~Inputt.B1;
01A56:  BCF    FD8.0
01A58:  RLCF   4B,W
01A5A:  MOVWF  xBA
01A5C:  MOVLW  00
01A5E:  BTFSS  x3E.0
01A60:  MOVLW  01
01A62:  IORWF  xBA,W
01A64:  MOVWF  4B
01A66:  MOVLB  0
01A68:  RETURN 0
....................     
.................... 
....................    
.................... }
.................... /*----------------------------------------------------------------------------*/
.................... /*----------------------------------------------------------------------------*/
.................... 
.................... 
.................... void Read_Config(void)
.................... {
....................    
.................... 
....................    EEpDat = read_eeprom(0x01);   // Inputt type 1-8
*
00780:  MOVFF  FF2,7BA
00784:  BCF    FF2.7
00786:  CLRF   FAA
00788:  MOVLW  01
0078A:  MOVWF  FA9
0078C:  BCF    FA6.6
0078E:  BCF    FA6.7
00790:  BSF    FA6.0
00792:  MOVF   FA8,W
00794:  MOVLB  7
00796:  BTFSC  xBA.7
00798:  BSF    FF2.7
0079A:  MOVWF  3B
....................    InputType1_8 = EEpDat;
0079C:  MOVFF  3B,3C
.................... 
....................    InputType.B1 = EEpDat;
007A0:  BCF    x40.0
007A2:  BTFSC  3B.0
007A4:  BSF    x40.0
....................    InputType.B2 = EEpDat >> 1;
007A6:  BCF    FD8.0
007A8:  RRCF   3B,W
007AA:  BCF    x40.1
007AC:  BTFSC  FE8.0
007AE:  BSF    x40.1
....................    InputType.B3 = EEpDat >> 2;
007B0:  RRCF   3B,W
007B2:  MOVWF  00
007B4:  RRCF   00,F
007B6:  MOVLW  3F
007B8:  ANDWF  00,F
007BA:  BCF    x40.2
007BC:  BTFSC  00.0
007BE:  BSF    x40.2
....................    InputType.B4 = EEpDat >> 3;
007C0:  RRCF   3B,W
007C2:  MOVWF  00
007C4:  RRCF   00,F
007C6:  RRCF   00,F
007C8:  MOVLW  1F
007CA:  ANDWF  00,F
007CC:  BCF    x40.3
007CE:  BTFSC  00.0
007D0:  BSF    x40.3
....................    InputType.B5 = EEpDat >> 4;
007D2:  SWAPF  3B,W
007D4:  MOVWF  00
007D6:  MOVLW  0F
007D8:  ANDWF  00,F
007DA:  BCF    x40.4
007DC:  BTFSC  00.0
007DE:  BSF    x40.4
....................    InputType.B6 = EEpDat >> 5;
007E0:  SWAPF  3B,W
007E2:  MOVWF  00
007E4:  RRCF   00,F
007E6:  MOVLW  07
007E8:  ANDWF  00,F
007EA:  BCF    x40.5
007EC:  BTFSC  00.0
007EE:  BSF    x40.5
....................    InputType.B7 = EEpDat >> 6;
007F0:  SWAPF  3B,W
007F2:  MOVWF  00
007F4:  RRCF   00,F
007F6:  RRCF   00,F
007F8:  MOVLW  03
007FA:  ANDWF  00,F
007FC:  BCF    x40.6
007FE:  BTFSC  00.0
00800:  BSF    x40.6
....................    InputType.B8 = EEpDat >> 7;
00802:  CLRF   00
00804:  BTFSC  3B.7
00806:  BSF    00.0
00808:  BCF    x40.7
0080A:  BTFSC  00.0
0080C:  BSF    x40.7
.................... 
....................    FaultNCNO[1] = InputType.B1;
0080E:  BCF    xA4.1
00810:  BTFSC  x40.0
00812:  BSF    xA4.1
....................    FaultNCNO[2] = InputType.B2;
00814:  BCF    xA4.2
00816:  BTFSC  x40.1
00818:  BSF    xA4.2
....................    FaultNCNO[3] = InputType.B3;
0081A:  BCF    xA4.3
0081C:  BTFSC  x40.2
0081E:  BSF    xA4.3
....................    FaultNCNO[4] = InputType.B4;
00820:  BCF    xA4.4
00822:  BTFSC  x40.3
00824:  BSF    xA4.4
....................    FaultNCNO[5] = InputType.B5;
00826:  BCF    xA4.5
00828:  BTFSC  x40.4
0082A:  BSF    xA4.5
....................    FaultNCNO[6] = InputType.B6;
0082C:  BCF    xA4.6
0082E:  BTFSC  x40.5
00830:  BSF    xA4.6
....................    FaultNCNO[7] = InputType.B7;
00832:  BCF    xA4.7
00834:  BTFSC  x40.6
00836:  BSF    xA4.7
....................    FaultNCNO[8] = InputType.B8;
00838:  BCF    xA5.0
0083A:  BTFSC  x40.7
0083C:  BSF    xA5.0
....................   
....................    ////////////////////////////////////////
.................... 
....................    EEpDat = read_eeprom(0x04);   // Fault type 1-8
0083E:  MOVFF  FF2,7BA
00842:  BCF    FF2.7
00844:  CLRF   FAA
00846:  MOVLW  04
00848:  MOVWF  FA9
0084A:  BCF    FA6.6
0084C:  BCF    FA6.7
0084E:  BSF    FA6.0
00850:  MOVF   FA8,W
00852:  BTFSC  xBA.7
00854:  BSF    FF2.7
00856:  MOVWF  3B
....................    FaultType1_8 = EEpDat;
00858:  MOVFF  3B,3F
.................... 
....................    FaultType.B1 = EEpDat;
0085C:  BCF    x41.0
0085E:  BTFSC  3B.0
00860:  BSF    x41.0
....................    FaultType.B2 = EEpDat >> 1;
00862:  BCF    FD8.0
00864:  RRCF   3B,W
00866:  BCF    x41.1
00868:  BTFSC  FE8.0
0086A:  BSF    x41.1
....................    FaultType.B3 = EEpDat >> 2;
0086C:  RRCF   3B,W
0086E:  MOVWF  00
00870:  RRCF   00,F
00872:  MOVLW  3F
00874:  ANDWF  00,F
00876:  BCF    x41.2
00878:  BTFSC  00.0
0087A:  BSF    x41.2
....................    FaultType.B4 = EEpDat >> 3;
0087C:  RRCF   3B,W
0087E:  MOVWF  00
00880:  RRCF   00,F
00882:  RRCF   00,F
00884:  MOVLW  1F
00886:  ANDWF  00,F
00888:  BCF    x41.3
0088A:  BTFSC  00.0
0088C:  BSF    x41.3
....................    FaultType.B5 = EEpDat >> 4;
0088E:  SWAPF  3B,W
00890:  MOVWF  00
00892:  MOVLW  0F
00894:  ANDWF  00,F
00896:  BCF    x41.4
00898:  BTFSC  00.0
0089A:  BSF    x41.4
....................    FaultType.B6 = EEpDat >> 5;
0089C:  SWAPF  3B,W
0089E:  MOVWF  00
008A0:  RRCF   00,F
008A2:  MOVLW  07
008A4:  ANDWF  00,F
008A6:  BCF    x41.5
008A8:  BTFSC  00.0
008AA:  BSF    x41.5
....................    FaultType.B7 = EEpDat >> 6;
008AC:  SWAPF  3B,W
008AE:  MOVWF  00
008B0:  RRCF   00,F
008B2:  RRCF   00,F
008B4:  MOVLW  03
008B6:  ANDWF  00,F
008B8:  BCF    x41.6
008BA:  BTFSC  00.0
008BC:  BSF    x41.6
....................    FaultType.B8 = EEpDat >> 7;
008BE:  CLRF   00
008C0:  BTFSC  3B.7
008C2:  BSF    00.0
008C4:  BCF    x41.7
008C6:  BTFSC  00.0
008C8:  BSF    x41.7
.................... 
.................... 
....................    ////////////////////////////////////////////////
.................... 
....................    EEpDat = read_eeprom(0x07);   // Output type 1-8
008CA:  MOVFF  FF2,7BA
008CE:  BCF    FF2.7
008D0:  CLRF   FAA
008D2:  MOVLW  07
008D4:  MOVWF  FA9
008D6:  BCF    FA6.6
008D8:  BCF    FA6.7
008DA:  BSF    FA6.0
008DC:  MOVF   FA8,W
008DE:  BTFSC  xBA.7
008E0:  BSF    FF2.7
008E2:  MOVWF  3B
....................    OutputType1_8 = EEpDat;
008E4:  MOVFF  3B,42
.................... 
....................    OutputType.B1 = EEpDat;
008E8:  BCF    x42.0
008EA:  BTFSC  3B.0
008EC:  BSF    x42.0
....................    OutputType.B2 = EEpDat >> 1;
008EE:  BCF    FD8.0
008F0:  RRCF   3B,W
008F2:  BCF    x42.1
008F4:  BTFSC  FE8.0
008F6:  BSF    x42.1
....................    OutputType.B3 = EEpDat >> 2;
008F8:  RRCF   3B,W
008FA:  MOVWF  00
008FC:  RRCF   00,F
008FE:  MOVLW  3F
00900:  ANDWF  00,F
00902:  BCF    x42.2
00904:  BTFSC  00.0
00906:  BSF    x42.2
....................    OutputType.B4 = EEpDat >> 3;
00908:  RRCF   3B,W
0090A:  MOVWF  00
0090C:  RRCF   00,F
0090E:  RRCF   00,F
00910:  MOVLW  1F
00912:  ANDWF  00,F
00914:  BCF    x42.3
00916:  BTFSC  00.0
00918:  BSF    x42.3
....................    OutputType.B5 = EEpDat >> 4;
0091A:  SWAPF  3B,W
0091C:  MOVWF  00
0091E:  MOVLW  0F
00920:  ANDWF  00,F
00922:  BCF    x42.4
00924:  BTFSC  00.0
00926:  BSF    x42.4
....................    OutputType.B6 = EEpDat >> 5;
00928:  SWAPF  3B,W
0092A:  MOVWF  00
0092C:  RRCF   00,F
0092E:  MOVLW  07
00930:  ANDWF  00,F
00932:  BCF    x42.5
00934:  BTFSC  00.0
00936:  BSF    x42.5
....................    OutputType.B7 = EEpDat >> 6;
00938:  SWAPF  3B,W
0093A:  MOVWF  00
0093C:  RRCF   00,F
0093E:  RRCF   00,F
00940:  MOVLW  03
00942:  ANDWF  00,F
00944:  BCF    x42.6
00946:  BTFSC  00.0
00948:  BSF    x42.6
....................    OutputType.B8 = EEpDat >> 7;
0094A:  CLRF   00
0094C:  BTFSC  3B.7
0094E:  BSF    00.0
00950:  BCF    x42.7
00952:  BTFSC  00.0
00954:  BSF    x42.7
.................... 
.................... 
....................    ////////////////////////////////////////
.................... 
....................    EEpDat = read_eeprom(0x0A);   // Output Both 1-8
00956:  MOVFF  FF2,7BA
0095A:  BCF    FF2.7
0095C:  CLRF   FAA
0095E:  MOVLW  0A
00960:  MOVWF  FA9
00962:  BCF    FA6.6
00964:  BCF    FA6.7
00966:  BSF    FA6.0
00968:  MOVF   FA8,W
0096A:  BTFSC  xBA.7
0096C:  BSF    FF2.7
0096E:  MOVWF  3B
....................    OutputBoth1_8 = EEpDat;
00970:  MOVFF  3B,45
.................... 
....................    OutputBoth.B1 = EEpDat;
00974:  BCF    x43.0
00976:  BTFSC  3B.0
00978:  BSF    x43.0
....................    OutputBoth.B2 = EEpDat >> 1;
0097A:  BCF    FD8.0
0097C:  RRCF   3B,W
0097E:  BCF    x43.1
00980:  BTFSC  FE8.0
00982:  BSF    x43.1
....................    OutputBoth.B3 = EEpDat >> 2;
00984:  RRCF   3B,W
00986:  MOVWF  00
00988:  RRCF   00,F
0098A:  MOVLW  3F
0098C:  ANDWF  00,F
0098E:  BCF    x43.2
00990:  BTFSC  00.0
00992:  BSF    x43.2
....................    OutputBoth.B4 = EEpDat >> 3;
00994:  RRCF   3B,W
00996:  MOVWF  00
00998:  RRCF   00,F
0099A:  RRCF   00,F
0099C:  MOVLW  1F
0099E:  ANDWF  00,F
009A0:  BCF    x43.3
009A2:  BTFSC  00.0
009A4:  BSF    x43.3
....................    OutputBoth.B5 = EEpDat >> 4;
009A6:  SWAPF  3B,W
009A8:  MOVWF  00
009AA:  MOVLW  0F
009AC:  ANDWF  00,F
009AE:  BCF    x43.4
009B0:  BTFSC  00.0
009B2:  BSF    x43.4
....................    OutputBoth.B6 = EEpDat >> 5;
009B4:  SWAPF  3B,W
009B6:  MOVWF  00
009B8:  RRCF   00,F
009BA:  MOVLW  07
009BC:  ANDWF  00,F
009BE:  BCF    x43.5
009C0:  BTFSC  00.0
009C2:  BSF    x43.5
....................    OutputBoth.B7 = EEpDat >> 6;
009C4:  SWAPF  3B,W
009C6:  MOVWF  00
009C8:  RRCF   00,F
009CA:  RRCF   00,F
009CC:  MOVLW  03
009CE:  ANDWF  00,F
009D0:  BCF    x43.6
009D2:  BTFSC  00.0
009D4:  BSF    x43.6
....................    OutputBoth.B8 = EEpDat >> 7;
009D6:  CLRF   00
009D8:  BTFSC  3B.7
009DA:  BSF    00.0
009DC:  BCF    x43.7
009DE:  BTFSC  00.0
009E0:  BSF    x43.7
.................... 
.................... 
....................    /////////////////////////////////////////////////
.................... 
....................    EEpDat = read_eeprom(0x0D);   // AlarmIndicator 1-8
009E2:  MOVFF  FF2,7BA
009E6:  BCF    FF2.7
009E8:  CLRF   FAA
009EA:  MOVLW  0D
009EC:  MOVWF  FA9
009EE:  BCF    FA6.6
009F0:  BCF    FA6.7
009F2:  BSF    FA6.0
009F4:  MOVF   FA8,W
009F6:  BTFSC  xBA.7
009F8:  BSF    FF2.7
009FA:  MOVWF  3B
....................    Alarm_Indicator1_8 = EEpDat;
009FC:  MOVFF  3B,48
.................... 
....................    AlarmIndicator.B1 = EEpDat;
00A00:  BCF    x44.0
00A02:  BTFSC  3B.0
00A04:  BSF    x44.0
....................    AlarmIndicator.B2 = EEpDat >> 1;
00A06:  BCF    FD8.0
00A08:  RRCF   3B,W
00A0A:  BCF    x44.1
00A0C:  BTFSC  FE8.0
00A0E:  BSF    x44.1
....................    AlarmIndicator.B3 = EEpDat >> 2;
00A10:  RRCF   3B,W
00A12:  MOVWF  00
00A14:  RRCF   00,F
00A16:  MOVLW  3F
00A18:  ANDWF  00,F
00A1A:  BCF    x44.2
00A1C:  BTFSC  00.0
00A1E:  BSF    x44.2
....................    AlarmIndicator.B4 = EEpDat >> 3;
00A20:  RRCF   3B,W
00A22:  MOVWF  00
00A24:  RRCF   00,F
00A26:  RRCF   00,F
00A28:  MOVLW  1F
00A2A:  ANDWF  00,F
00A2C:  BCF    x44.3
00A2E:  BTFSC  00.0
00A30:  BSF    x44.3
....................    AlarmIndicator.B5 = EEpDat >> 4;
00A32:  SWAPF  3B,W
00A34:  MOVWF  00
00A36:  MOVLW  0F
00A38:  ANDWF  00,F
00A3A:  BCF    x44.4
00A3C:  BTFSC  00.0
00A3E:  BSF    x44.4
....................    AlarmIndicator.B6 = EEpDat >> 5;
00A40:  SWAPF  3B,W
00A42:  MOVWF  00
00A44:  RRCF   00,F
00A46:  MOVLW  07
00A48:  ANDWF  00,F
00A4A:  BCF    x44.5
00A4C:  BTFSC  00.0
00A4E:  BSF    x44.5
....................    AlarmIndicator.B7 = EEpDat >> 6;
00A50:  SWAPF  3B,W
00A52:  MOVWF  00
00A54:  RRCF   00,F
00A56:  RRCF   00,F
00A58:  MOVLW  03
00A5A:  ANDWF  00,F
00A5C:  BCF    x44.6
00A5E:  BTFSC  00.0
00A60:  BSF    x44.6
....................    AlarmIndicator.B8 = EEpDat >> 7;
00A62:  CLRF   00
00A64:  BTFSC  3B.7
00A66:  BSF    00.0
00A68:  BCF    x44.7
00A6A:  BTFSC  00.0
00A6C:  BSF    x44.7
.................... 
....................    //////////////////////////////////////////////////
....................    EEpDat = read_eeprom(0x10);
00A6E:  MOVFF  FF2,7BA
00A72:  BCF    FF2.7
00A74:  CLRF   FAA
00A76:  MOVLW  10
00A78:  MOVWF  FA9
00A7A:  BCF    FA6.6
00A7C:  BCF    FA6.7
00A7E:  BSF    FA6.0
00A80:  MOVF   FA8,W
00A82:  BTFSC  xBA.7
00A84:  BSF    FF2.7
00A86:  MOVWF  3B
....................    //Red1_8 = EEpDat;
....................    RED_Colour.B1 = EEpDat;
00A88:  BCF    x4A.0
00A8A:  BTFSC  3B.0
00A8C:  BSF    x4A.0
....................    RED_Colour.B2 = EEpDat >> 1;
00A8E:  BCF    FD8.0
00A90:  RRCF   3B,W
00A92:  BCF    x4A.1
00A94:  BTFSC  FE8.0
00A96:  BSF    x4A.1
....................    RED_Colour.B3 = EEpDat >> 2;
00A98:  RRCF   3B,W
00A9A:  MOVWF  00
00A9C:  RRCF   00,F
00A9E:  MOVLW  3F
00AA0:  ANDWF  00,F
00AA2:  BCF    x4A.2
00AA4:  BTFSC  00.0
00AA6:  BSF    x4A.2
....................    RED_Colour.B4 = EEpDat >> 3;
00AA8:  RRCF   3B,W
00AAA:  MOVWF  00
00AAC:  RRCF   00,F
00AAE:  RRCF   00,F
00AB0:  MOVLW  1F
00AB2:  ANDWF  00,F
00AB4:  BCF    x4A.3
00AB6:  BTFSC  00.0
00AB8:  BSF    x4A.3
....................    RED_Colour.B5 = EEpDat >> 4;
00ABA:  SWAPF  3B,W
00ABC:  MOVWF  00
00ABE:  MOVLW  0F
00AC0:  ANDWF  00,F
00AC2:  BCF    x4A.4
00AC4:  BTFSC  00.0
00AC6:  BSF    x4A.4
....................    RED_Colour.B6 = EEpDat >> 5;
00AC8:  SWAPF  3B,W
00ACA:  MOVWF  00
00ACC:  RRCF   00,F
00ACE:  MOVLW  07
00AD0:  ANDWF  00,F
00AD2:  BCF    x4A.5
00AD4:  BTFSC  00.0
00AD6:  BSF    x4A.5
....................    RED_Colour.B7 = EEpDat >> 6;
00AD8:  SWAPF  3B,W
00ADA:  MOVWF  00
00ADC:  RRCF   00,F
00ADE:  RRCF   00,F
00AE0:  MOVLW  03
00AE2:  ANDWF  00,F
00AE4:  BCF    x4A.6
00AE6:  BTFSC  00.0
00AE8:  BSF    x4A.6
....................    RED_Colour.B8 = EEpDat >> 7;
00AEA:  CLRF   00
00AEC:  BTFSC  3B.7
00AEE:  BSF    00.0
00AF0:  BCF    x4A.7
00AF2:  BTFSC  00.0
00AF4:  BSF    x4A.7
....................     
....................    EEpDat = read_eeprom(0x14);
00AF6:  MOVFF  FF2,7BA
00AFA:  BCF    FF2.7
00AFC:  CLRF   FAA
00AFE:  MOVLW  14
00B00:  MOVWF  FA9
00B02:  BCF    FA6.6
00B04:  BCF    FA6.7
00B06:  BSF    FA6.0
00B08:  MOVF   FA8,W
00B0A:  BTFSC  xBA.7
00B0C:  BSF    FF2.7
00B0E:  MOVWF  3B
....................    //Green1_8 = EEpDat;
....................    GREEN_Colour.B1 = EEpDat;
00B10:  BCF    x4B.0
00B12:  BTFSC  3B.0
00B14:  BSF    x4B.0
....................    GREEN_Colour.B2 = EEpDat >> 1;
00B16:  BCF    FD8.0
00B18:  RRCF   3B,W
00B1A:  BCF    x4B.1
00B1C:  BTFSC  FE8.0
00B1E:  BSF    x4B.1
....................    GREEN_Colour.B3 = EEpDat >> 2;
00B20:  RRCF   3B,W
00B22:  MOVWF  00
00B24:  RRCF   00,F
00B26:  MOVLW  3F
00B28:  ANDWF  00,F
00B2A:  BCF    x4B.2
00B2C:  BTFSC  00.0
00B2E:  BSF    x4B.2
....................    GREEN_Colour.B4 = EEpDat >> 3;
00B30:  RRCF   3B,W
00B32:  MOVWF  00
00B34:  RRCF   00,F
00B36:  RRCF   00,F
00B38:  MOVLW  1F
00B3A:  ANDWF  00,F
00B3C:  BCF    x4B.3
00B3E:  BTFSC  00.0
00B40:  BSF    x4B.3
....................    GREEN_Colour.B5 = EEpDat >> 4;
00B42:  SWAPF  3B,W
00B44:  MOVWF  00
00B46:  MOVLW  0F
00B48:  ANDWF  00,F
00B4A:  BCF    x4B.4
00B4C:  BTFSC  00.0
00B4E:  BSF    x4B.4
....................    GREEN_Colour.B6 = EEpDat >> 5;
00B50:  SWAPF  3B,W
00B52:  MOVWF  00
00B54:  RRCF   00,F
00B56:  MOVLW  07
00B58:  ANDWF  00,F
00B5A:  BCF    x4B.5
00B5C:  BTFSC  00.0
00B5E:  BSF    x4B.5
....................    GREEN_Colour.B7 = EEpDat >> 6;
00B60:  SWAPF  3B,W
00B62:  MOVWF  00
00B64:  RRCF   00,F
00B66:  RRCF   00,F
00B68:  MOVLW  03
00B6A:  ANDWF  00,F
00B6C:  BCF    x4B.6
00B6E:  BTFSC  00.0
00B70:  BSF    x4B.6
....................    GREEN_Colour.B8 = EEpDat >> 7;
00B72:  CLRF   00
00B74:  BTFSC  3B.7
00B76:  BSF    00.0
00B78:  BCF    x4B.7
00B7A:  BTFSC  00.0
00B7C:  BSF    x4B.7
.................... 
....................    //////////////////////////////////////////////////
.................... 
....................    AutoAck = read_eeprom(0x18);          // Auto Acknoeledge
00B7E:  MOVFF  FF2,7BA
00B82:  BCF    FF2.7
00B84:  CLRF   FAA
00B86:  MOVLW  18
00B88:  MOVWF  FA9
00B8A:  BCF    FA6.6
00B8C:  BCF    FA6.7
00B8E:  BSF    FA6.0
00B90:  MOVF   FA8,W
00B92:  BTFSC  xBA.7
00B94:  BSF    FF2.7
00B96:  MOVLB  0
00B98:  MOVWF  x6C
....................    AutoAckTime = read_eeprom(0x19);      // Auto Acknoeledge Time
00B9A:  MOVFF  FF2,7BA
00B9E:  BCF    FF2.7
00BA0:  CLRF   FAA
00BA2:  MOVLW  19
00BA4:  MOVWF  FA9
00BA6:  BCF    FA6.6
00BA8:  BCF    FA6.7
00BAA:  BSF    FA6.0
00BAC:  MOVF   FA8,W
00BAE:  MOVLB  7
00BB0:  BTFSC  xBA.7
00BB2:  BSF    FF2.7
00BB4:  MOVLB  0
00BB6:  MOVWF  x6D
....................    FlashingRateTime = FlashingRate = read_eeprom(0x1A); // Flashing rate
00BB8:  MOVFF  FF2,7BA
00BBC:  BCF    FF2.7
00BBE:  CLRF   FAA
00BC0:  MOVLW  1A
00BC2:  MOVWF  FA9
00BC4:  BCF    FA6.6
00BC6:  BCF    FA6.7
00BC8:  BSF    FA6.0
00BCA:  MOVF   FA8,W
00BCC:  MOVLB  7
00BCE:  BTFSC  xBA.7
00BD0:  BSF    FF2.7
00BD2:  MOVLB  0
00BD4:  MOVWF  x6E
00BD6:  MOVFF  6E,1D
....................    NoOfPoint = read_eeprom(0x1B);        // Number of total point
00BDA:  MOVFF  FF2,7BA
00BDE:  BCF    FF2.7
00BE0:  CLRF   FAA
00BE2:  MOVLW  1B
00BE4:  MOVWF  FA9
00BE6:  BCF    FA6.6
00BE8:  BCF    FA6.7
00BEA:  BSF    FA6.0
00BEC:  MOVF   FA8,W
00BEE:  MOVLB  7
00BF0:  BTFSC  xBA.7
00BF2:  BSF    FF2.7
00BF4:  MOVLB  0
00BF6:  MOVWF  x6F
....................    AllFaultDelayTime = read_eeprom(0x1C);  // Master or slave sync(flashing)
00BF8:  MOVFF  FF2,7BA
00BFC:  BCF    FF2.7
00BFE:  CLRF   FAA
00C00:  MOVLW  1C
00C02:  MOVWF  FA9
00C04:  BCF    FA6.6
00C06:  BCF    FA6.7
00C08:  BSF    FA6.0
00C0A:  MOVF   FA8,W
00C0C:  MOVLB  7
00C0E:  BTFSC  xBA.7
00C10:  BSF    FF2.7
00C12:  MOVWF  xA3
.................... 
....................    Address = read_eeprom(0x1D);          //Communication address
00C14:  MOVFF  FF2,7BA
00C18:  BCF    FF2.7
00C1A:  CLRF   FAA
00C1C:  MOVLW  1D
00C1E:  MOVWF  FA9
00C20:  BCF    FA6.6
00C22:  BCF    FA6.7
00C24:  BSF    FA6.0
00C26:  MOVF   FA8,W
00C28:  BTFSC  xBA.7
00C2A:  BSF    FF2.7
00C2C:  MOVLB  0
00C2E:  MOVWF  x7B
....................    
....................    FaultDelayTime[1] = read_eeprom(0x1E);
00C30:  MOVFF  FF2,7BA
00C34:  BCF    FF2.7
00C36:  CLRF   FAA
00C38:  MOVLW  1E
00C3A:  MOVWF  FA9
00C3C:  BCF    FA6.6
00C3E:  BCF    FA6.7
00C40:  BSF    FA6.0
00C42:  MOVF   FA8,W
00C44:  MOVLB  7
00C46:  BTFSC  xBA.7
00C48:  BSF    FF2.7
00C4A:  CLRF   x7E
00C4C:  MOVWF  x7D
....................    FaultDelayTime[2] = read_eeprom(0x1F);
00C4E:  MOVFF  FF2,7BA
00C52:  BCF    FF2.7
00C54:  CLRF   FAA
00C56:  MOVLW  1F
00C58:  MOVWF  FA9
00C5A:  BCF    FA6.6
00C5C:  BCF    FA6.7
00C5E:  BSF    FA6.0
00C60:  MOVF   FA8,W
00C62:  BTFSC  xBA.7
00C64:  BSF    FF2.7
00C66:  CLRF   x80
00C68:  MOVWF  x7F
....................    FaultDelayTime[3] = read_eeprom(0x20);
00C6A:  MOVFF  FF2,7BA
00C6E:  BCF    FF2.7
00C70:  CLRF   FAA
00C72:  MOVLW  20
00C74:  MOVWF  FA9
00C76:  BCF    FA6.6
00C78:  BCF    FA6.7
00C7A:  BSF    FA6.0
00C7C:  MOVF   FA8,W
00C7E:  BTFSC  xBA.7
00C80:  BSF    FF2.7
00C82:  CLRF   x82
00C84:  MOVWF  x81
....................    FaultDelayTime[4] = read_eeprom(0x21);
00C86:  MOVFF  FF2,7BA
00C8A:  BCF    FF2.7
00C8C:  CLRF   FAA
00C8E:  MOVLW  21
00C90:  MOVWF  FA9
00C92:  BCF    FA6.6
00C94:  BCF    FA6.7
00C96:  BSF    FA6.0
00C98:  MOVF   FA8,W
00C9A:  BTFSC  xBA.7
00C9C:  BSF    FF2.7
00C9E:  CLRF   x84
00CA0:  MOVWF  x83
....................    FaultDelayTime[5] = read_eeprom(0x22);
00CA2:  MOVFF  FF2,7BA
00CA6:  BCF    FF2.7
00CA8:  CLRF   FAA
00CAA:  MOVLW  22
00CAC:  MOVWF  FA9
00CAE:  BCF    FA6.6
00CB0:  BCF    FA6.7
00CB2:  BSF    FA6.0
00CB4:  MOVF   FA8,W
00CB6:  BTFSC  xBA.7
00CB8:  BSF    FF2.7
00CBA:  CLRF   x86
00CBC:  MOVWF  x85
....................    FaultDelayTime[6] = read_eeprom(0x23);
00CBE:  MOVFF  FF2,7BA
00CC2:  BCF    FF2.7
00CC4:  CLRF   FAA
00CC6:  MOVLW  23
00CC8:  MOVWF  FA9
00CCA:  BCF    FA6.6
00CCC:  BCF    FA6.7
00CCE:  BSF    FA6.0
00CD0:  MOVF   FA8,W
00CD2:  BTFSC  xBA.7
00CD4:  BSF    FF2.7
00CD6:  CLRF   x88
00CD8:  MOVWF  x87
....................    FaultDelayTime[7] = read_eeprom(0x24);
00CDA:  MOVFF  FF2,7BA
00CDE:  BCF    FF2.7
00CE0:  CLRF   FAA
00CE2:  MOVLW  24
00CE4:  MOVWF  FA9
00CE6:  BCF    FA6.6
00CE8:  BCF    FA6.7
00CEA:  BSF    FA6.0
00CEC:  MOVF   FA8,W
00CEE:  BTFSC  xBA.7
00CF0:  BSF    FF2.7
00CF2:  CLRF   x8A
00CF4:  MOVWF  x89
....................    FaultDelayTime[8] = read_eeprom(0x25);
00CF6:  MOVFF  FF2,7BA
00CFA:  BCF    FF2.7
00CFC:  CLRF   FAA
00CFE:  MOVLW  25
00D00:  MOVWF  FA9
00D02:  BCF    FA6.6
00D04:  BCF    FA6.7
00D06:  BSF    FA6.0
00D08:  MOVF   FA8,W
00D0A:  BTFSC  xBA.7
00D0C:  BSF    FF2.7
00D0E:  CLRF   x8C
00D10:  MOVWF  x8B
....................    FaultDelayTime[9] = read_eeprom(0x26);
00D12:  MOVFF  FF2,7BA
00D16:  BCF    FF2.7
00D18:  CLRF   FAA
00D1A:  MOVLW  26
00D1C:  MOVWF  FA9
00D1E:  BCF    FA6.6
00D20:  BCF    FA6.7
00D22:  BSF    FA6.0
00D24:  MOVF   FA8,W
00D26:  BTFSC  xBA.7
00D28:  BSF    FF2.7
00D2A:  CLRF   x8E
00D2C:  MOVWF  x8D
....................    FaultDelayTime[10] = read_eeprom(0x27);
00D2E:  MOVFF  FF2,7BA
00D32:  BCF    FF2.7
00D34:  CLRF   FAA
00D36:  MOVLW  27
00D38:  MOVWF  FA9
00D3A:  BCF    FA6.6
00D3C:  BCF    FA6.7
00D3E:  BSF    FA6.0
00D40:  MOVF   FA8,W
00D42:  BTFSC  xBA.7
00D44:  BSF    FF2.7
00D46:  CLRF   x90
00D48:  MOVWF  x8F
....................    FaultDelayTime[11] = read_eeprom(0x28);
00D4A:  MOVFF  FF2,7BA
00D4E:  BCF    FF2.7
00D50:  CLRF   FAA
00D52:  MOVLW  28
00D54:  MOVWF  FA9
00D56:  BCF    FA6.6
00D58:  BCF    FA6.7
00D5A:  BSF    FA6.0
00D5C:  MOVF   FA8,W
00D5E:  BTFSC  xBA.7
00D60:  BSF    FF2.7
00D62:  CLRF   x92
00D64:  MOVWF  x91
....................    FaultDelayTime[12] = read_eeprom(0x29);
00D66:  MOVFF  FF2,7BA
00D6A:  BCF    FF2.7
00D6C:  CLRF   FAA
00D6E:  MOVLW  29
00D70:  MOVWF  FA9
00D72:  BCF    FA6.6
00D74:  BCF    FA6.7
00D76:  BSF    FA6.0
00D78:  MOVF   FA8,W
00D7A:  BTFSC  xBA.7
00D7C:  BSF    FF2.7
00D7E:  CLRF   x94
00D80:  MOVWF  x93
....................    FaultDelayTime[13] = read_eeprom(0x2A);
00D82:  MOVFF  FF2,7BA
00D86:  BCF    FF2.7
00D88:  CLRF   FAA
00D8A:  MOVLW  2A
00D8C:  MOVWF  FA9
00D8E:  BCF    FA6.6
00D90:  BCF    FA6.7
00D92:  BSF    FA6.0
00D94:  MOVF   FA8,W
00D96:  BTFSC  xBA.7
00D98:  BSF    FF2.7
00D9A:  CLRF   x96
00D9C:  MOVWF  x95
....................    FaultDelayTime[14] = read_eeprom(0x2B);
00D9E:  MOVFF  FF2,7BA
00DA2:  BCF    FF2.7
00DA4:  CLRF   FAA
00DA6:  MOVLW  2B
00DA8:  MOVWF  FA9
00DAA:  BCF    FA6.6
00DAC:  BCF    FA6.7
00DAE:  BSF    FA6.0
00DB0:  MOVF   FA8,W
00DB2:  BTFSC  xBA.7
00DB4:  BSF    FF2.7
00DB6:  CLRF   x98
00DB8:  MOVWF  x97
....................    FaultDelayTime[15] = read_eeprom(0x2C);
00DBA:  MOVFF  FF2,7BA
00DBE:  BCF    FF2.7
00DC0:  CLRF   FAA
00DC2:  MOVLW  2C
00DC4:  MOVWF  FA9
00DC6:  BCF    FA6.6
00DC8:  BCF    FA6.7
00DCA:  BSF    FA6.0
00DCC:  MOVF   FA8,W
00DCE:  BTFSC  xBA.7
00DD0:  BSF    FF2.7
00DD2:  CLRF   x9A
00DD4:  MOVWF  x99
....................    FaultDelayTime[16] = read_eeprom(0x2D);
00DD6:  MOVFF  FF2,7BA
00DDA:  BCF    FF2.7
00DDC:  CLRF   FAA
00DDE:  MOVLW  2D
00DE0:  MOVWF  FA9
00DE2:  BCF    FA6.6
00DE4:  BCF    FA6.7
00DE6:  BSF    FA6.0
00DE8:  MOVF   FA8,W
00DEA:  BTFSC  xBA.7
00DEC:  BSF    FF2.7
00DEE:  CLRF   x9C
00DF0:  MOVWF  x9B
....................    FaultDelayTime[17] = read_eeprom(0x2E);
00DF2:  MOVFF  FF2,7BA
00DF6:  BCF    FF2.7
00DF8:  CLRF   FAA
00DFA:  MOVLW  2E
00DFC:  MOVWF  FA9
00DFE:  BCF    FA6.6
00E00:  BCF    FA6.7
00E02:  BSF    FA6.0
00E04:  MOVF   FA8,W
00E06:  BTFSC  xBA.7
00E08:  BSF    FF2.7
00E0A:  CLRF   x9E
00E0C:  MOVWF  x9D
....................    FaultDelayTime[18] = read_eeprom(0x2F);
00E0E:  MOVFF  FF2,7BA
00E12:  BCF    FF2.7
00E14:  CLRF   FAA
00E16:  MOVLW  2F
00E18:  MOVWF  FA9
00E1A:  BCF    FA6.6
00E1C:  BCF    FA6.7
00E1E:  BSF    FA6.0
00E20:  MOVF   FA8,W
00E22:  BTFSC  xBA.7
00E24:  BSF    FF2.7
00E26:  CLRF   xA0
00E28:  MOVWF  x9F
....................    FaultDelayTime[19] = read_eeprom(0x30);
00E2A:  MOVFF  FF2,7BA
00E2E:  BCF    FF2.7
00E30:  CLRF   FAA
00E32:  MOVLW  30
00E34:  MOVWF  FA9
00E36:  BCF    FA6.6
00E38:  BCF    FA6.7
00E3A:  BSF    FA6.0
00E3C:  MOVF   FA8,W
00E3E:  BTFSC  xBA.7
00E40:  BSF    FF2.7
00E42:  CLRF   xA2
00E44:  MOVWF  xA1
....................    FaultDelayTime[20] = read_eeprom(0x31);
00E46:  MOVFF  FF2,7BA
00E4A:  BCF    FF2.7
00E4C:  CLRF   FAA
00E4E:  MOVLW  31
00E50:  MOVWF  FA9
00E52:  BCF    FA6.6
00E54:  BCF    FA6.7
00E56:  BSF    FA6.0
00E58:  MOVF   FA8,W
00E5A:  BTFSC  xBA.7
00E5C:  BSF    FF2.7
00E5E:  CLRF   xA4
00E60:  MOVWF  xA3
....................    
....................    unsigned int  a = 0; 
....................    unsigned char  phonenum;
00E62:  CLRF   xB0
....................    for(; ; a++)
....................    {
....................       restart_wdt();
00E64:  CLRWDT
....................       phonenum = read_eeprom(0x32 + a);
00E66:  MOVLW  32
00E68:  ADDWF  xB0,W
00E6A:  MOVWF  xBA
00E6C:  MOVFF  FF2,7BB
00E70:  BCF    FF2.7
00E72:  CLRF   FAA
00E74:  MOVFF  7BA,FA9
00E78:  BCF    FA6.6
00E7A:  BCF    FA6.7
00E7C:  BSF    FA6.0
00E7E:  MOVF   FA8,W
00E80:  BTFSC  xBB.7
00E82:  BSF    FF2.7
00E84:  MOVWF  xB1
....................       if((phonenum == 0x0D) || (a > 15))
00E86:  MOVF   xB1,W
00E88:  SUBLW  0D
00E8A:  BZ    0E92
00E8C:  MOVF   xB0,W
00E8E:  SUBLW  0F
00E90:  BC    0EDA
....................       {
....................          sms_phonenumber[a] =  '\0';
00E92:  CLRF   03
00E94:  MOVF   xB0,W
00E96:  ADDLW  8B
00E98:  MOVWF  FE9
00E9A:  MOVLW  05
00E9C:  ADDWFC 03,W
00E9E:  MOVWF  FEA
00EA0:  CLRF   FEF
....................          write_eeprom(0x32+a,phonenum);
00EA2:  MOVLW  32
00EA4:  ADDWF  xB0,W
00EA6:  MOVWF  xBA
00EA8:  MOVF   FF2,W
00EAA:  MOVWF  00
00EAC:  BCF    FF2.7
00EAE:  CLRF   FAA
00EB0:  MOVFF  7BA,FA9
00EB4:  MOVFF  7B1,FA8
00EB8:  BCF    FA6.6
00EBA:  BCF    FA6.7
00EBC:  BSF    FA6.2
00EBE:  MOVLB  F
00EC0:  MOVLW  55
00EC2:  MOVWF  FA7
00EC4:  MOVLW  AA
00EC6:  MOVWF  FA7
00EC8:  BSF    FA6.1
00ECA:  BTFSC  FA6.1
00ECC:  BRA    0ECA
00ECE:  BCF    FA6.2
00ED0:  MOVF   00,W
00ED2:  IORWF  FF2,F
....................          break;
00ED4:  BRA    0EF6
....................       }
00ED6:  BRA    0EEE
00ED8:  MOVLB  7
....................       else
....................       {
....................          sms_phonenumber[a] = phonenum;
00EDA:  CLRF   03
00EDC:  MOVF   xB0,W
00EDE:  ADDLW  8B
00EE0:  MOVWF  FE9
00EE2:  MOVLW  05
00EE4:  ADDWFC 03,W
00EE6:  MOVWF  FEA
00EE8:  MOVFF  7B1,FEF
00EEC:  MOVLB  F
....................       }
00EEE:  MOVLB  7
00EF0:  INCF   xB0,F
00EF2:  BRA    0E64
00EF4:  MOVLB  F
....................    }
....................    
....................    int16  i =3,j=0,k=0 , buff;
00EF6:  MOVLB  7
00EF8:  CLRF   xB3
00EFA:  MOVLW  03
00EFC:  MOVWF  xB2
00EFE:  CLRF   xB5
00F00:  CLRF   xB4
00F02:  CLRF   xB7
00F04:  CLRF   xB6
....................    for(; ; i++,j++)
....................    {
....................       restart_wdt();
00F06:  CLRWDT
....................       buff = read_eeprom(0x5D+i);
00F08:  MOVLW  5D
00F0A:  ADDWF  xB2,W
00F0C:  MOVWF  xBA
00F0E:  MOVLW  00
00F10:  ADDWFC xB3,W
00F12:  MOVWF  xBB
00F14:  MOVFF  FF2,7BC
00F18:  BCF    FF2.7
00F1A:  MOVFF  7BB,FAA
00F1E:  MOVFF  7BA,FA9
00F22:  BCF    FA6.6
00F24:  BCF    FA6.7
00F26:  BSF    FA6.0
00F28:  MOVF   FA8,W
00F2A:  BTFSC  xBC.7
00F2C:  BSF    FF2.7
00F2E:  CLRF   xB9
00F30:  MOVWF  xB8
....................       
....................       if((buff == 0x0D)|| (j>41))
00F32:  MOVF   xB8,W
00F34:  SUBLW  0D
00F36:  BNZ   0F3C
00F38:  MOVF   xB9,F
00F3A:  BZ    0F46
00F3C:  MOVF   xB5,F
00F3E:  BNZ   0F46
00F40:  MOVF   xB4,W
00F42:  SUBLW  29
00F44:  BC    0F58
....................       {
....................          SMS_Massage1[j] = '\0' ; // end string
00F46:  MOVLW  9A
00F48:  ADDWF  xB4,W
00F4A:  MOVWF  FE9
00F4C:  MOVLW  05
00F4E:  ADDWFC xB5,W
00F50:  MOVWF  FEA
00F52:  CLRF   FEF
....................          break;
00F54:  BRA    0F7C
....................       }
00F56:  BRA    0F68
....................       else
....................       {
....................          SMS_Massage1[j] = buff;  
00F58:  MOVLW  9A
00F5A:  ADDWF  xB4,W
00F5C:  MOVWF  FE9
00F5E:  MOVLW  05
00F60:  ADDWFC xB5,W
00F62:  MOVWF  FEA
00F64:  MOVFF  7B8,FEF
....................       }
00F68:  MOVFF  7B3,03
00F6C:  MOVF   xB2,W
00F6E:  INCF   xB2,F
00F70:  BTFSC  FD8.2
00F72:  INCF   xB3,F
00F74:  INCF   xB4,F
00F76:  BTFSC  FD8.2
00F78:  INCF   xB5,F
00F7A:  BRA    0F06
....................    }
....................    
....................    i++;
00F7C:  INCF   xB2,F
00F7E:  BTFSC  FD8.2
00F80:  INCF   xB3,F
....................    j=0;
00F82:  CLRF   xB5
00F84:  CLRF   xB4
....................    
....................    for(; ; i++,j++)
....................    {
....................       restart_wdt();
00F86:  CLRWDT
....................       buff = read_eeprom(0x5D+i);
00F88:  MOVLW  5D
00F8A:  ADDWF  xB2,W
00F8C:  MOVWF  xBA
00F8E:  MOVLW  00
00F90:  ADDWFC xB3,W
00F92:  MOVWF  xBB
00F94:  MOVFF  FF2,7BC
00F98:  BCF    FF2.7
00F9A:  MOVFF  7BB,FAA
00F9E:  MOVFF  7BA,FA9
00FA2:  BCF    FA6.6
00FA4:  BCF    FA6.7
00FA6:  BSF    FA6.0
00FA8:  MOVF   FA8,W
00FAA:  BTFSC  xBC.7
00FAC:  BSF    FF2.7
00FAE:  CLRF   xB9
00FB0:  MOVWF  xB8
....................       
....................       if((buff == 0x0D) || (j>41))
00FB2:  MOVF   xB8,W
00FB4:  SUBLW  0D
00FB6:  BNZ   0FBC
00FB8:  MOVF   xB9,F
00FBA:  BZ    0FC6
00FBC:  MOVF   xB5,F
00FBE:  BNZ   0FC6
00FC0:  MOVF   xB4,W
00FC2:  SUBLW  29
00FC4:  BC    0FD8
....................       {
....................          SMS_Massage2[j] = '\0' ; // end string
00FC6:  MOVLW  BA
00FC8:  ADDWF  xB4,W
00FCA:  MOVWF  FE9
00FCC:  MOVLW  05
00FCE:  ADDWFC xB5,W
00FD0:  MOVWF  FEA
00FD2:  CLRF   FEF
....................          break;
00FD4:  BRA    0FFC
....................       }
00FD6:  BRA    0FE8
....................       else
....................       {
....................          SMS_Massage2[j] = buff;
00FD8:  MOVLW  BA
00FDA:  ADDWF  xB4,W
00FDC:  MOVWF  FE9
00FDE:  MOVLW  05
00FE0:  ADDWFC xB5,W
00FE2:  MOVWF  FEA
00FE4:  MOVFF  7B8,FEF
....................          
....................       }
00FE8:  MOVFF  7B3,03
00FEC:  MOVF   xB2,W
00FEE:  INCF   xB2,F
00FF0:  BTFSC  FD8.2
00FF2:  INCF   xB3,F
00FF4:  INCF   xB4,F
00FF6:  BTFSC  FD8.2
00FF8:  INCF   xB5,F
00FFA:  BRA    0F86
....................    }
....................    
....................    i++;
00FFC:  INCF   xB2,F
00FFE:  BTFSC  FD8.2
01000:  INCF   xB3,F
....................    j=0;
01002:  CLRF   xB5
01004:  CLRF   xB4
....................    
....................    for(; ; i++,j++)
....................    {
....................       restart_wdt();
01006:  CLRWDT
....................       buff = read_eeprom(0x5D+i);
01008:  MOVLW  5D
0100A:  ADDWF  xB2,W
0100C:  MOVWF  xBA
0100E:  MOVLW  00
01010:  ADDWFC xB3,W
01012:  MOVWF  xBB
01014:  MOVFF  FF2,7BC
01018:  BCF    FF2.7
0101A:  MOVFF  7BB,FAA
0101E:  MOVFF  7BA,FA9
01022:  BCF    FA6.6
01024:  BCF    FA6.7
01026:  BSF    FA6.0
01028:  MOVF   FA8,W
0102A:  BTFSC  xBC.7
0102C:  BSF    FF2.7
0102E:  CLRF   xB9
01030:  MOVWF  xB8
....................       
....................       if((buff == 0x0D) || (j>41))
01032:  MOVF   xB8,W
01034:  SUBLW  0D
01036:  BNZ   103C
01038:  MOVF   xB9,F
0103A:  BZ    1046
0103C:  MOVF   xB5,F
0103E:  BNZ   1046
01040:  MOVF   xB4,W
01042:  SUBLW  29
01044:  BC    1058
....................       {
....................          SMS_Massage3[j] = '\0' ; // end string
01046:  MOVLW  DA
01048:  ADDWF  xB4,W
0104A:  MOVWF  FE9
0104C:  MOVLW  05
0104E:  ADDWFC xB5,W
01050:  MOVWF  FEA
01052:  CLRF   FEF
....................          break;
01054:  BRA    107C
....................       }
01056:  BRA    1068
....................       else
....................       {
....................          SMS_Massage3[j] = buff;
01058:  MOVLW  DA
0105A:  ADDWF  xB4,W
0105C:  MOVWF  FE9
0105E:  MOVLW  05
01060:  ADDWFC xB5,W
01062:  MOVWF  FEA
01064:  MOVFF  7B8,FEF
....................          
....................       }
01068:  MOVFF  7B3,03
0106C:  MOVF   xB2,W
0106E:  INCF   xB2,F
01070:  BTFSC  FD8.2
01072:  INCF   xB3,F
01074:  INCF   xB4,F
01076:  BTFSC  FD8.2
01078:  INCF   xB5,F
0107A:  BRA    1006
....................    }
....................    
....................    i++;
0107C:  INCF   xB2,F
0107E:  BTFSC  FD8.2
01080:  INCF   xB3,F
....................    j=0;
01082:  CLRF   xB5
01084:  CLRF   xB4
....................    
....................    for(; ; i++,j++)
....................    {
....................       restart_wdt();
01086:  CLRWDT
....................       buff = read_eeprom(0x5D+i);
01088:  MOVLW  5D
0108A:  ADDWF  xB2,W
0108C:  MOVWF  xBA
0108E:  MOVLW  00
01090:  ADDWFC xB3,W
01092:  MOVWF  xBB
01094:  MOVFF  FF2,7BC
01098:  BCF    FF2.7
0109A:  MOVFF  7BB,FAA
0109E:  MOVFF  7BA,FA9
010A2:  BCF    FA6.6
010A4:  BCF    FA6.7
010A6:  BSF    FA6.0
010A8:  MOVF   FA8,W
010AA:  BTFSC  xBC.7
010AC:  BSF    FF2.7
010AE:  CLRF   xB9
010B0:  MOVWF  xB8
....................       
....................       if((buff == 0x0D) || (j>41))
010B2:  MOVF   xB8,W
010B4:  SUBLW  0D
010B6:  BNZ   10BC
010B8:  MOVF   xB9,F
010BA:  BZ    10C6
010BC:  MOVF   xB5,F
010BE:  BNZ   10C6
010C0:  MOVF   xB4,W
010C2:  SUBLW  29
010C4:  BC    10D8
....................       {
....................          SMS_Massage4[j] = '\0' ; // end string
010C6:  MOVLW  FA
010C8:  ADDWF  xB4,W
010CA:  MOVWF  FE9
010CC:  MOVLW  05
010CE:  ADDWFC xB5,W
010D0:  MOVWF  FEA
010D2:  CLRF   FEF
....................          break;
010D4:  BRA    10FC
....................       }
010D6:  BRA    10E8
....................       else
....................       {
....................          SMS_Massage4[j] = buff;
010D8:  MOVLW  FA
010DA:  ADDWF  xB4,W
010DC:  MOVWF  FE9
010DE:  MOVLW  05
010E0:  ADDWFC xB5,W
010E2:  MOVWF  FEA
010E4:  MOVFF  7B8,FEF
....................          
....................       }
010E8:  MOVFF  7B3,03
010EC:  MOVF   xB2,W
010EE:  INCF   xB2,F
010F0:  BTFSC  FD8.2
010F2:  INCF   xB3,F
010F4:  INCF   xB4,F
010F6:  BTFSC  FD8.2
010F8:  INCF   xB5,F
010FA:  BRA    1086
....................    }
....................    
....................    i++;
010FC:  INCF   xB2,F
010FE:  BTFSC  FD8.2
01100:  INCF   xB3,F
....................    j=0;
01102:  CLRF   xB5
01104:  CLRF   xB4
....................    
....................    for(; ; i++,j++)
....................    {
....................       restart_wdt();
01106:  CLRWDT
....................       buff = read_eeprom(0x5D+i);
01108:  MOVLW  5D
0110A:  ADDWF  xB2,W
0110C:  MOVWF  xBA
0110E:  MOVLW  00
01110:  ADDWFC xB3,W
01112:  MOVWF  xBB
01114:  MOVFF  FF2,7BC
01118:  BCF    FF2.7
0111A:  MOVFF  7BB,FAA
0111E:  MOVFF  7BA,FA9
01122:  BCF    FA6.6
01124:  BCF    FA6.7
01126:  BSF    FA6.0
01128:  MOVF   FA8,W
0112A:  BTFSC  xBC.7
0112C:  BSF    FF2.7
0112E:  CLRF   xB9
01130:  MOVWF  xB8
....................       
....................       if((buff == 0x0D) || (j>41))
01132:  MOVF   xB8,W
01134:  SUBLW  0D
01136:  BNZ   113C
01138:  MOVF   xB9,F
0113A:  BZ    1146
0113C:  MOVF   xB5,F
0113E:  BNZ   1146
01140:  MOVF   xB4,W
01142:  SUBLW  29
01144:  BC    1158
....................       {
....................          SMS_Massage5[j] = '\0' ; // end string
01146:  MOVLW  1A
01148:  ADDWF  xB4,W
0114A:  MOVWF  FE9
0114C:  MOVLW  06
0114E:  ADDWFC xB5,W
01150:  MOVWF  FEA
01152:  CLRF   FEF
....................          break;
01154:  BRA    117C
....................       }
01156:  BRA    1168
....................       else
....................       {
....................          SMS_Massage5[j] = buff;
01158:  MOVLW  1A
0115A:  ADDWF  xB4,W
0115C:  MOVWF  FE9
0115E:  MOVLW  06
01160:  ADDWFC xB5,W
01162:  MOVWF  FEA
01164:  MOVFF  7B8,FEF
....................          
....................       }
01168:  MOVFF  7B3,03
0116C:  MOVF   xB2,W
0116E:  INCF   xB2,F
01170:  BTFSC  FD8.2
01172:  INCF   xB3,F
01174:  INCF   xB4,F
01176:  BTFSC  FD8.2
01178:  INCF   xB5,F
0117A:  BRA    1106
....................    }
....................    
....................    i++;
0117C:  INCF   xB2,F
0117E:  BTFSC  FD8.2
01180:  INCF   xB3,F
....................    j=0;
01182:  CLRF   xB5
01184:  CLRF   xB4
....................    
....................    for(; ; i++,j++)
....................    {
....................       restart_wdt();
01186:  CLRWDT
....................       buff = read_eeprom(0x5D+i);
01188:  MOVLW  5D
0118A:  ADDWF  xB2,W
0118C:  MOVWF  xBA
0118E:  MOVLW  00
01190:  ADDWFC xB3,W
01192:  MOVWF  xBB
01194:  MOVFF  FF2,7BC
01198:  BCF    FF2.7
0119A:  MOVFF  7BB,FAA
0119E:  MOVFF  7BA,FA9
011A2:  BCF    FA6.6
011A4:  BCF    FA6.7
011A6:  BSF    FA6.0
011A8:  MOVF   FA8,W
011AA:  BTFSC  xBC.7
011AC:  BSF    FF2.7
011AE:  CLRF   xB9
011B0:  MOVWF  xB8
....................       
....................       if((buff == 0x0D) || (j>41))
011B2:  MOVF   xB8,W
011B4:  SUBLW  0D
011B6:  BNZ   11BC
011B8:  MOVF   xB9,F
011BA:  BZ    11C6
011BC:  MOVF   xB5,F
011BE:  BNZ   11C6
011C0:  MOVF   xB4,W
011C2:  SUBLW  29
011C4:  BC    11D8
....................       {
....................          SMS_Massage6[j] = '\0' ; // end string
011C6:  MOVLW  3A
011C8:  ADDWF  xB4,W
011CA:  MOVWF  FE9
011CC:  MOVLW  06
011CE:  ADDWFC xB5,W
011D0:  MOVWF  FEA
011D2:  CLRF   FEF
....................          break;
011D4:  BRA    11FC
....................       }
011D6:  BRA    11E8
....................       else
....................       {
....................          SMS_Massage6[j] = buff;
011D8:  MOVLW  3A
011DA:  ADDWF  xB4,W
011DC:  MOVWF  FE9
011DE:  MOVLW  06
011E0:  ADDWFC xB5,W
011E2:  MOVWF  FEA
011E4:  MOVFF  7B8,FEF
....................          
....................       }
011E8:  MOVFF  7B3,03
011EC:  MOVF   xB2,W
011EE:  INCF   xB2,F
011F0:  BTFSC  FD8.2
011F2:  INCF   xB3,F
011F4:  INCF   xB4,F
011F6:  BTFSC  FD8.2
011F8:  INCF   xB5,F
011FA:  BRA    1186
....................    }
....................    
....................    i++;
011FC:  INCF   xB2,F
011FE:  BTFSC  FD8.2
01200:  INCF   xB3,F
....................    j=0;
01202:  CLRF   xB5
01204:  CLRF   xB4
....................    
....................    for(; ; i++,j++)
....................    {
....................       restart_wdt();
01206:  CLRWDT
....................       buff = read_eeprom(0x5D+i);
01208:  MOVLW  5D
0120A:  ADDWF  xB2,W
0120C:  MOVWF  xBA
0120E:  MOVLW  00
01210:  ADDWFC xB3,W
01212:  MOVWF  xBB
01214:  MOVFF  FF2,7BC
01218:  BCF    FF2.7
0121A:  MOVFF  7BB,FAA
0121E:  MOVFF  7BA,FA9
01222:  BCF    FA6.6
01224:  BCF    FA6.7
01226:  BSF    FA6.0
01228:  MOVF   FA8,W
0122A:  BTFSC  xBC.7
0122C:  BSF    FF2.7
0122E:  CLRF   xB9
01230:  MOVWF  xB8
....................       
....................       if((buff == 0x0D) || (j>41))
01232:  MOVF   xB8,W
01234:  SUBLW  0D
01236:  BNZ   123C
01238:  MOVF   xB9,F
0123A:  BZ    1246
0123C:  MOVF   xB5,F
0123E:  BNZ   1246
01240:  MOVF   xB4,W
01242:  SUBLW  29
01244:  BC    1258
....................       {
....................          SMS_Massage7[j] = '\0' ; // end string
01246:  MOVLW  5A
01248:  ADDWF  xB4,W
0124A:  MOVWF  FE9
0124C:  MOVLW  06
0124E:  ADDWFC xB5,W
01250:  MOVWF  FEA
01252:  CLRF   FEF
....................          break;
01254:  BRA    127C
....................       }
01256:  BRA    1268
....................       else
....................       {
....................          SMS_Massage7[j] = buff;
01258:  MOVLW  5A
0125A:  ADDWF  xB4,W
0125C:  MOVWF  FE9
0125E:  MOVLW  06
01260:  ADDWFC xB5,W
01262:  MOVWF  FEA
01264:  MOVFF  7B8,FEF
....................          
....................       }
01268:  MOVFF  7B3,03
0126C:  MOVF   xB2,W
0126E:  INCF   xB2,F
01270:  BTFSC  FD8.2
01272:  INCF   xB3,F
01274:  INCF   xB4,F
01276:  BTFSC  FD8.2
01278:  INCF   xB5,F
0127A:  BRA    1206
....................    }
....................    
....................    i++;
0127C:  INCF   xB2,F
0127E:  BTFSC  FD8.2
01280:  INCF   xB3,F
....................    j=0;
01282:  CLRF   xB5
01284:  CLRF   xB4
....................    
....................    for(; ; i++,j++)
....................    {
....................       restart_wdt();
01286:  CLRWDT
....................       buff = read_eeprom(0x5D+i);
01288:  MOVLW  5D
0128A:  ADDWF  xB2,W
0128C:  MOVWF  xBA
0128E:  MOVLW  00
01290:  ADDWFC xB3,W
01292:  MOVWF  xBB
01294:  MOVFF  FF2,7BC
01298:  BCF    FF2.7
0129A:  MOVFF  7BB,FAA
0129E:  MOVFF  7BA,FA9
012A2:  BCF    FA6.6
012A4:  BCF    FA6.7
012A6:  BSF    FA6.0
012A8:  MOVF   FA8,W
012AA:  BTFSC  xBC.7
012AC:  BSF    FF2.7
012AE:  CLRF   xB9
012B0:  MOVWF  xB8
....................       
....................       if((buff == 0x0D) || (j>41))
012B2:  MOVF   xB8,W
012B4:  SUBLW  0D
012B6:  BNZ   12BC
012B8:  MOVF   xB9,F
012BA:  BZ    12C6
012BC:  MOVF   xB5,F
012BE:  BNZ   12C6
012C0:  MOVF   xB4,W
012C2:  SUBLW  29
012C4:  BC    12D8
....................       {
....................          SMS_Massage8[j] = '\0' ; // end string
012C6:  MOVLW  7A
012C8:  ADDWF  xB4,W
012CA:  MOVWF  FE9
012CC:  MOVLW  06
012CE:  ADDWFC xB5,W
012D0:  MOVWF  FEA
012D2:  CLRF   FEF
....................          break;
012D4:  BRA    12FC
....................       }
012D6:  BRA    12E8
....................       else
....................       {
....................          SMS_Massage8[j] = buff;
012D8:  MOVLW  7A
012DA:  ADDWF  xB4,W
012DC:  MOVWF  FE9
012DE:  MOVLW  06
012E0:  ADDWFC xB5,W
012E2:  MOVWF  FEA
012E4:  MOVFF  7B8,FEF
....................          
....................       }
012E8:  MOVFF  7B3,03
012EC:  MOVF   xB2,W
012EE:  INCF   xB2,F
012F0:  BTFSC  FD8.2
012F2:  INCF   xB3,F
012F4:  INCF   xB4,F
012F6:  BTFSC  FD8.2
012F8:  INCF   xB5,F
012FA:  BRA    1286
....................    } 
012FC:  MOVLB  0
012FE:  RETURN 0
....................   
....................    
.................... 
.................... }
.................... //////////////////////////////////////////////////////////////////////////////////
.................... ////////////////////////////////////////////////////////////////////////////////
.................... #int_RDA
.................... void RDA_isr(void)
.................... {
....................    SBUF = getc();
*
0059E:  BTFSS  F9E.5
005A0:  BRA    059E
005A2:  MOVFF  FAE,30
....................    checkCommand();
005A6:  BRA    02EE
.................... }
.................... 
005A8:  BCF    F9E.5
005AA:  GOTO   006C
.................... #int_TIMER2
.................... void TIMER2_isr(void)      //10ms
.................... {
....................    StatusTime++;
005AE:  INCF   1B,F
.................... 
....................    if(T_timeout != 0)
005B0:  MOVLB  5
005B2:  MOVF   x87,F
005B4:  BZ    05CC
....................    {
....................       T_timeout--;
005B6:  DECF   x87,F
....................       if(T_timeout == 0)
005B8:  MOVF   x87,F
005BA:  BNZ   05CC
....................       {
....................           RxD_DataLen = 0x00;
005BC:  MOVLB  0
005BE:  CLRF   x7C
....................           sequence = end_sq;
005C0:  MOVFF  71,7A
....................           T_timeout = 0x00; 
005C4:  MOVLB  5
005C6:  CLRF   x87
....................           output_bit(P485ctrl,0);
005C8:  BCF    F8A.3
005CA:  BCF    F93.3
....................       }
....................    }
....................    ////////// Time Base 1 Second /////////////
....................    if(TimeBase1s != 0x00)
005CC:  MOVF   1E,F
005CE:  BZ    05FA
....................    {
....................       TimeBase1s--;
005D0:  DECF   1E,F
....................       if(TimeBase1s == 0x00)      // <====== code in time base 1 second
005D2:  MOVF   1E,F
005D4:  BNZ   05FA
....................       {
....................          if(AutoAckDelayTime != 0x00)
005D6:  MOVF   1F,F
005D8:  BZ    05E2
....................          {
....................             AutoAckDelayTime--;
005DA:  DECF   1F,F
....................             if(AutoAckDelayTime == 0x00)
005DC:  MOVF   1F,F
005DE:  BNZ   05E2
....................             {
....................                AutoAckFlag = 1 ;
005E0:  BSF    1C.2
....................             }
....................          }
....................          if(++send_SMS_count >=5){
005E2:  MOVLB  7
005E4:  INCF   x3D,F
005E6:  MOVF   x3D,W
005E8:  SUBLW  04
005EA:  BC    05F2
....................             send_SMS_count =0;
005EC:  CLRF   x3D
....................             send_SMS_period = 1;
005EE:  MOVLW  01
005F0:  MOVWF  x3C
....................          }
....................          //////////////////////////////
....................          RefreshConfigData = 1;
005F2:  BSF    32.4
....................          TimeBase1s = 100;
005F4:  MOVLW  64
005F6:  MOVWF  1E
005F8:  MOVLB  5
....................       }
.................... 
....................    }
....................    ///////////// End Time base 1 Second ///////
.................... 
.................... 
.................... 
....................    if(StatusTime == 50)    //500mS
005FA:  MOVF   1B,W
005FC:  SUBLW  32
005FE:  BNZ   062A
....................    {
....................       StatusTime = 0;
00600:  CLRF   1B
....................       if(HearthbeatInd == 0)
00602:  BTFSC  1C.0
00604:  BRA    060E
....................       {
....................          HearthbeatInd = 1;
00606:  BSF    1C.0
....................          output_bit(Pled,1);
00608:  BSF    F8A.5
0060A:  BCF    F93.5
....................       }
0060C:  BRA    0614
....................       else
....................       {
....................          HearthbeatInd = 0;
0060E:  BCF    1C.0
....................          output_bit(Pled,0);
00610:  BCF    F8A.5
00612:  BCF    F93.5
....................       }
....................       /////////////////////////////////////////// time base 500 ms
....................       if(Test == 1)            //Test function
00614:  BTFSS  1C.6
00616:  BRA    0628
....................       {
....................              if(T_test > 0x00) T_test --;
00618:  MOVF   31,F
0061A:  BZ    061E
0061C:  DECF   31,F
....................              if(T_test == 0x00)
0061E:  MOVF   31,F
00620:  BNZ   0626
....................              {
....................                Test_fault = 1;
00622:  BSF    1C.5
....................                functointest_f = 1;
00624:  BSF    32.1
....................              }
....................        }
00626:  BRA    062A
....................        else
....................        {
....................           //Test = 0;
....................           T_test = 0x00;
00628:  CLRF   31
....................        }
....................    }
....................    ///////////////////////////////
....................    if(FlashingRateTime != 0)
0062A:  MOVF   1D,F
0062C:  BZ    0650
....................    {
....................       FlashingRateTime--;
0062E:  DECF   1D,F
....................       if(FlashingRateTime == 0)
00630:  MOVF   1D,F
00632:  BNZ   0644
....................       {
....................          outmcp23 = 0xff;
00634:  SETF   x8A
....................          
....................          //if(SyncStatus == 0)
....................          //{
....................             if(FlashingFlag)
00636:  BTFSS  1C.1
00638:  BRA    063E
....................             {
....................                FlashingFlag = 0;
0063A:  BCF    1C.1
....................                //output_bit(PSyncS,0);
....................             }
0063C:  BRA    0640
....................             else
....................             {
.................... 
....................                FlashingFlag = 1;
0063E:  BSF    1C.1
....................                //output_bit(PSyncS,1);
....................             }
....................          //}
....................          FlashingRateTime = FlashingRate;      //reload value
00640:  MOVFF  6E,1D
....................       }
.................... 
....................       if(Synctimer != 0x00)
00644:  MOVF   33,F
00646:  BZ    0650
....................       {
....................          Synctimer--;
00648:  DECF   33,F
....................          if(Synctimer == 0x00)
0064A:  MOVF   33,F
0064C:  BNZ   0650
....................          {
....................             SyncStatus = 0;
0064E:  BCF    32.2
....................          }
....................       }
.................... 
....................    } 
00650:  BCF    F9E.1
00652:  MOVLB  0
00654:  GOTO   006C
.................... }
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... void Anal_Function(void)
.................... {
....................    /////////////////////////////////////////////////////////////////////////////
....................    ////////////////////////////// MANUAL RESET /////////////////////////////////
....................    /////////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... //if(NoOfPoint >= 10)
.................... //{
.................... 
.................... //input1
....................    if(AlarmIndicator.B1 == 1)    // Alarm Function
*
04688:  MOVLB  7
0468A:  BTFSS  x44.0
0468C:  BRA    473A
....................    {
....................       if((((Inputt.B1 ^ InputType.B1) == 1) && (FaultType.B1 == 1))|| In.B1 == 1)    // alarm1 occure and "Lock type"
0468E:  MOVLW  00
04690:  BTFSC  x3E.0
04692:  MOVLW  01
04694:  MOVWF  xB1
04696:  MOVLW  00
04698:  BTFSC  x40.0
0469A:  MOVLW  01
0469C:  XORWF  xB1,W
0469E:  SUBLW  01
046A0:  BNZ   46A6
046A2:  BTFSC  x41.0
046A4:  BRA    46AA
046A6:  BTFSS  x46.0
046A8:  BRA    4732
....................       //if(Inputt.B1 == 0)
....................       {
....................          if(Ack.B1 == 0)
046AA:  BTFSC  x45.0
046AC:  BRA    4730
....................          {
....................             if(In.B1 == 0 && AutoAck == 0x0F)   //use auto acknowlegde
046AE:  BTFSC  x46.0
046B0:  BRA    46CA
046B2:  MOVLB  0
046B4:  MOVF   x6C,W
046B6:  SUBLW  0F
046B8:  BTFSC  FD8.2
046BA:  BRA    46C0
046BC:  MOVLB  7
046BE:  BRA    46CA
....................             {
....................                TimeBase1s = 100 ;            //reload again
046C0:  MOVLW  64
046C2:  MOVWF  1E
....................                AutoAckDelayTime = AutoAckTime ;
046C4:  MOVFF  6D,1F
046C8:  MOVLB  7
....................             }
.................... 
....................             In.B1 = 1;                                 // setbit in1
046CA:  BSF    x46.0
....................             if(FlashingFlag == 0)
046CC:  BTFSC  1C.1
046CE:  BRA    46D4
....................             {
....................                Output.B1 = 0;           //Flash output1
046D0:  BCF    x3F.0
....................             }
046D2:  BRA    46D6
....................             else
....................             {
....................                Output.B1 = 1;
046D4:  BSF    x3F.0
....................             }
....................             if (~AutoTestFlag)
046D6:  BTFSC  1C.4
046D8:  BRA    46F6
....................             {
....................                if(OutputBoth.B1 == 0)                  //Both output
046DA:  BTFSC  x43.0
046DC:  BRA    46E8
....................                {
....................                   output_bit(Pbuzzer,0);   //Buzzer
046DE:  BCF    F89.4
046E0:  BCF    F92.4
....................                   output_bit(Pbell,0);     //Bell
046E2:  BCF    F89.3
046E4:  BCF    F92.3
....................                }
046E6:  BRA    46F6
....................                else
....................                {
....................                   if(OutputType.B1 == 1) output_bit(Pbuzzer,0);     //Buzzer
046E8:  BTFSS  x42.0
046EA:  BRA    46F2
046EC:  BCF    F89.4
046EE:  BCF    F92.4
046F0:  BRA    46F6
....................                   else output_bit(Pbell,0);                          //Bell
046F2:  BCF    F89.3
046F4:  BCF    F92.3
....................                }    
....................             }  
....................             // SMS Sending   
....................             if((SendSMS.B1 ==0) && (functointest_f ==0) && (Ack.B1 ==0))
046F6:  BTFSC  x4C.0
046F8:  BRA    4730
046FA:  BTFSC  32.1
046FC:  BRA    4730
046FE:  BTFSC  x45.0
04700:  BRA    4730
....................             {            
....................                SendSMS.B1 =1;
04702:  BSF    x4C.0
....................                strcat(SMS_MassageSUM, SMS_Massage1);
04704:  MOVLW  06
04706:  MOVWF  xB1
04708:  MOVLW  9A
0470A:  MOVWF  xB0
0470C:  MOVLW  05
0470E:  MOVWF  xB3
04710:  MOVLW  9A
04712:  MOVWF  xB2
04714:  MOVLB  0
04716:  RCALL  4256
....................                strcat(SMS_MassageSUM, spacestring);
04718:  MOVLW  06
0471A:  MOVLB  7
0471C:  MOVWF  xB1
0471E:  MOVLW  9A
04720:  MOVWF  xB0
04722:  MOVLW  07
04724:  MOVWF  xB3
04726:  MOVLW  3A
04728:  MOVWF  xB2
0472A:  MOVLB  0
0472C:  RCALL  4256
0472E:  MOVLB  7
....................                /*
....................                fprintf(CH2,"AT+CMGF=1"); 
....................                putc('\n',CH2);
....................                delay_ms(10);
.................... 
....................                fprintf(CH2,"AT+CMGS=\"");
....................                fprintf(CH2,sms_phonenumber);
....................                
....................                fprintf(CH2,"\"");
....................                putc('\n',CH2);
....................                delay_ms(50);
....................               
....................               fprintf(CH2,SMS_Massage1);
....................               putc('\n',CH2);
....................               putc(26,CH2);
....................           */
....................             }
....................             
....................         }
....................       }
04730:  BRA    4738
....................       else if(FaultType.B1 == 1) Ack.B1 = 0;
04732:  BTFSS  x41.0
04734:  BRA    4738
04736:  BCF    x45.0
....................    }
04738:  BRA    4792
....................    else  //Indicator Function
....................    {
....................       if((Inputt.B1 ^ InputType.B1) == 1)
0473A:  MOVLW  00
0473C:  BTFSC  x3E.0
0473E:  MOVLW  01
04740:  MOVWF  xB1
04742:  MOVLW  00
04744:  BTFSC  x40.0
04746:  MOVLW  01
04748:  XORWF  xB1,W
0474A:  SUBLW  01
0474C:  BNZ   478C
....................       {
....................          Output.B1 = 0;
0474E:  BCF    x3F.0
.................... 
....................          // SMS Sending   
....................          if((SendSMS.B1 ==0) && (functointest_f ==0) && (Ack.B1 ==0))
04750:  BTFSC  x4C.0
04752:  BRA    478A
04754:  BTFSC  32.1
04756:  BRA    478A
04758:  BTFSC  x45.0
0475A:  BRA    478A
....................          {            
....................             SendSMS.B1 =1;
0475C:  BSF    x4C.0
....................             strcat(SMS_MassageSUM, SMS_Massage1);
0475E:  MOVLW  06
04760:  MOVWF  xB1
04762:  MOVLW  9A
04764:  MOVWF  xB0
04766:  MOVLW  05
04768:  MOVWF  xB3
0476A:  MOVLW  9A
0476C:  MOVWF  xB2
0476E:  MOVLB  0
04770:  RCALL  4256
....................             strcat(SMS_MassageSUM, spacestring);
04772:  MOVLW  06
04774:  MOVLB  7
04776:  MOVWF  xB1
04778:  MOVLW  9A
0477A:  MOVWF  xB0
0477C:  MOVLW  07
0477E:  MOVWF  xB3
04780:  MOVLW  3A
04782:  MOVWF  xB2
04784:  MOVLB  0
04786:  RCALL  4256
04788:  MOVLB  7
....................                /*
....................             fprintf(CH2,"AT+CMGF=1"); 
....................             putc('\n',CH2);
....................             delay_ms(10);
.................... 
....................             fprintf(CH2,"AT+CMGS=\"");
....................             fprintf(CH2,sms_phonenumber);
....................             
....................             fprintf(CH2,"\"");
....................             putc('\n',CH2);
....................             delay_ms(50);
....................            
....................            fprintf(CH2,SMS_Massage1);
....................            putc('\n',CH2);
....................           putc(26,CH2);
....................           */
....................          }
....................          
....................       }
0478A:  BRA    4792
....................       else
....................       {
....................          Output.B1 = 1;
0478C:  BSF    x3F.0
....................          
....................          SendSMS.B1 =0;
0478E:  BCF    x4C.0
....................          functointest_f =0;
04790:  BCF    32.1
....................       }
....................    }
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //input2
....................    if(AlarmIndicator.B2 == 1)    // Alarm Function
04792:  BTFSS  x44.1
04794:  BRA    4842
....................    {
....................       if((((Inputt.B2 ^ InputType.B2) == 1) && (FaultType.B2 == 1))|| In.B2 == 1)    // alarm1 occure and "Lock type"
04796:  MOVLW  00
04798:  BTFSC  x3E.1
0479A:  MOVLW  01
0479C:  MOVWF  xB1
0479E:  MOVLW  00
047A0:  BTFSC  x40.1
047A2:  MOVLW  01
047A4:  XORWF  xB1,W
047A6:  SUBLW  01
047A8:  BNZ   47AE
047AA:  BTFSC  x41.1
047AC:  BRA    47B2
047AE:  BTFSS  x46.1
047B0:  BRA    483A
....................       //if(Inputt.B2 == 0)
....................       {
....................          if(Ack.B2 == 0)
047B2:  BTFSC  x45.1
047B4:  BRA    47FE
....................          {
....................             if(In.B2 == 0 && AutoAck == 0x0F)   //use auto acknowlegde
047B6:  BTFSC  x46.1
047B8:  BRA    47D2
047BA:  MOVLB  0
047BC:  MOVF   x6C,W
047BE:  SUBLW  0F
047C0:  BTFSC  FD8.2
047C2:  BRA    47C8
047C4:  MOVLB  7
047C6:  BRA    47D2
....................             {
....................                TimeBase1s = 100 ;            //reload again
047C8:  MOVLW  64
047CA:  MOVWF  1E
....................                AutoAckDelayTime = AutoAckTime ;
047CC:  MOVFF  6D,1F
047D0:  MOVLB  7
....................             }
.................... 
....................             In.B2 = 1;                                 // setbit in1
047D2:  BSF    x46.1
....................             if(FlashingFlag == 0)
047D4:  BTFSC  1C.1
047D6:  BRA    47DC
....................             {
....................                Output.B2 = 0;           //Flash output1
047D8:  BCF    x3F.1
....................             }
047DA:  BRA    47DE
....................             else
....................             {
....................                Output.B2 = 1;
047DC:  BSF    x3F.1
....................             }
.................... 
....................             if (~AutoTestFlag)
047DE:  BTFSC  1C.4
047E0:  BRA    47FE
....................             {
....................                
....................                if(OutputBoth.B2 == 0)                  //Both output
047E2:  BTFSC  x43.1
047E4:  BRA    47F0
....................                {
....................                   output_bit(Pbuzzer,0);   //Buzzer
047E6:  BCF    F89.4
047E8:  BCF    F92.4
....................                   output_bit(Pbell,0);     //Bell
047EA:  BCF    F89.3
047EC:  BCF    F92.3
....................                }
047EE:  BRA    47FE
....................                else
....................                {
....................                   if(OutputType.B2 == 1) output_bit(Pbuzzer,0);     //Buzzer
047F0:  BTFSS  x42.1
047F2:  BRA    47FA
047F4:  BCF    F89.4
047F6:  BCF    F92.4
047F8:  BRA    47FE
....................                   else output_bit(Pbell,0);                          //Bell
047FA:  BCF    F89.3
047FC:  BCF    F92.3
....................                }
....................             }
....................           }
....................           // SMS Sending   
....................             if((SendSMS.B2 ==0)&& (functointest_f ==0) && (Ack.B2 ==0))
047FE:  BTFSC  x4C.1
04800:  BRA    4838
04802:  BTFSC  32.1
04804:  BRA    4838
04806:  BTFSC  x45.1
04808:  BRA    4838
....................             {                
....................                SendSMS.B2 =1;
0480A:  BSF    x4C.1
....................                strcat(SMS_MassageSUM, SMS_Massage2);
0480C:  MOVLW  06
0480E:  MOVWF  xB1
04810:  MOVLW  9A
04812:  MOVWF  xB0
04814:  MOVLW  05
04816:  MOVWF  xB3
04818:  MOVLW  BA
0481A:  MOVWF  xB2
0481C:  MOVLB  0
0481E:  RCALL  4256
....................                strcat(SMS_MassageSUM, spacestring);
04820:  MOVLW  06
04822:  MOVLB  7
04824:  MOVWF  xB1
04826:  MOVLW  9A
04828:  MOVWF  xB0
0482A:  MOVLW  07
0482C:  MOVWF  xB3
0482E:  MOVLW  3A
04830:  MOVWF  xB2
04832:  MOVLB  0
04834:  RCALL  4256
04836:  MOVLB  7
....................                /*
....................                fprintf(CH2,"AT+CMGF=1"); 
....................                putc('\n',CH2);
....................                delay_ms(10);
.................... 
....................                fprintf(CH2,"AT+CMGS=\"");
....................                fprintf(CH2,sms_phonenumber);
....................                
....................                fprintf(CH2,"\"");
....................                putc('\n',CH2);
....................                delay_ms(50);
....................                
....................               fprintf(CH2,SMS_Massage2);
....................               putc('\n',CH2);
....................              putc(26,CH2);
....................           */
....................             }  
....................       }
04838:  BRA    4840
....................       else if(FaultType.B2 == 1) Ack.B2 = 0;
0483A:  BTFSS  x41.1
0483C:  BRA    4840
0483E:  BCF    x45.1
....................    }
04840:  BRA    489A
....................    else  //Indicator Function
....................    {
....................       if((Inputt.B2 ^ InputType.B2) == 1)
04842:  MOVLW  00
04844:  BTFSC  x3E.1
04846:  MOVLW  01
04848:  MOVWF  xB1
0484A:  MOVLW  00
0484C:  BTFSC  x40.1
0484E:  MOVLW  01
04850:  XORWF  xB1,W
04852:  SUBLW  01
04854:  BNZ   4894
....................       {
....................          Output.B2 = 0;
04856:  BCF    x3F.1
....................           // SMS Sending   
....................          if((SendSMS.B2 ==0)&& (functointest_f ==0) && (Ack.B2 ==0))
04858:  BTFSC  x4C.1
0485A:  BRA    4892
0485C:  BTFSC  32.1
0485E:  BRA    4892
04860:  BTFSC  x45.1
04862:  BRA    4892
....................          {            
....................             SendSMS.B2 =1;
04864:  BSF    x4C.1
....................             strcat(SMS_MassageSUM, SMS_Massage2);
04866:  MOVLW  06
04868:  MOVWF  xB1
0486A:  MOVLW  9A
0486C:  MOVWF  xB0
0486E:  MOVLW  05
04870:  MOVWF  xB3
04872:  MOVLW  BA
04874:  MOVWF  xB2
04876:  MOVLB  0
04878:  RCALL  4256
....................             strcat(SMS_MassageSUM, spacestring);
0487A:  MOVLW  06
0487C:  MOVLB  7
0487E:  MOVWF  xB1
04880:  MOVLW  9A
04882:  MOVWF  xB0
04884:  MOVLW  07
04886:  MOVWF  xB3
04888:  MOVLW  3A
0488A:  MOVWF  xB2
0488C:  MOVLB  0
0488E:  RCALL  4256
04890:  MOVLB  7
....................                /*
....................             fprintf(CH2,"AT+CMGF=1"); 
....................             putc('\n',CH2);
....................             delay_ms(10);
.................... 
....................             fprintf(CH2,"AT+CMGS=\"");
....................             fprintf(CH2,sms_phonenumber);
....................             
....................             printf("\"");
....................             putc('\n',CH2);
....................             delay_ms(50);
....................            
....................            fprintf(CH2,SMS_Massage1);
....................            putc('\n',CH2);
....................            putc(26,CH2);
....................           */
....................          }  
....................       }
04892:  BRA    489A
....................       else
....................       {
....................          Output.B2 = 1;
04894:  BSF    x3F.1
....................          SendSMS.B2 =0;
04896:  BCF    x4C.1
....................          functointest_f =0;
04898:  BCF    32.1
....................       }
....................    }
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //input3
....................    if(AlarmIndicator.B3 == 1)    // Alarm Function
0489A:  BTFSS  x44.2
0489C:  BRA    494A
....................    {
....................       if((((Inputt.B3 ^ InputType.B3) == 1) && (FaultType.B3 == 1))|| In.B3 == 1)    // alarm1 occure and "Lock type"
0489E:  MOVLW  00
048A0:  BTFSC  x3E.2
048A2:  MOVLW  01
048A4:  MOVWF  xB1
048A6:  MOVLW  00
048A8:  BTFSC  x40.2
048AA:  MOVLW  01
048AC:  XORWF  xB1,W
048AE:  SUBLW  01
048B0:  BNZ   48B6
048B2:  BTFSC  x41.2
048B4:  BRA    48BA
048B6:  BTFSS  x46.2
048B8:  BRA    4942
....................       //if(Inputt.B3 == 0)
....................       {
....................          if(Ack.B3 == 0)
048BA:  BTFSC  x45.2
048BC:  BRA    4906
....................          {
....................             if(In.B3 == 0 && AutoAck == 0x0F)   //use auto acknowlegde
048BE:  BTFSC  x46.2
048C0:  BRA    48DA
048C2:  MOVLB  0
048C4:  MOVF   x6C,W
048C6:  SUBLW  0F
048C8:  BTFSC  FD8.2
048CA:  BRA    48D0
048CC:  MOVLB  7
048CE:  BRA    48DA
....................             {
....................                TimeBase1s = 100 ;            //reload again
048D0:  MOVLW  64
048D2:  MOVWF  1E
....................                AutoAckDelayTime = AutoAckTime ;
048D4:  MOVFF  6D,1F
048D8:  MOVLB  7
....................             }
.................... 
....................             In.B3 = 1;                                 // setbit in1
048DA:  BSF    x46.2
....................             if(FlashingFlag == 0)
048DC:  BTFSC  1C.1
048DE:  BRA    48E4
....................             {
....................                Output.B3 = 0;           //Flash output1
048E0:  BCF    x3F.2
....................             }
048E2:  BRA    48E6
....................             else
....................             {
....................                Output.B3 = 1;
048E4:  BSF    x3F.2
....................             }
.................... 
....................             if (~AutoTestFlag)
048E6:  BTFSC  1C.4
048E8:  BRA    4906
....................             {
....................                
....................                if(OutputBoth.B3 == 0)                  //Both output
048EA:  BTFSC  x43.2
048EC:  BRA    48F8
....................                {
....................                   output_bit(Pbuzzer,0);   //Buzzer
048EE:  BCF    F89.4
048F0:  BCF    F92.4
....................                   output_bit(Pbell,0);     //Bell
048F2:  BCF    F89.3
048F4:  BCF    F92.3
....................                }
048F6:  BRA    4906
....................                else
....................                {
....................                   if(OutputType.B3 == 1) output_bit(Pbuzzer,0);     //Buzzer
048F8:  BTFSS  x42.2
048FA:  BRA    4902
048FC:  BCF    F89.4
048FE:  BCF    F92.4
04900:  BRA    4906
....................                   else output_bit(Pbell,0);                          //Bell
04902:  BCF    F89.3
04904:  BCF    F92.3
....................                }
....................                
....................             }
....................           }
....................           // SMS Sending   
....................             if((SendSMS.B3 ==0)&& (functointest_f ==0) && (Ack.B3 ==0))
04906:  BTFSC  x4C.2
04908:  BRA    4940
0490A:  BTFSC  32.1
0490C:  BRA    4940
0490E:  BTFSC  x45.2
04910:  BRA    4940
....................             {               
....................                SendSMS.B3 =1;
04912:  BSF    x4C.2
....................                strcat(SMS_MassageSUM, SMS_Massage3);
04914:  MOVLW  06
04916:  MOVWF  xB1
04918:  MOVLW  9A
0491A:  MOVWF  xB0
0491C:  MOVLW  05
0491E:  MOVWF  xB3
04920:  MOVLW  DA
04922:  MOVWF  xB2
04924:  MOVLB  0
04926:  RCALL  4256
....................                strcat(SMS_MassageSUM, spacestring);
04928:  MOVLW  06
0492A:  MOVLB  7
0492C:  MOVWF  xB1
0492E:  MOVLW  9A
04930:  MOVWF  xB0
04932:  MOVLW  07
04934:  MOVWF  xB3
04936:  MOVLW  3A
04938:  MOVWF  xB2
0493A:  MOVLB  0
0493C:  RCALL  4256
0493E:  MOVLB  7
....................                /*
....................                fprintf(CH2,"AT+CMGF=1"); 
....................                putc('\n',CH2);
....................                delay_ms(10);
.................... 
....................                fprintf(CH2,"AT+CMGS=\"");
....................                fprintf(CH2,sms_phonenumber);
....................                
....................                fprintf(CH2,"\"");
....................                putc('\n',CH2);
....................                delay_ms(50);
....................               
....................               fprintf(CH2,SMS_Massage3);
....................               putc('\n',CH2);
....................              putc(26,CH2);
....................           */
....................             }
.................... 
....................       }
04940:  BRA    4948
....................       else if(FaultType.B3 == 1) Ack.B3 = 0;
04942:  BTFSS  x41.2
04944:  BRA    4948
04946:  BCF    x45.2
....................    }
04948:  BRA    49A2
....................    else  //Indicator Function
....................    {
....................       if((Inputt.B3 ^ InputType.B3) == 1)
0494A:  MOVLW  00
0494C:  BTFSC  x3E.2
0494E:  MOVLW  01
04950:  MOVWF  xB1
04952:  MOVLW  00
04954:  BTFSC  x40.2
04956:  MOVLW  01
04958:  XORWF  xB1,W
0495A:  SUBLW  01
0495C:  BNZ   499C
....................       {
....................          Output.B3 = 0;
0495E:  BCF    x3F.2
....................          // SMS Sending   
....................          if((SendSMS.B3 ==0)&& (functointest_f ==0) && (Ack.B3 ==0))
04960:  BTFSC  x4C.2
04962:  BRA    499A
04964:  BTFSC  32.1
04966:  BRA    499A
04968:  BTFSC  x45.2
0496A:  BRA    499A
....................          {            
....................             SendSMS.B3 =1;
0496C:  BSF    x4C.2
....................             strcat(SMS_MassageSUM, SMS_Massage3);
0496E:  MOVLW  06
04970:  MOVWF  xB1
04972:  MOVLW  9A
04974:  MOVWF  xB0
04976:  MOVLW  05
04978:  MOVWF  xB3
0497A:  MOVLW  DA
0497C:  MOVWF  xB2
0497E:  MOVLB  0
04980:  RCALL  4256
....................             strcat(SMS_MassageSUM, spacestring);
04982:  MOVLW  06
04984:  MOVLB  7
04986:  MOVWF  xB1
04988:  MOVLW  9A
0498A:  MOVWF  xB0
0498C:  MOVLW  07
0498E:  MOVWF  xB3
04990:  MOVLW  3A
04992:  MOVWF  xB2
04994:  MOVLB  0
04996:  RCALL  4256
04998:  MOVLB  7
....................                /*
....................             fprintf(CH2,"AT+CMGF=1"); 
....................             putc('\n',CH2);
....................             delay_ms(10);
.................... 
....................             fprintf(CH2,"AT+CMGS=\"");
....................             fprintf(CH2,sms_phonenumber);
....................             
....................             fprintf(CH2,"\"");
....................             putc('\n',CH2);
....................             delay_ms(50);
....................            
....................            fprintf(CH2,SMS_Massage3);
....................            putc('\n',CH2);
....................           putc(26,CH2);
....................           */
....................          }
....................       }
0499A:  BRA    49A2
....................       else
....................       {
....................          Output.B3 = 1;
0499C:  BSF    x3F.2
....................          SendSMS.B3 =0;
0499E:  BCF    x4C.2
....................        functointest_f =0;
049A0:  BCF    32.1
....................       }
....................    }
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //input4
....................    if(AlarmIndicator.B4 == 1)    // Alarm Function
049A2:  BTFSS  x44.3
049A4:  BRA    4A52
....................    {
....................       if((((Inputt.B4 ^ InputType.B4) == 1) && (FaultType.B4 == 1))|| In.B4 == 1)    // alarm1 occure and "Lock type"
049A6:  MOVLW  00
049A8:  BTFSC  x3E.3
049AA:  MOVLW  01
049AC:  MOVWF  xB1
049AE:  MOVLW  00
049B0:  BTFSC  x40.3
049B2:  MOVLW  01
049B4:  XORWF  xB1,W
049B6:  SUBLW  01
049B8:  BNZ   49BE
049BA:  BTFSC  x41.3
049BC:  BRA    49C2
049BE:  BTFSS  x46.3
049C0:  BRA    4A4A
....................       //if(Inputt.B4 == 0)
....................       {
....................          if(Ack.B4 == 0)
049C2:  BTFSC  x45.3
049C4:  BRA    4A0E
....................          {
....................             if(In.B4 == 0 && AutoAck == 0x0F)   //use auto acknowlegde
049C6:  BTFSC  x46.3
049C8:  BRA    49E2
049CA:  MOVLB  0
049CC:  MOVF   x6C,W
049CE:  SUBLW  0F
049D0:  BTFSC  FD8.2
049D2:  BRA    49D8
049D4:  MOVLB  7
049D6:  BRA    49E2
....................             {
....................                TimeBase1s = 100 ;            //reload again
049D8:  MOVLW  64
049DA:  MOVWF  1E
....................                AutoAckDelayTime = AutoAckTime ;
049DC:  MOVFF  6D,1F
049E0:  MOVLB  7
....................             }
.................... 
....................             In.B4 = 1;                                 // setbit in1
049E2:  BSF    x46.3
....................             if(FlashingFlag == 0)
049E4:  BTFSC  1C.1
049E6:  BRA    49EC
....................             {
....................                Output.B4 = 0;           //Flash output1
049E8:  BCF    x3F.3
....................             }
049EA:  BRA    49EE
....................             else
....................             {
....................                Output.B4 = 1;
049EC:  BSF    x3F.3
....................             }
.................... 
....................             if (~AutoTestFlag)
049EE:  BTFSC  1C.4
049F0:  BRA    4A0E
....................             {
....................                
....................                if(OutputBoth.B4 == 0)                  //Both output
049F2:  BTFSC  x43.3
049F4:  BRA    4A00
....................                {
....................                   output_bit(Pbuzzer,0);   //Buzzer
049F6:  BCF    F89.4
049F8:  BCF    F92.4
....................                   output_bit(Pbell,0);     //Bell
049FA:  BCF    F89.3
049FC:  BCF    F92.3
....................                }
049FE:  BRA    4A0E
....................                else
....................                {
....................                   if(OutputType.B4 == 1) output_bit(Pbuzzer,0);     //Buzzer
04A00:  BTFSS  x42.3
04A02:  BRA    4A0A
04A04:  BCF    F89.4
04A06:  BCF    F92.4
04A08:  BRA    4A0E
....................                   else output_bit(Pbell,0);                          //Bell
04A0A:  BCF    F89.3
04A0C:  BCF    F92.3
....................                }
....................                
....................             }
....................           }
....................           // SMS Sending   
....................             if((SendSMS.B4 ==0)&& (functointest_f ==0) && (Ack.B4 ==0))
04A0E:  BTFSC  x4C.3
04A10:  BRA    4A48
04A12:  BTFSC  32.1
04A14:  BRA    4A48
04A16:  BTFSC  x45.3
04A18:  BRA    4A48
....................             {               
....................                SendSMS.B4 =1;
04A1A:  BSF    x4C.3
....................                strcat(SMS_MassageSUM, SMS_Massage4);
04A1C:  MOVLW  06
04A1E:  MOVWF  xB1
04A20:  MOVLW  9A
04A22:  MOVWF  xB0
04A24:  MOVLW  05
04A26:  MOVWF  xB3
04A28:  MOVLW  FA
04A2A:  MOVWF  xB2
04A2C:  MOVLB  0
04A2E:  RCALL  4256
....................                strcat(SMS_MassageSUM, spacestring);
04A30:  MOVLW  06
04A32:  MOVLB  7
04A34:  MOVWF  xB1
04A36:  MOVLW  9A
04A38:  MOVWF  xB0
04A3A:  MOVLW  07
04A3C:  MOVWF  xB3
04A3E:  MOVLW  3A
04A40:  MOVWF  xB2
04A42:  MOVLB  0
04A44:  RCALL  4256
04A46:  MOVLB  7
....................                /*
....................                fprintf(CH2,"AT+CMGF=1"); 
....................                putc('\n',CH2);
....................                delay_ms(10);
.................... 
....................                fprintf(CH2,"AT+CMGS=\"");
....................                fprintf(CH2,sms_phonenumber);
....................             
....................                fprintf(CH2,"\"");
....................                putc('\n',CH2);
....................                delay_ms(50);
....................               
....................               fprintf(CH2,SMS_Massage4);
....................               putc('\n',CH2);
....................              putc(26,CH2);
....................           */
....................             }
.................... 
....................       }
04A48:  BRA    4A50
....................       else if(FaultType.B4 == 1) Ack.B4 = 0;
04A4A:  BTFSS  x41.3
04A4C:  BRA    4A50
04A4E:  BCF    x45.3
....................    }
04A50:  BRA    4AAE
....................    else  //Indicator Function
....................    {
....................       if((Inputt.B4 ^ InputType.B4) == 1)
04A52:  MOVLW  00
04A54:  BTFSC  x3E.3
04A56:  MOVLW  01
04A58:  MOVWF  xB1
04A5A:  MOVLW  00
04A5C:  BTFSC  x40.3
04A5E:  MOVLW  01
04A60:  XORWF  xB1,W
04A62:  SUBLW  01
04A64:  BNZ   4AA8
....................       {
....................          Output.B4 = 0;
04A66:  BCF    x3F.3
....................          
....................          // SMS Sending   
....................          if((SendSMS.B4 ==0)&& (functointest_f ==0) && (Ack.B4 ==0))
04A68:  BTFSC  x4C.3
04A6A:  BRA    4AA6
04A6C:  BTFSC  32.1
04A6E:  BRA    4AA6
04A70:  BTFSC  x45.3
04A72:  BRA    4AA6
....................          {            
....................             SendSMS.B4 =1;
04A74:  BSF    x4C.3
....................             strcat(SMS_MassageSUM, SMS_Massage4);
04A76:  MOVLW  06
04A78:  MOVWF  xB1
04A7A:  MOVLW  9A
04A7C:  MOVWF  xB0
04A7E:  MOVLW  05
04A80:  MOVWF  xB3
04A82:  MOVLW  FA
04A84:  MOVWF  xB2
04A86:  MOVLB  0
04A88:  CALL   4256
....................             strcat(SMS_MassageSUM, spacestring);
04A8C:  MOVLW  06
04A8E:  MOVLB  7
04A90:  MOVWF  xB1
04A92:  MOVLW  9A
04A94:  MOVWF  xB0
04A96:  MOVLW  07
04A98:  MOVWF  xB3
04A9A:  MOVLW  3A
04A9C:  MOVWF  xB2
04A9E:  MOVLB  0
04AA0:  CALL   4256
04AA4:  MOVLB  7
....................                /*
....................             fprintf(CH2,"AT+CMGF=1"); 
....................             putc('\n',CH2);
....................             delay_ms(10);
.................... 
....................             fprintf(CH2,"AT+CMGS=\"");
....................             fprintf(CH2,sms_phonenumber);
....................          
....................             fprintf(CH2,"\"");
....................             putc('\n',CH2);
....................             delay_ms(50);
....................            
....................            fprintf(CH2,SMS_Massage4);
....................            putc('\n',CH2);
....................           putc(26,CH2);
....................           */
....................          }
....................       }
04AA6:  BRA    4AAE
....................       else
....................       {
....................          Output.B4 = 1;
04AA8:  BSF    x3F.3
....................          SendSMS.B4 =0;
04AAA:  BCF    x4C.3
....................        functointest_f =0;
04AAC:  BCF    32.1
....................       }
....................    }
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //input5
....................    if(AlarmIndicator.B5 == 1)    // Alarm Function
04AAE:  BTFSS  x44.4
04AB0:  BRA    4B62
....................    {
....................       if((((Inputt.B5 ^ InputType.B5) == 1) && (FaultType.B5 == 1))|| In.B5 == 1)    // alarm1 occure and "Lock type"
04AB2:  MOVLW  00
04AB4:  BTFSC  x3E.4
04AB6:  MOVLW  01
04AB8:  MOVWF  xB1
04ABA:  MOVLW  00
04ABC:  BTFSC  x40.4
04ABE:  MOVLW  01
04AC0:  XORWF  xB1,W
04AC2:  SUBLW  01
04AC4:  BNZ   4ACA
04AC6:  BTFSC  x41.4
04AC8:  BRA    4ACE
04ACA:  BTFSS  x46.4
04ACC:  BRA    4B5A
....................       //if(Inputt.B5 == 0)
....................       {
....................          if(Ack.B5 == 0)
04ACE:  BTFSC  x45.4
04AD0:  BRA    4B1A
....................          {
....................             if(In.B5 == 0 && AutoAck == 0x0F)   //use auto acknowlegde
04AD2:  BTFSC  x46.4
04AD4:  BRA    4AEE
04AD6:  MOVLB  0
04AD8:  MOVF   x6C,W
04ADA:  SUBLW  0F
04ADC:  BTFSC  FD8.2
04ADE:  BRA    4AE4
04AE0:  MOVLB  7
04AE2:  BRA    4AEE
....................             {
....................                TimeBase1s = 100 ;            //reload again
04AE4:  MOVLW  64
04AE6:  MOVWF  1E
....................                AutoAckDelayTime = AutoAckTime ;
04AE8:  MOVFF  6D,1F
04AEC:  MOVLB  7
....................             }
.................... 
....................             In.B5 = 1;                                 // setbit in1
04AEE:  BSF    x46.4
....................             if(FlashingFlag == 0)
04AF0:  BTFSC  1C.1
04AF2:  BRA    4AF8
....................             {
....................                Output.B5 = 0;           //Flash output1
04AF4:  BCF    x3F.4
....................             }
04AF6:  BRA    4AFA
....................             else
....................             {
....................                Output.B5 = 1;
04AF8:  BSF    x3F.4
....................             }
.................... 
....................             if (~AutoTestFlag)
04AFA:  BTFSC  1C.4
04AFC:  BRA    4B1A
....................             {
....................                
....................                if(OutputBoth.B5 == 0)                  //Both output
04AFE:  BTFSC  x43.4
04B00:  BRA    4B0C
....................                {
....................                   output_bit(Pbuzzer,0);   //Buzzer
04B02:  BCF    F89.4
04B04:  BCF    F92.4
....................                   output_bit(Pbell,0);     //Bell
04B06:  BCF    F89.3
04B08:  BCF    F92.3
....................                }
04B0A:  BRA    4B1A
....................                else
....................                {
....................                   if(OutputType.B5 == 1) output_bit(Pbuzzer,0);     //Buzzer
04B0C:  BTFSS  x42.4
04B0E:  BRA    4B16
04B10:  BCF    F89.4
04B12:  BCF    F92.4
04B14:  BRA    4B1A
....................                   else output_bit(Pbell,0);                          //Bell
04B16:  BCF    F89.3
04B18:  BCF    F92.3
....................                }
....................                
....................             }
....................           }
....................           
....................           // SMS Sending   
....................             if((SendSMS.B5 ==0)&& (functointest_f ==0) && (Ack.B5 ==0))
04B1A:  BTFSC  x4C.4
04B1C:  BRA    4B58
04B1E:  BTFSC  32.1
04B20:  BRA    4B58
04B22:  BTFSC  x45.4
04B24:  BRA    4B58
....................             {               
....................                SendSMS.B5 =1;
04B26:  BSF    x4C.4
....................                strcat(SMS_MassageSUM, SMS_Massage5);
04B28:  MOVLW  06
04B2A:  MOVWF  xB1
04B2C:  MOVLW  9A
04B2E:  MOVWF  xB0
04B30:  MOVLW  06
04B32:  MOVWF  xB3
04B34:  MOVLW  1A
04B36:  MOVWF  xB2
04B38:  MOVLB  0
04B3A:  CALL   4256
....................                strcat(SMS_MassageSUM, spacestring);
04B3E:  MOVLW  06
04B40:  MOVLB  7
04B42:  MOVWF  xB1
04B44:  MOVLW  9A
04B46:  MOVWF  xB0
04B48:  MOVLW  07
04B4A:  MOVWF  xB3
04B4C:  MOVLW  3A
04B4E:  MOVWF  xB2
04B50:  MOVLB  0
04B52:  CALL   4256
04B56:  MOVLB  7
....................                /*
....................                fprintf(CH2,"AT+CMGF=1"); 
....................                putc('\n',CH2);
....................                delay_ms(10);
.................... 
....................                fprintf(CH2,"AT+CMGS=\"");
....................                fprintf(CH2,sms_phonenumber);
....................                
....................                fprintf(CH2,"\"");
....................                putc('\n',CH2);
....................                delay_ms(50);
....................               
....................               fprintf(CH2,SMS_Massage5);
....................               putc('\n',CH2);
....................              putc(26,CH2);
....................           */
....................             }
.................... 
....................       }
04B58:  BRA    4B60
....................       else if(FaultType.B5 == 1) Ack.B5 = 0;
04B5A:  BTFSS  x41.4
04B5C:  BRA    4B60
04B5E:  BCF    x45.4
....................    }
04B60:  BRA    4BBE
....................    else  //Indicator Function
....................    {
....................       if((Inputt.B5 ^ InputType.B5) == 1)
04B62:  MOVLW  00
04B64:  BTFSC  x3E.4
04B66:  MOVLW  01
04B68:  MOVWF  xB1
04B6A:  MOVLW  00
04B6C:  BTFSC  x40.4
04B6E:  MOVLW  01
04B70:  XORWF  xB1,W
04B72:  SUBLW  01
04B74:  BNZ   4BB8
....................       {
....................          Output.B5 = 0;
04B76:  BCF    x3F.4
....................          // SMS Sending   
....................          if((SendSMS.B5 ==0)&& (functointest_f ==0) && (Ack.B5 ==0))
04B78:  BTFSC  x4C.4
04B7A:  BRA    4BB6
04B7C:  BTFSC  32.1
04B7E:  BRA    4BB6
04B80:  BTFSC  x45.4
04B82:  BRA    4BB6
....................          {            
....................             SendSMS.B5 =1;
04B84:  BSF    x4C.4
....................             strcat(SMS_MassageSUM, SMS_Massage5);
04B86:  MOVLW  06
04B88:  MOVWF  xB1
04B8A:  MOVLW  9A
04B8C:  MOVWF  xB0
04B8E:  MOVLW  06
04B90:  MOVWF  xB3
04B92:  MOVLW  1A
04B94:  MOVWF  xB2
04B96:  MOVLB  0
04B98:  CALL   4256
....................             strcat(SMS_MassageSUM, spacestring);
04B9C:  MOVLW  06
04B9E:  MOVLB  7
04BA0:  MOVWF  xB1
04BA2:  MOVLW  9A
04BA4:  MOVWF  xB0
04BA6:  MOVLW  07
04BA8:  MOVWF  xB3
04BAA:  MOVLW  3A
04BAC:  MOVWF  xB2
04BAE:  MOVLB  0
04BB0:  CALL   4256
04BB4:  MOVLB  7
....................                /*
....................             fprintf(CH2,"AT+CMGF=1"); 
....................             putc('\n',CH2);
....................             delay_ms(10);
.................... 
....................             fprintf(CH2,"AT+CMGS=\"");
....................             fprintf(CH2,sms_phonenumber);
....................             
....................             fprintf(CH2,"\"");
....................             putc('\n',CH2);
....................             delay_ms(50);
....................            
....................            fprintf(CH2,SMS_Massage5);  
....................            putc('\n',CH2);
....................           putc(26,CH2);
....................           */
....................          }
....................       }
04BB6:  BRA    4BBE
....................       else
....................       {
....................          Output.B5 = 1;
04BB8:  BSF    x3F.4
....................          SendSMS.B5 =0;
04BBA:  BCF    x4C.4
....................        functointest_f =0;
04BBC:  BCF    32.1
....................       }
....................    }
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //input6
....................    if(AlarmIndicator.B6 == 1)    // Alarm Function
04BBE:  BTFSS  x44.5
04BC0:  BRA    4C72
....................    {
....................       if((((Inputt.B6 ^ InputType.B6) == 1) && (FaultType.B6 == 1))|| In.B6 == 1)    // alarm1 occure and "Lock type"
04BC2:  MOVLW  00
04BC4:  BTFSC  x3E.5
04BC6:  MOVLW  01
04BC8:  MOVWF  xB1
04BCA:  MOVLW  00
04BCC:  BTFSC  x40.5
04BCE:  MOVLW  01
04BD0:  XORWF  xB1,W
04BD2:  SUBLW  01
04BD4:  BNZ   4BDA
04BD6:  BTFSC  x41.5
04BD8:  BRA    4BDE
04BDA:  BTFSS  x46.5
04BDC:  BRA    4C6A
....................       //if(Inputt.B6 == 0)
....................       {
....................          if(Ack.B6 == 0)
04BDE:  BTFSC  x45.5
04BE0:  BRA    4C2A
....................          {
....................             if(In.B6 == 0 && AutoAck == 0x0F)   //use auto acknowlegde
04BE2:  BTFSC  x46.5
04BE4:  BRA    4BFE
04BE6:  MOVLB  0
04BE8:  MOVF   x6C,W
04BEA:  SUBLW  0F
04BEC:  BTFSC  FD8.2
04BEE:  BRA    4BF4
04BF0:  MOVLB  7
04BF2:  BRA    4BFE
....................             {
....................                TimeBase1s = 100 ;            //reload again
04BF4:  MOVLW  64
04BF6:  MOVWF  1E
....................                AutoAckDelayTime = AutoAckTime ;
04BF8:  MOVFF  6D,1F
04BFC:  MOVLB  7
....................             }
.................... 
....................             In.B6 = 1;                                 // setbit in1
04BFE:  BSF    x46.5
....................             if(FlashingFlag == 0)
04C00:  BTFSC  1C.1
04C02:  BRA    4C08
....................             {
....................                Output.B6 = 0;           //Flash output1
04C04:  BCF    x3F.5
....................             }
04C06:  BRA    4C0A
....................             else
....................             {
....................                Output.B6 = 1;
04C08:  BSF    x3F.5
....................             }
.................... 
....................             if (~AutoTestFlag)
04C0A:  BTFSC  1C.4
04C0C:  BRA    4C2A
....................             {
....................                
....................                if(OutputBoth.B6 == 0)                  //Both output
04C0E:  BTFSC  x43.5
04C10:  BRA    4C1C
....................                {
....................                   output_bit(Pbuzzer,0);   //Buzzer
04C12:  BCF    F89.4
04C14:  BCF    F92.4
....................                   output_bit(Pbell,0);     //Bell
04C16:  BCF    F89.3
04C18:  BCF    F92.3
....................                }
04C1A:  BRA    4C2A
....................                else
....................                {
....................                   if(OutputType.B6 == 1) output_bit(Pbuzzer,0);     //Buzzer
04C1C:  BTFSS  x42.5
04C1E:  BRA    4C26
04C20:  BCF    F89.4
04C22:  BCF    F92.4
04C24:  BRA    4C2A
....................                   else output_bit(Pbell,0);                          //Bell
04C26:  BCF    F89.3
04C28:  BCF    F92.3
....................                }
....................                
....................             }
....................           }
....................           
....................           // SMS Sending   
....................             if((SendSMS.B6 ==0)&& (functointest_f ==0) && (Ack.B6 ==0))
04C2A:  BTFSC  x4C.5
04C2C:  BRA    4C68
04C2E:  BTFSC  32.1
04C30:  BRA    4C68
04C32:  BTFSC  x45.5
04C34:  BRA    4C68
....................             {               
....................                SendSMS.B6 =1;
04C36:  BSF    x4C.5
....................                strcat(SMS_MassageSUM, SMS_Massage6);
04C38:  MOVLW  06
04C3A:  MOVWF  xB1
04C3C:  MOVLW  9A
04C3E:  MOVWF  xB0
04C40:  MOVLW  06
04C42:  MOVWF  xB3
04C44:  MOVLW  3A
04C46:  MOVWF  xB2
04C48:  MOVLB  0
04C4A:  CALL   4256
....................                strcat(SMS_MassageSUM, spacestring);
04C4E:  MOVLW  06
04C50:  MOVLB  7
04C52:  MOVWF  xB1
04C54:  MOVLW  9A
04C56:  MOVWF  xB0
04C58:  MOVLW  07
04C5A:  MOVWF  xB3
04C5C:  MOVLW  3A
04C5E:  MOVWF  xB2
04C60:  MOVLB  0
04C62:  CALL   4256
04C66:  MOVLB  7
....................                /*
....................                fprintf(CH2,"AT+CMGF=1"); 
....................                putc('\n',CH2);
....................                delay_ms(10);
.................... 
....................                fprintf(CH2,"AT+CMGS=\"");
....................                fprintf(CH2,sms_phonenumber);
....................                
....................                fprintf(CH2,"\"");
....................                putc('\n',CH2);
....................                delay_ms(50);
....................               
....................               fprintf(CH2,SMS_Massage6);
....................               putc('\n',CH2);
....................              putc(26,CH2);
....................           */
....................             }
.................... 
....................       }
04C68:  BRA    4C70
....................       else if(FaultType.B6 == 1) Ack.B6 = 0;
04C6A:  BTFSS  x41.5
04C6C:  BRA    4C70
04C6E:  BCF    x45.5
....................    }
04C70:  BRA    4CCE
....................    else  //Indicator Function
....................    {
....................       if((Inputt.B6 ^ InputType.B6) == 1)
04C72:  MOVLW  00
04C74:  BTFSC  x3E.5
04C76:  MOVLW  01
04C78:  MOVWF  xB1
04C7A:  MOVLW  00
04C7C:  BTFSC  x40.5
04C7E:  MOVLW  01
04C80:  XORWF  xB1,W
04C82:  SUBLW  01
04C84:  BNZ   4CC8
....................       {
....................          Output.B6 = 0;
04C86:  BCF    x3F.5
....................          // SMS Sending   
....................          if((SendSMS.B6 ==0)&& (functointest_f ==0) && (Ack.B6 ==0))
04C88:  BTFSC  x4C.5
04C8A:  BRA    4CC6
04C8C:  BTFSC  32.1
04C8E:  BRA    4CC6
04C90:  BTFSC  x45.5
04C92:  BRA    4CC6
....................          {            
....................             
....................             SendSMS.B6 =1;
04C94:  BSF    x4C.5
....................             strcat(SMS_MassageSUM, SMS_Massage6);
04C96:  MOVLW  06
04C98:  MOVWF  xB1
04C9A:  MOVLW  9A
04C9C:  MOVWF  xB0
04C9E:  MOVLW  06
04CA0:  MOVWF  xB3
04CA2:  MOVLW  3A
04CA4:  MOVWF  xB2
04CA6:  MOVLB  0
04CA8:  CALL   4256
....................             strcat(SMS_MassageSUM, spacestring);
04CAC:  MOVLW  06
04CAE:  MOVLB  7
04CB0:  MOVWF  xB1
04CB2:  MOVLW  9A
04CB4:  MOVWF  xB0
04CB6:  MOVLW  07
04CB8:  MOVWF  xB3
04CBA:  MOVLW  3A
04CBC:  MOVWF  xB2
04CBE:  MOVLB  0
04CC0:  CALL   4256
04CC4:  MOVLB  7
....................                /*
....................             fprintf(CH2,"AT+CMGF=1"); 
....................             putc('\n',CH2);
....................             delay_ms(10);
.................... 
....................             fprintf(CH2,"AT+CMGS=\"");
....................             fprintf(CH2,sms_phonenumber);
....................             
....................             fprintf(CH2,"\"");
....................             putc('\n',CH2);
....................             delay_ms(50);
....................            
....................            fprintf(CH2,SMS_Massage6);  
....................            putc('\n',CH2);
....................           putc(26,CH2);
....................           */
....................          }
....................       }
04CC6:  BRA    4CCE
....................       else
....................       {
....................          Output.B6 = 1;
04CC8:  BSF    x3F.5
....................          SendSMS.B6 =0;
04CCA:  BCF    x4C.5
....................        functointest_f =0;
04CCC:  BCF    32.1
....................       }
....................    }
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //input7
....................    if(AlarmIndicator.B7 == 1)    // Alarm Function
04CCE:  BTFSS  x44.6
04CD0:  BRA    4D82
....................    {
....................       if((((Inputt.B7 ^ InputType.B7) == 1) && (FaultType.B7 == 1))|| In.B7 == 1)    // alarm1 occure and "Lock type"
04CD2:  MOVLW  00
04CD4:  BTFSC  x3E.6
04CD6:  MOVLW  01
04CD8:  MOVWF  xB1
04CDA:  MOVLW  00
04CDC:  BTFSC  x40.6
04CDE:  MOVLW  01
04CE0:  XORWF  xB1,W
04CE2:  SUBLW  01
04CE4:  BNZ   4CEA
04CE6:  BTFSC  x41.6
04CE8:  BRA    4CEE
04CEA:  BTFSS  x46.6
04CEC:  BRA    4D7A
....................       //if(Inputt.B7 == 0)
....................       {
....................          if(Ack.B7 == 0)
04CEE:  BTFSC  x45.6
04CF0:  BRA    4D3A
....................          {
....................             if(In.B7 == 0 && AutoAck == 0x0F)   //use auto acknowlegde
04CF2:  BTFSC  x46.6
04CF4:  BRA    4D0E
04CF6:  MOVLB  0
04CF8:  MOVF   x6C,W
04CFA:  SUBLW  0F
04CFC:  BTFSC  FD8.2
04CFE:  BRA    4D04
04D00:  MOVLB  7
04D02:  BRA    4D0E
....................             {
....................                TimeBase1s = 100 ;            //reload again
04D04:  MOVLW  64
04D06:  MOVWF  1E
....................                AutoAckDelayTime = AutoAckTime ;
04D08:  MOVFF  6D,1F
04D0C:  MOVLB  7
....................             }
.................... 
....................             In.B7 = 1;                                 // setbit in1
04D0E:  BSF    x46.6
....................             if(FlashingFlag == 0)
04D10:  BTFSC  1C.1
04D12:  BRA    4D18
....................             {
....................                Output.B7 = 0;           //Flash output1
04D14:  BCF    x3F.6
....................             }
04D16:  BRA    4D1A
....................             else
....................             {
....................                Output.B7 = 1;
04D18:  BSF    x3F.6
....................             }
.................... 
....................             if (~AutoTestFlag)
04D1A:  BTFSC  1C.4
04D1C:  BRA    4D3A
....................             {
....................                
....................                if(OutputBoth.B7 == 0)                  //Both output
04D1E:  BTFSC  x43.6
04D20:  BRA    4D2C
....................                {
....................                   output_bit(Pbuzzer,0);   //Buzzer
04D22:  BCF    F89.4
04D24:  BCF    F92.4
....................                   output_bit(Pbell,0);     //Bell
04D26:  BCF    F89.3
04D28:  BCF    F92.3
....................                }
04D2A:  BRA    4D3A
....................                else
....................                {
....................                   if(OutputType.B7 == 1) output_bit(Pbuzzer,0);     //Buzzer
04D2C:  BTFSS  x42.6
04D2E:  BRA    4D36
04D30:  BCF    F89.4
04D32:  BCF    F92.4
04D34:  BRA    4D3A
....................                   else output_bit(Pbell,0);                          //Bell
04D36:  BCF    F89.3
04D38:  BCF    F92.3
....................                }
....................                
....................             }
....................           }
....................           
....................           // SMS Sending   
....................             if((SendSMS.B7 ==0)&& (functointest_f ==0) && (Ack.B7 ==0))
04D3A:  BTFSC  x4C.6
04D3C:  BRA    4D78
04D3E:  BTFSC  32.1
04D40:  BRA    4D78
04D42:  BTFSC  x45.6
04D44:  BRA    4D78
....................             {               
....................                SendSMS.B7 =1;
04D46:  BSF    x4C.6
....................                strcat(SMS_MassageSUM, SMS_Massage7);
04D48:  MOVLW  06
04D4A:  MOVWF  xB1
04D4C:  MOVLW  9A
04D4E:  MOVWF  xB0
04D50:  MOVLW  06
04D52:  MOVWF  xB3
04D54:  MOVLW  5A
04D56:  MOVWF  xB2
04D58:  MOVLB  0
04D5A:  CALL   4256
....................                strcat(SMS_MassageSUM, spacestring);
04D5E:  MOVLW  06
04D60:  MOVLB  7
04D62:  MOVWF  xB1
04D64:  MOVLW  9A
04D66:  MOVWF  xB0
04D68:  MOVLW  07
04D6A:  MOVWF  xB3
04D6C:  MOVLW  3A
04D6E:  MOVWF  xB2
04D70:  MOVLB  0
04D72:  CALL   4256
04D76:  MOVLB  7
....................                /*
....................                fprintf(CH2,"AT+CMGF=1"); 
....................                putc('\n',CH2);
....................                delay_ms(10);
.................... 
....................                fprintf(CH2,"AT+CMGS=\"");
....................                fprintf(CH2,sms_phonenumber);
....................                
....................                fprintf(CH2,"\"");
....................                putc('\n',CH2);
....................                delay_ms(50);
....................               
....................               fprintf(CH2,SMS_Massage7);  
....................               putc('\n',CH2);
....................              putc(26,CH2);
....................           */
....................             }
.................... 
....................       }
04D78:  BRA    4D80
....................       else if(FaultType.B7 == 1) Ack.B7 = 0;
04D7A:  BTFSS  x41.6
04D7C:  BRA    4D80
04D7E:  BCF    x45.6
....................    }
04D80:  BRA    4DDE
....................    else  //Indicator Function
....................    {
....................       if((Inputt.B7 ^ InputType.B7) == 1)
04D82:  MOVLW  00
04D84:  BTFSC  x3E.6
04D86:  MOVLW  01
04D88:  MOVWF  xB1
04D8A:  MOVLW  00
04D8C:  BTFSC  x40.6
04D8E:  MOVLW  01
04D90:  XORWF  xB1,W
04D92:  SUBLW  01
04D94:  BNZ   4DD8
....................       {
....................          Output.B7 = 0;
04D96:  BCF    x3F.6
....................          // SMS Sending   
....................          if((SendSMS.B7 ==0)&& (functointest_f ==0) && (Ack.B7 ==0))
04D98:  BTFSC  x4C.6
04D9A:  BRA    4DD6
04D9C:  BTFSC  32.1
04D9E:  BRA    4DD6
04DA0:  BTFSC  x45.6
04DA2:  BRA    4DD6
....................          {            
....................             SendSMS.B7 =1;
04DA4:  BSF    x4C.6
....................             strcat(SMS_MassageSUM, SMS_Massage7);
04DA6:  MOVLW  06
04DA8:  MOVWF  xB1
04DAA:  MOVLW  9A
04DAC:  MOVWF  xB0
04DAE:  MOVLW  06
04DB0:  MOVWF  xB3
04DB2:  MOVLW  5A
04DB4:  MOVWF  xB2
04DB6:  MOVLB  0
04DB8:  CALL   4256
....................             strcat(SMS_MassageSUM, spacestring);
04DBC:  MOVLW  06
04DBE:  MOVLB  7
04DC0:  MOVWF  xB1
04DC2:  MOVLW  9A
04DC4:  MOVWF  xB0
04DC6:  MOVLW  07
04DC8:  MOVWF  xB3
04DCA:  MOVLW  3A
04DCC:  MOVWF  xB2
04DCE:  MOVLB  0
04DD0:  CALL   4256
04DD4:  MOVLB  7
....................                /*
....................             fprintf(CH2,"AT+CMGF=1"); 
....................             putc('\n',CH2);
....................             delay_ms(10);
.................... 
....................             fprintf(CH2,"AT+CMGS=\"");
....................             fprintf(CH2,sms_phonenumber);
....................             
....................             fprintf(CH2,"\"");
....................             putc('\n',CH2);
....................             delay_ms(50);
....................            
....................            fprintf(CH2,SMS_Massage7); 
....................            putc('\n',CH2);
....................           putc(26,CH2);
....................           */
....................          }
....................       }
04DD6:  BRA    4DDE
....................       else
....................       {
....................          Output.B7 = 1;
04DD8:  BSF    x3F.6
....................          SendSMS.B7 =0;
04DDA:  BCF    x4C.6
....................        functointest_f =0;
04DDC:  BCF    32.1
....................       }
....................    }
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //input8
....................    if(AlarmIndicator.B8 == 1)    // Alarm Function
04DDE:  BTFSS  x44.7
04DE0:  BRA    4E92
....................    {
....................       if((((Inputt.B8 ^ InputType.B8) == 1) && (FaultType.B8 == 1))|| In.B8 == 1)    // alarm1 occure and "Lock type"
04DE2:  MOVLW  00
04DE4:  BTFSC  x3E.7
04DE6:  MOVLW  01
04DE8:  MOVWF  xB1
04DEA:  MOVLW  00
04DEC:  BTFSC  x40.7
04DEE:  MOVLW  01
04DF0:  XORWF  xB1,W
04DF2:  SUBLW  01
04DF4:  BNZ   4DFA
04DF6:  BTFSC  x41.7
04DF8:  BRA    4DFE
04DFA:  BTFSS  x46.7
04DFC:  BRA    4E8A
....................       //if(Inputt.B8 == 0)
....................       {
....................          if(Ack.B8 == 0)
04DFE:  BTFSC  x45.7
04E00:  BRA    4E4A
....................          {
....................             if(In.B8 == 0 && AutoAck == 0x0F)   //use auto acknowlegde
04E02:  BTFSC  x46.7
04E04:  BRA    4E1E
04E06:  MOVLB  0
04E08:  MOVF   x6C,W
04E0A:  SUBLW  0F
04E0C:  BTFSC  FD8.2
04E0E:  BRA    4E14
04E10:  MOVLB  7
04E12:  BRA    4E1E
....................             {
....................                TimeBase1s = 100 ;            //reload again
04E14:  MOVLW  64
04E16:  MOVWF  1E
....................                AutoAckDelayTime = AutoAckTime ;
04E18:  MOVFF  6D,1F
04E1C:  MOVLB  7
....................             }
.................... 
....................             In.B8 = 1;                                 // setbit in1
04E1E:  BSF    x46.7
....................             if(FlashingFlag == 0)
04E20:  BTFSC  1C.1
04E22:  BRA    4E28
....................             {
....................                Output.B8 = 0;           //Flash output1
04E24:  BCF    x3F.7
....................             }
04E26:  BRA    4E2A
....................             else
....................             {
....................                Output.B8 = 1;
04E28:  BSF    x3F.7
....................             }
.................... 
....................             if (~AutoTestFlag)
04E2A:  BTFSC  1C.4
04E2C:  BRA    4E4A
....................             {
....................                
....................                if(OutputBoth.B8 == 0)                  //Both output
04E2E:  BTFSC  x43.7
04E30:  BRA    4E3C
....................                {
....................                   output_bit(Pbuzzer,0);   //Buzzer
04E32:  BCF    F89.4
04E34:  BCF    F92.4
....................                   output_bit(Pbell,0);     //Bell
04E36:  BCF    F89.3
04E38:  BCF    F92.3
....................                }
04E3A:  BRA    4E4A
....................                else
....................                {
....................                   if(OutputType.B8 == 1) output_bit(Pbuzzer,0);     //Buzzer
04E3C:  BTFSS  x42.7
04E3E:  BRA    4E46
04E40:  BCF    F89.4
04E42:  BCF    F92.4
04E44:  BRA    4E4A
....................                   else output_bit(Pbell,0);                          //Bell
04E46:  BCF    F89.3
04E48:  BCF    F92.3
....................                }
....................                
....................             }
....................        }
....................      
....................        // SMS Sending   
....................          if((SendSMS.B8 ==0)&& (functointest_f ==0) && (Ack.B8 ==0))
04E4A:  BTFSC  x4C.7
04E4C:  BRA    4E88
04E4E:  BTFSC  32.1
04E50:  BRA    4E88
04E52:  BTFSC  x45.7
04E54:  BRA    4E88
....................          {            
....................             SendSMS.B8 =1;
04E56:  BSF    x4C.7
....................             strcat(SMS_MassageSUM, SMS_Massage8);
04E58:  MOVLW  06
04E5A:  MOVWF  xB1
04E5C:  MOVLW  9A
04E5E:  MOVWF  xB0
04E60:  MOVLW  06
04E62:  MOVWF  xB3
04E64:  MOVLW  7A
04E66:  MOVWF  xB2
04E68:  MOVLB  0
04E6A:  CALL   4256
....................             strcat(SMS_MassageSUM, spacestring);
04E6E:  MOVLW  06
04E70:  MOVLB  7
04E72:  MOVWF  xB1
04E74:  MOVLW  9A
04E76:  MOVWF  xB0
04E78:  MOVLW  07
04E7A:  MOVWF  xB3
04E7C:  MOVLW  3A
04E7E:  MOVWF  xB2
04E80:  MOVLB  0
04E82:  CALL   4256
04E86:  MOVLB  7
....................                /*
....................             fprintf(CH2,"AT+CMGF=1"); 
....................             putc('\n',CH2);
....................             delay_ms(10);
.................... 
....................             fprintf(CH2,"AT+CMGS=\"");
....................             fprintf(CH2,sms_phonenumber);
....................             
....................             fprintf(CH2,"\"");
....................             putc('\n',CH2);
....................             delay_ms(50);
....................            
....................            printf(SMS_Massage8);  
....................            putc('\n',CH2);
....................           putc(26,CH2);
....................           */
....................          }
.................... 
....................       }
04E88:  BRA    4E90
....................       else if(FaultType.B8 == 1) Ack.B8 = 0;
04E8A:  BTFSS  x41.7
04E8C:  BRA    4E90
04E8E:  BCF    x45.7
....................    }
04E90:  BRA    4EEE
....................    else  //Indicator Function
....................    {
....................       if((Inputt.B8 ^ InputType.B8) == 1)
04E92:  MOVLW  00
04E94:  BTFSC  x3E.7
04E96:  MOVLW  01
04E98:  MOVWF  xB1
04E9A:  MOVLW  00
04E9C:  BTFSC  x40.7
04E9E:  MOVLW  01
04EA0:  XORWF  xB1,W
04EA2:  SUBLW  01
04EA4:  BNZ   4EE8
....................       {
....................          Output.B8 = 0;
04EA6:  BCF    x3F.7
....................          // SMS Sending   
....................          if((SendSMS.B8 ==0)&& (functointest_f ==0) && (Ack.B8 ==0))
04EA8:  BTFSC  x4C.7
04EAA:  BRA    4EE6
04EAC:  BTFSC  32.1
04EAE:  BRA    4EE6
04EB0:  BTFSC  x45.7
04EB2:  BRA    4EE6
....................          {            
....................             SendSMS.B8 =1;
04EB4:  BSF    x4C.7
....................             strcat(SMS_MassageSUM, SMS_Massage8);
04EB6:  MOVLW  06
04EB8:  MOVWF  xB1
04EBA:  MOVLW  9A
04EBC:  MOVWF  xB0
04EBE:  MOVLW  06
04EC0:  MOVWF  xB3
04EC2:  MOVLW  7A
04EC4:  MOVWF  xB2
04EC6:  MOVLB  0
04EC8:  CALL   4256
....................             strcat(SMS_MassageSUM, spacestring);
04ECC:  MOVLW  06
04ECE:  MOVLB  7
04ED0:  MOVWF  xB1
04ED2:  MOVLW  9A
04ED4:  MOVWF  xB0
04ED6:  MOVLW  07
04ED8:  MOVWF  xB3
04EDA:  MOVLW  3A
04EDC:  MOVWF  xB2
04EDE:  MOVLB  0
04EE0:  CALL   4256
04EE4:  MOVLB  7
....................                /*
....................             printf("AT+CMGF=1"); 
....................             putc('\n',CH2);
....................             delay_ms(10);
.................... 
....................             fprintf(CH2,"AT+CMGS=\"");
....................             fprintf(CH2,sms_phonenumber);
....................             
....................             fprintf(CH2,"\"");
....................             putc('\n',CH2);
....................             delay_ms(50);
....................            
....................            fprintf(CH2,SMS_Massage8);  
....................            putc('\n',CH2);
....................           putc(26,CH2);
....................           */
....................          }
....................       }
04EE6:  BRA    4EEE
....................       else
....................       {
....................          Output.B8 = 1;
04EE8:  BSF    x3F.7
....................          SendSMS.B8 =0;
04EEA:  BCF    x4C.7
....................        functointest_f =0;
04EEC:  BCF    32.1
....................       }
....................    }
.................... ///////////////////////////////////////////////////////////////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////////////////
.................... /////////////////////////// END MANUAL RESET //////////////////////////////////////////
.................... 
.................... 
....................    /////////////////////////////////////////////////////////////////////////////
....................    ////////////////////////////// AUTO RESET ///////////////////////////////////
....................    /////////////////////////////////////////////////////////////////////////////
.................... 
.................... //if(NoOfPoint >= 10)
.................... //{
.................... 
.................... 
.................... static unsigned char inputflag = 0;
.................... 
.................... //input1
....................    if((((Inputt.B1 ^ InputType.B1) == 1) && (FaultType.B1 == 0)) ||Test_fault==1)   // alarm1 occure and " Non Lock type"
04EEE:  MOVLW  00
04EF0:  BTFSC  x3E.0
04EF2:  MOVLW  01
04EF4:  MOVWF  xB1
04EF6:  MOVLW  00
04EF8:  BTFSC  x40.0
04EFA:  MOVLW  01
04EFC:  XORWF  xB1,W
04EFE:  SUBLW  01
04F00:  BNZ   4F06
04F02:  BTFSS  x41.0
04F04:  BRA    4F0A
04F06:  BTFSS  1C.5
04F08:  BRA    4FA2
....................    {
....................       if(In2.B1 == 0 && AutoAck == 0x0F && Ack.B1 == 0)   //use auto acknowlegde
04F0A:  BTFSC  x47.0
04F0C:  BRA    4F2A
04F0E:  MOVLB  0
04F10:  MOVF   x6C,W
04F12:  SUBLW  0F
04F14:  BTFSC  FD8.2
04F16:  BRA    4F1C
04F18:  MOVLB  7
04F1A:  BRA    4F2A
04F1C:  MOVLB  7
04F1E:  BTFSC  x45.0
04F20:  BRA    4F2A
....................       {
....................             TimeBase1s = 100 ;            //reload again
04F22:  MOVLW  64
04F24:  MOVWF  1E
....................             AutoAckDelayTime = AutoAckTime ;
04F26:  MOVFF  6D,1F
....................       }
.................... 
....................       In2.B1 = 1;
04F2A:  BSF    x47.0
....................       if(Ack.B1 == 0)
04F2C:  BTFSC  x45.0
04F2E:  BRA    4F5E
....................       {
....................          if(FlashingFlag == 0)
04F30:  BTFSC  1C.1
04F32:  BRA    4F38
....................             {
....................                Output.B1 = 0;           //Flash output1
04F34:  BCF    x3F.0
....................             }
04F36:  BRA    4F3A
....................             else
....................             {
....................                Output.B1 = 1;
04F38:  BSF    x3F.0
....................             }
....................          if(~AutoTestFlag)
04F3A:  BTFSC  1C.4
04F3C:  BRA    4F5E
....................          {
....................             if(AlarmIndicator.B1 == 1){
04F3E:  BTFSS  x44.0
04F40:  BRA    4F5E
....................                 if(OutputBoth.B1 == 0)        //Both output
04F42:  BTFSC  x43.0
04F44:  BRA    4F50
....................                 {
....................                   output_bit(Pbuzzer,0);   //Buzzer
04F46:  BCF    F89.4
04F48:  BCF    F92.4
....................                   output_bit(Pbell,0);     //Bell
04F4A:  BCF    F89.3
04F4C:  BCF    F92.3
....................                 }
04F4E:  BRA    4F5E
....................                 else
....................                 {
....................                   if(OutputType.B1 == 1) output_bit(Pbuzzer,0);     //Buzzer
04F50:  BTFSS  x42.0
04F52:  BRA    4F5A
04F54:  BCF    F89.4
04F56:  BCF    F92.4
04F58:  BRA    4F5E
....................                   else output_bit(Pbell,0);                          //Bell
04F5A:  BCF    F89.3
04F5C:  BCF    F92.3
....................                 }
....................             }
....................          }
....................        }
....................       inputflag =1;
04F5E:  MOVLW  01
04F60:  MOVWF  xAD
....................       
....................       // SMS Sending   
....................       if((SendSMS.B1 ==0) && (functointest_f ==0) && (Ack.B1 ==0))
04F62:  BTFSC  x4C.0
04F64:  BRA    4FA0
04F66:  BTFSC  32.1
04F68:  BRA    4FA0
04F6A:  BTFSC  x45.0
04F6C:  BRA    4FA0
....................       {
....................          SendSMS.B1 =1;
04F6E:  BSF    x4C.0
....................          strcat(SMS_MassageSUM, SMS_Massage1);
04F70:  MOVLW  06
04F72:  MOVWF  xB1
04F74:  MOVLW  9A
04F76:  MOVWF  xB0
04F78:  MOVLW  05
04F7A:  MOVWF  xB3
04F7C:  MOVLW  9A
04F7E:  MOVWF  xB2
04F80:  MOVLB  0
04F82:  CALL   4256
....................          strcat(SMS_MassageSUM, spacestring);
04F86:  MOVLW  06
04F88:  MOVLB  7
04F8A:  MOVWF  xB1
04F8C:  MOVLW  9A
04F8E:  MOVWF  xB0
04F90:  MOVLW  07
04F92:  MOVWF  xB3
04F94:  MOVLW  3A
04F96:  MOVWF  xB2
04F98:  MOVLB  0
04F9A:  CALL   4256
04F9E:  MOVLB  7
....................          /*
....................          fprintf(CH2,"AT+CMGS=\"");
....................          fprintf(CH2,sms_phonenumber);
....................          
....................          fprintf(CH2,"\"");
....................          putc('\n',CH2);
....................          delay_ms(50);
....................         
....................         fprintf(CH2,SMS_Massage1);   
....................         putc('\n',CH2);
....................        putc(26,CH2);
....................         */
....................       }
....................    }
04FA0:  BRA    501A
....................    else if(FaultType.B1 == 0)
04FA2:  BTFSC  x41.0
04FA4:  BRA    501A
....................    {
....................       In2.B1 = 0;
04FA6:  BCF    x47.0
....................       Ack.B1 = 0;
04FA8:  BCF    x45.0
....................       Output.B1 = 1;      //Off LED
04FAA:  BSF    x3F.0
....................       
....................       SendSMS.B1 =0;// Clear SMS
04FAC:  BCF    x4C.0
.................... 
....................       if((OutputType.B1 == 1 || OutputBoth.B1 == 0)&& inputflag ==0)      //If Buzzer or Both
04FAE:  BTFSC  x42.0
04FB0:  BRA    4FB6
04FB2:  BTFSC  x43.0
04FB4:  BRA    4FD0
04FB6:  MOVF   xAD,F
04FB8:  BNZ   4FD0
....................       {
....................          if(CheckAutoReset(0x01) == 1);   //Check other Inputt "Ack" or not if not,do nothing
04FBA:  MOVLW  01
04FBC:  MOVWF  xB0
04FBE:  MOVLB  0
04FC0:  CALL   42C0
04FC4:  DECFSZ 01,W
04FC6:  BRA    4FCA
04FC8:  BRA    4FCE
....................          else
....................          {
....................             output_bit(Pbuzzer,1);   //Clear Buzzer
04FCA:  BSF    F89.4
04FCC:  BCF    F92.4
04FCE:  MOVLB  7
....................          }
....................       }
.................... 
.................... 
....................       if((OutputType.B1 == 0 || OutputBoth.B1 == 0)&& inputflag ==0)  //If Bell or Both
04FD0:  BTFSS  x42.0
04FD2:  BRA    4FD8
04FD4:  BTFSC  x43.0
04FD6:  BRA    4FF2
04FD8:  MOVF   xAD,F
04FDA:  BNZ   4FF2
....................       {
....................          if(CheckAutoReset(0x02) == 1);
04FDC:  MOVLW  02
04FDE:  MOVWF  xB0
04FE0:  MOVLB  0
04FE2:  CALL   42C0
04FE6:  DECFSZ 01,W
04FE8:  BRA    4FEC
04FEA:  BRA    4FF0
....................          else
....................          {
....................             output_bit(Pbell,1);      //Clear Bell
04FEC:  BSF    F89.3
04FEE:  BCF    F92.3
04FF0:  MOVLB  7
....................          }
....................       }
....................       // jj modify
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 )
04FF2:  BTFSC  x47.0
04FF4:  BRA    501A
04FF6:  BTFSC  x47.1
04FF8:  BRA    501A
04FFA:  BTFSC  x47.2
04FFC:  BRA    501A
04FFE:  BTFSC  x47.3
05000:  BRA    501A
05002:  BTFSC  x47.4
05004:  BRA    501A
05006:  BTFSC  x47.5
05008:  BRA    501A
0500A:  BTFSC  x47.6
0500C:  BRA    501A
0500E:  BTFSC  x47.7
05010:  BRA    501A
....................       {
....................          output_bit(Pbell,1);      //Clear Bell
05012:  BSF    F89.3
05014:  BCF    F92.3
....................          output_bit(Pbuzzer,1);   //Clear Buzzer
05016:  BSF    F89.4
05018:  BCF    F92.4
....................       }
....................    }
....................    ////////////////////////////////////////////////////////////////////////////////////////////////////
.................... //input2
....................    if((((Inputt.B2 ^ InputType.B2) == 1) && (FaultType.B2 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type"
0501A:  MOVLW  00
0501C:  BTFSC  x3E.1
0501E:  MOVLW  01
05020:  MOVWF  xB1
05022:  MOVLW  00
05024:  BTFSC  x40.1
05026:  MOVLW  01
05028:  XORWF  xB1,W
0502A:  SUBLW  01
0502C:  BNZ   5032
0502E:  BTFSS  x41.1
05030:  BRA    5036
05032:  BTFSS  1C.5
05034:  BRA    50CE
....................    {
....................       if(In2.B2 == 0 && AutoAck == 0x0F && Ack.B2 == 0)   //use auto acknowlegde
05036:  BTFSC  x47.1
05038:  BRA    5056
0503A:  MOVLB  0
0503C:  MOVF   x6C,W
0503E:  SUBLW  0F
05040:  BTFSC  FD8.2
05042:  BRA    5048
05044:  MOVLB  7
05046:  BRA    5056
05048:  MOVLB  7
0504A:  BTFSC  x45.1
0504C:  BRA    5056
....................       {
....................             TimeBase1s = 100 ;            //reload again
0504E:  MOVLW  64
05050:  MOVWF  1E
....................             AutoAckDelayTime = AutoAckTime ;
05052:  MOVFF  6D,1F
....................       }
.................... 
....................       In2.B2 = 1;
05056:  BSF    x47.1
....................       if(Ack.B2 == 0)
05058:  BTFSC  x45.1
0505A:  BRA    508A
....................       {
....................          if(FlashingFlag == 0)
0505C:  BTFSC  1C.1
0505E:  BRA    5064
....................             {
....................                Output.B2 = 0;           //Flash output1
05060:  BCF    x3F.1
....................             }
05062:  BRA    5066
....................             else
....................             {
....................                Output.B2 = 1;
05064:  BSF    x3F.1
....................             }
....................          if (~AutoTestFlag)
05066:  BTFSC  1C.4
05068:  BRA    508A
....................          {
....................            if(AlarmIndicator.B2 == 1){
0506A:  BTFSS  x44.1
0506C:  BRA    508A
....................              if(OutputBoth.B2 == 0)        //Both output
0506E:  BTFSC  x43.1
05070:  BRA    507C
....................              {
....................                output_bit(Pbuzzer,0);   //Buzzer
05072:  BCF    F89.4
05074:  BCF    F92.4
....................                output_bit(Pbell,0);     //Bell
05076:  BCF    F89.3
05078:  BCF    F92.3
....................              }
0507A:  BRA    508A
....................              else
....................              {
....................                if(OutputType.B2 == 1) output_bit(Pbuzzer,0);     //Buzzer
0507C:  BTFSS  x42.1
0507E:  BRA    5086
05080:  BCF    F89.4
05082:  BCF    F92.4
05084:  BRA    508A
....................                else output_bit(Pbell,0);                          //Bell
05086:  BCF    F89.3
05088:  BCF    F92.3
....................              }
....................            }
....................          }
....................        }
....................       inputflag =1;
0508A:  MOVLW  01
0508C:  MOVWF  xAD
....................       
....................       // SMS Sending   
....................       if((SendSMS.B2 ==0)&& (functointest_f ==0) && (Ack.B2 ==0))
0508E:  BTFSC  x4C.1
05090:  BRA    50CC
05092:  BTFSC  32.1
05094:  BRA    50CC
05096:  BTFSC  x45.1
05098:  BRA    50CC
....................       {
....................          SendSMS.B2 =1;
0509A:  BSF    x4C.1
....................          strcat(SMS_MassageSUM, SMS_Massage2);
0509C:  MOVLW  06
0509E:  MOVWF  xB1
050A0:  MOVLW  9A
050A2:  MOVWF  xB0
050A4:  MOVLW  05
050A6:  MOVWF  xB3
050A8:  MOVLW  BA
050AA:  MOVWF  xB2
050AC:  MOVLB  0
050AE:  CALL   4256
....................          strcat(SMS_MassageSUM, spacestring);
050B2:  MOVLW  06
050B4:  MOVLB  7
050B6:  MOVWF  xB1
050B8:  MOVLW  9A
050BA:  MOVWF  xB0
050BC:  MOVLW  07
050BE:  MOVWF  xB3
050C0:  MOVLW  3A
050C2:  MOVWF  xB2
050C4:  MOVLB  0
050C6:  CALL   4256
050CA:  MOVLB  7
....................          /*
....................          fprintf(CH2,"AT+CMGS=\"");
....................          fprintf(CH2,sms_phonenumber);
....................          
....................          fprintf(CH2,"\"");
....................          putc('\n',CH2);
....................          delay_ms(50);
....................         
....................         fprintf(CH2,SMS_Massage2); 
....................         putc('\n',CH2);
....................        putc(26,CH2);
....................         */
....................       }
....................    }
050CC:  BRA    5146
....................    else if(FaultType.B2 == 0)
050CE:  BTFSC  x41.1
050D0:  BRA    5146
....................    {
....................       In2.B2 = 0x00;
050D2:  BCF    x47.1
....................       Ack.B2 = 0;
050D4:  BCF    x45.1
....................       Output.B2 = 1;      //Off LED
050D6:  BSF    x3F.1
....................       
....................       SendSMS.B2 =0;// Clear SMS
050D8:  BCF    x4C.1
.................... 
....................       if((OutputType.B2 == 1 || OutputBoth.B2 == 0)&& inputflag ==0)      //If Buzzer or Both
050DA:  BTFSC  x42.1
050DC:  BRA    50E2
050DE:  BTFSC  x43.1
050E0:  BRA    50FC
050E2:  MOVF   xAD,F
050E4:  BNZ   50FC
....................       {
....................          if(CheckAutoReset(0x01) == 1);   //Check other Inputt "Ack" or not if not,do nothing
050E6:  MOVLW  01
050E8:  MOVWF  xB0
050EA:  MOVLB  0
050EC:  CALL   42C0
050F0:  DECFSZ 01,W
050F2:  BRA    50F6
050F4:  BRA    50FA
....................          else
....................          {
....................             output_bit(Pbuzzer,1);   //Clear Buzzer
050F6:  BSF    F89.4
050F8:  BCF    F92.4
050FA:  MOVLB  7
....................          }
....................       }
.................... 
.................... 
....................       if((OutputType.B2 == 0 || OutputBoth.B2 == 0)&& inputflag ==0)  //If Bell or Both
050FC:  BTFSS  x42.1
050FE:  BRA    5104
05100:  BTFSC  x43.1
05102:  BRA    511E
05104:  MOVF   xAD,F
05106:  BNZ   511E
....................       {
....................          if(CheckAutoReset(0x02) == 1);
05108:  MOVLW  02
0510A:  MOVWF  xB0
0510C:  MOVLB  0
0510E:  CALL   42C0
05112:  DECFSZ 01,W
05114:  BRA    5118
05116:  BRA    511C
....................          else
....................          {
....................             output_bit(Pbell,1);      //Clear Bell
05118:  BSF    F89.3
0511A:  BCF    F92.3
0511C:  MOVLB  7
....................          }
....................       }
....................       // jj modify
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 )
0511E:  BTFSC  x47.0
05120:  BRA    5146
05122:  BTFSC  x47.1
05124:  BRA    5146
05126:  BTFSC  x47.2
05128:  BRA    5146
0512A:  BTFSC  x47.3
0512C:  BRA    5146
0512E:  BTFSC  x47.4
05130:  BRA    5146
05132:  BTFSC  x47.5
05134:  BRA    5146
05136:  BTFSC  x47.6
05138:  BRA    5146
0513A:  BTFSC  x47.7
0513C:  BRA    5146
....................       {
....................          output_bit(Pbell,1);      //Clear Bell
0513E:  BSF    F89.3
05140:  BCF    F92.3
....................          output_bit(Pbuzzer,1);   //Clear Buzzer
05142:  BSF    F89.4
05144:  BCF    F92.4
....................       }
....................    }
....................    ////////////////////////////////////////////////////////////////////////////////////////////////////
.................... //input3
....................    if((((Inputt.B3 ^ InputType.B3) == 1) && (FaultType.B3 == 0)) ||Test_fault==1)   // alarm1 occure and " Non Lock type"
05146:  MOVLW  00
05148:  BTFSC  x3E.2
0514A:  MOVLW  01
0514C:  MOVWF  xB1
0514E:  MOVLW  00
05150:  BTFSC  x40.2
05152:  MOVLW  01
05154:  XORWF  xB1,W
05156:  SUBLW  01
05158:  BNZ   515E
0515A:  BTFSS  x41.2
0515C:  BRA    5162
0515E:  BTFSS  1C.5
05160:  BRA    51FA
....................    {
....................       if(In2.B3 == 0 && AutoAck == 0x0F && Ack.B3 == 0)   //use auto acknowlegde
05162:  BTFSC  x47.2
05164:  BRA    5182
05166:  MOVLB  0
05168:  MOVF   x6C,W
0516A:  SUBLW  0F
0516C:  BTFSC  FD8.2
0516E:  BRA    5174
05170:  MOVLB  7
05172:  BRA    5182
05174:  MOVLB  7
05176:  BTFSC  x45.2
05178:  BRA    5182
....................       {
....................             TimeBase1s = 100 ;            //reload again
0517A:  MOVLW  64
0517C:  MOVWF  1E
....................             AutoAckDelayTime = AutoAckTime ;
0517E:  MOVFF  6D,1F
....................       }
.................... 
....................       In2.B3 = 1;
05182:  BSF    x47.2
....................       if(Ack.B3 == 0)
05184:  BTFSC  x45.2
05186:  BRA    51B6
....................       {
....................          if(FlashingFlag == 0)
05188:  BTFSC  1C.1
0518A:  BRA    5190
....................             {
....................                Output.B3 = 0;           //Flash output1
0518C:  BCF    x3F.2
....................             }
0518E:  BRA    5192
....................             else
....................             {
....................                Output.B3 = 1;
05190:  BSF    x3F.2
....................             }
....................          if (~AutoTestFlag)
05192:  BTFSC  1C.4
05194:  BRA    51B6
....................          {
....................             if(AlarmIndicator.B3 == 1){
05196:  BTFSS  x44.2
05198:  BRA    51B6
....................                 if(OutputBoth.B3 == 0)        //Both output
0519A:  BTFSC  x43.2
0519C:  BRA    51A8
....................                 {
....................                   output_bit(Pbuzzer,0);   //Buzzer
0519E:  BCF    F89.4
051A0:  BCF    F92.4
....................                   output_bit(Pbell,0);     //Bell
051A2:  BCF    F89.3
051A4:  BCF    F92.3
....................                 }
051A6:  BRA    51B6
....................                 else
....................                 {
....................                   if(OutputType.B3 == 1) output_bit(Pbuzzer,0);     //Buzzer
051A8:  BTFSS  x42.2
051AA:  BRA    51B2
051AC:  BCF    F89.4
051AE:  BCF    F92.4
051B0:  BRA    51B6
....................                   else output_bit(Pbell,0);                          //Bell
051B2:  BCF    F89.3
051B4:  BCF    F92.3
....................                 }
....................             }
....................          }
....................        }
....................       inputflag =1;
051B6:  MOVLW  01
051B8:  MOVWF  xAD
....................       
....................       // SMS Sending   
....................       if((SendSMS.B3 ==0)&& (functointest_f ==0) && (Ack.B3 ==0))
051BA:  BTFSC  x4C.2
051BC:  BRA    51F8
051BE:  BTFSC  32.1
051C0:  BRA    51F8
051C2:  BTFSC  x45.2
051C4:  BRA    51F8
....................       {
....................          SendSMS.B3 =1;
051C6:  BSF    x4C.2
....................          strcat(SMS_MassageSUM, SMS_Massage3);
051C8:  MOVLW  06
051CA:  MOVWF  xB1
051CC:  MOVLW  9A
051CE:  MOVWF  xB0
051D0:  MOVLW  05
051D2:  MOVWF  xB3
051D4:  MOVLW  DA
051D6:  MOVWF  xB2
051D8:  MOVLB  0
051DA:  CALL   4256
....................          strcat(SMS_MassageSUM, spacestring);
051DE:  MOVLW  06
051E0:  MOVLB  7
051E2:  MOVWF  xB1
051E4:  MOVLW  9A
051E6:  MOVWF  xB0
051E8:  MOVLW  07
051EA:  MOVWF  xB3
051EC:  MOVLW  3A
051EE:  MOVWF  xB2
051F0:  MOVLB  0
051F2:  CALL   4256
051F6:  MOVLB  7
....................          /*
....................          fprintf(CH2,"AT+CMGS=\"");
....................          fprintf(CH2,sms_phonenumber);
....................          
....................          fprintf(CH2,"\"");
....................          putc('\n',CH2);
....................          delay_ms(50);
....................         
....................         fprintf(CH2,SMS_Massage3); 
....................         putc('\n',CH2);
....................        putc(26,CH2);
....................         */
....................       }
....................    }
051F8:  BRA    5272
....................    else if(FaultType.B3 == 0)
051FA:  BTFSC  x41.2
051FC:  BRA    5272
....................    {
....................       In2.B3 = 0x00;
051FE:  BCF    x47.2
....................       Ack.B3 = 0;
05200:  BCF    x45.2
....................       Output.B3 = 1;      //Off LED
05202:  BSF    x3F.2
....................       
....................       SendSMS.B3 =0;// Clear SMS
05204:  BCF    x4C.2
.................... 
....................       if((OutputType.B3 == 1 || OutputBoth.B3 == 0)&& inputflag ==0)      //If Buzzer or Both
05206:  BTFSC  x42.2
05208:  BRA    520E
0520A:  BTFSC  x43.2
0520C:  BRA    5228
0520E:  MOVF   xAD,F
05210:  BNZ   5228
....................       {
....................          if(CheckAutoReset(0x01) == 1);   //Check other Inputt "Ack" or not if not,do nothing
05212:  MOVLW  01
05214:  MOVWF  xB0
05216:  MOVLB  0
05218:  CALL   42C0
0521C:  DECFSZ 01,W
0521E:  BRA    5222
05220:  BRA    5226
....................          else
....................          {
....................             output_bit(Pbuzzer,1);   //Clear Buzzer
05222:  BSF    F89.4
05224:  BCF    F92.4
05226:  MOVLB  7
....................          }
....................       }
.................... 
.................... 
....................       if((OutputType.B3 == 0 || OutputBoth.B3 == 0)&& inputflag ==0)  //If Bell or Both
05228:  BTFSS  x42.2
0522A:  BRA    5230
0522C:  BTFSC  x43.2
0522E:  BRA    524A
05230:  MOVF   xAD,F
05232:  BNZ   524A
....................       {
....................          if(CheckAutoReset(0x02) == 1);
05234:  MOVLW  02
05236:  MOVWF  xB0
05238:  MOVLB  0
0523A:  CALL   42C0
0523E:  DECFSZ 01,W
05240:  BRA    5244
05242:  BRA    5248
....................          else
....................          {
....................             output_bit(Pbell,1);      //Clear Bell
05244:  BSF    F89.3
05246:  BCF    F92.3
05248:  MOVLB  7
....................          }
....................       }
....................       // jj modify
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0 )
0524A:  BTFSC  x47.0
0524C:  BRA    5272
0524E:  BTFSC  x47.1
05250:  BRA    5272
05252:  BTFSC  x47.2
05254:  BRA    5272
05256:  BTFSC  x47.3
05258:  BRA    5272
0525A:  BTFSC  x47.4
0525C:  BRA    5272
0525E:  BTFSC  x47.5
05260:  BRA    5272
05262:  BTFSC  x47.6
05264:  BRA    5272
05266:  BTFSC  x47.7
05268:  BRA    5272
....................       {
....................          output_bit(Pbell,1);      //Clear Bell
0526A:  BSF    F89.3
0526C:  BCF    F92.3
....................          output_bit(Pbuzzer,1);   //Clear Buzzer
0526E:  BSF    F89.4
05270:  BCF    F92.4
....................       }
....................    }
....................    ////////////////////////////////////////////////////////////////////////////////////////////////////
.................... //input4
....................    if((((Inputt.B4 ^ InputType.B4) == 1) && (FaultType.B4 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type"
05272:  MOVLW  00
05274:  BTFSC  x3E.3
05276:  MOVLW  01
05278:  MOVWF  xB1
0527A:  MOVLW  00
0527C:  BTFSC  x40.3
0527E:  MOVLW  01
05280:  XORWF  xB1,W
05282:  SUBLW  01
05284:  BNZ   528A
05286:  BTFSS  x41.3
05288:  BRA    528E
0528A:  BTFSS  1C.5
0528C:  BRA    5326
....................    {
....................       if(In2.B4 == 0 && AutoAck == 0x0F && Ack.B4 == 0)   //use auto acknowlegde
0528E:  BTFSC  x47.3
05290:  BRA    52AE
05292:  MOVLB  0
05294:  MOVF   x6C,W
05296:  SUBLW  0F
05298:  BTFSC  FD8.2
0529A:  BRA    52A0
0529C:  MOVLB  7
0529E:  BRA    52AE
052A0:  MOVLB  7
052A2:  BTFSC  x45.3
052A4:  BRA    52AE
....................       {
....................             TimeBase1s = 100 ;            //reload again
052A6:  MOVLW  64
052A8:  MOVWF  1E
....................             AutoAckDelayTime = AutoAckTime ;
052AA:  MOVFF  6D,1F
....................       }
.................... 
....................       In2.B4 = 1;
052AE:  BSF    x47.3
....................       if(Ack.B4 == 0)
052B0:  BTFSC  x45.3
052B2:  BRA    52E2
....................       {
....................          if(FlashingFlag == 0)
052B4:  BTFSC  1C.1
052B6:  BRA    52BC
....................             {
....................                Output.B4 = 0;           //Flash output1
052B8:  BCF    x3F.3
....................             }
052BA:  BRA    52BE
....................             else
....................             {
....................                Output.B4 = 1;
052BC:  BSF    x3F.3
....................             }
....................          if (~AutoTestFlag)
052BE:  BTFSC  1C.4
052C0:  BRA    52E2
....................          {
....................             if(AlarmIndicator.B4 == 1){
052C2:  BTFSS  x44.3
052C4:  BRA    52E2
....................                 if(OutputBoth.B4 == 0)        //Both output
052C6:  BTFSC  x43.3
052C8:  BRA    52D4
....................                 {
....................                   output_bit(Pbuzzer,0);   //Buzzer
052CA:  BCF    F89.4
052CC:  BCF    F92.4
....................                   output_bit(Pbell,0);     //Bell
052CE:  BCF    F89.3
052D0:  BCF    F92.3
....................                 }
052D2:  BRA    52E2
....................                 else
....................                 {
....................                   if(OutputType.B4 == 1) output_bit(Pbuzzer,0);     //Buzzer
052D4:  BTFSS  x42.3
052D6:  BRA    52DE
052D8:  BCF    F89.4
052DA:  BCF    F92.4
052DC:  BRA    52E2
....................                   else output_bit(Pbell,0);                          //Bell
052DE:  BCF    F89.3
052E0:  BCF    F92.3
....................                 }
....................             }
....................          }
....................        }
....................       inputflag =1;
052E2:  MOVLW  01
052E4:  MOVWF  xAD
....................       
....................       // SMS Sending   
....................       if((SendSMS.B4 ==0)&& (functointest_f ==0) && (Ack.B4 ==0))
052E6:  BTFSC  x4C.3
052E8:  BRA    5324
052EA:  BTFSC  32.1
052EC:  BRA    5324
052EE:  BTFSC  x45.3
052F0:  BRA    5324
....................       {
....................          SendSMS.B4 =1;
052F2:  BSF    x4C.3
....................          strcat(SMS_MassageSUM, SMS_Massage4);
052F4:  MOVLW  06
052F6:  MOVWF  xB1
052F8:  MOVLW  9A
052FA:  MOVWF  xB0
052FC:  MOVLW  05
052FE:  MOVWF  xB3
05300:  MOVLW  FA
05302:  MOVWF  xB2
05304:  MOVLB  0
05306:  CALL   4256
....................          strcat(SMS_MassageSUM, spacestring);
0530A:  MOVLW  06
0530C:  MOVLB  7
0530E:  MOVWF  xB1
05310:  MOVLW  9A
05312:  MOVWF  xB0
05314:  MOVLW  07
05316:  MOVWF  xB3
05318:  MOVLW  3A
0531A:  MOVWF  xB2
0531C:  MOVLB  0
0531E:  CALL   4256
05322:  MOVLB  7
....................          /*
....................          fprintf(CH2,"AT+CMGS=\"");
....................          fprintf(CH2,sms_phonenumber);
....................          
....................          fprintf(CH2,"\"");
....................          putc('\n',CH2);
....................          delay_ms(50);
....................         
....................         fprintf(CH2,SMS_Massage4); 
....................         putc('\n',CH2);
....................        putc(26,CH2);
....................         */
....................       }
....................    }
05324:  BRA    539E
....................    else if(FaultType.B4 == 0)
05326:  BTFSC  x41.3
05328:  BRA    539E
....................    {
....................       In2.B4 = 0x00;
0532A:  BCF    x47.3
....................       Ack.B4 = 0;
0532C:  BCF    x45.3
....................       Output.B4 = 1;      //Off LED
0532E:  BSF    x3F.3
....................       
....................       SendSMS.B4 =0;// Clear SMS
05330:  BCF    x4C.3
.................... 
....................       if((OutputType.B4 == 1 || OutputBoth.B4 == 0)&& inputflag ==0)      //If Buzzer or Both
05332:  BTFSC  x42.3
05334:  BRA    533A
05336:  BTFSC  x43.3
05338:  BRA    5354
0533A:  MOVF   xAD,F
0533C:  BNZ   5354
....................       {
....................          if(CheckAutoReset(0x01) == 1);   //Check other Inputt "Ack" or not if not,do nothing
0533E:  MOVLW  01
05340:  MOVWF  xB0
05342:  MOVLB  0
05344:  CALL   42C0
05348:  DECFSZ 01,W
0534A:  BRA    534E
0534C:  BRA    5352
....................          else
....................          {
....................             output_bit(Pbuzzer,1);   //Clear Buzzer
0534E:  BSF    F89.4
05350:  BCF    F92.4
05352:  MOVLB  7
....................          }
....................       }
.................... 
.................... 
....................       if((OutputType.B4 == 0 || OutputBoth.B4 == 0)&& inputflag ==0)  //If Bell or Both
05354:  BTFSS  x42.3
05356:  BRA    535C
05358:  BTFSC  x43.3
0535A:  BRA    5376
0535C:  MOVF   xAD,F
0535E:  BNZ   5376
....................       {
....................          if(CheckAutoReset(0x02) == 1);
05360:  MOVLW  02
05362:  MOVWF  xB0
05364:  MOVLB  0
05366:  CALL   42C0
0536A:  DECFSZ 01,W
0536C:  BRA    5370
0536E:  BRA    5374
....................          else
....................          {
....................             output_bit(Pbell,1);      //Clear Bell
05370:  BSF    F89.3
05372:  BCF    F92.3
05374:  MOVLB  7
....................          }
....................       }
....................       // jj modify
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0)
05376:  BTFSC  x47.0
05378:  BRA    539E
0537A:  BTFSC  x47.1
0537C:  BRA    539E
0537E:  BTFSC  x47.2
05380:  BRA    539E
05382:  BTFSC  x47.3
05384:  BRA    539E
05386:  BTFSC  x47.4
05388:  BRA    539E
0538A:  BTFSC  x47.5
0538C:  BRA    539E
0538E:  BTFSC  x47.6
05390:  BRA    539E
05392:  BTFSC  x47.7
05394:  BRA    539E
....................       {
....................          output_bit(Pbell,1);      //Clear Bell
05396:  BSF    F89.3
05398:  BCF    F92.3
....................          output_bit(Pbuzzer,1);   //Clear Buzzer
0539A:  BSF    F89.4
0539C:  BCF    F92.4
....................       }
....................    }
....................    ////////////////////////////////////////////////////////////////////////////////////////////////////
.................... //input5
....................    if((((Inputt.B5 ^ InputType.B5) == 1) && (FaultType.B5 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type"
0539E:  MOVLW  00
053A0:  BTFSC  x3E.4
053A2:  MOVLW  01
053A4:  MOVWF  xB1
053A6:  MOVLW  00
053A8:  BTFSC  x40.4
053AA:  MOVLW  01
053AC:  XORWF  xB1,W
053AE:  SUBLW  01
053B0:  BNZ   53B6
053B2:  BTFSS  x41.4
053B4:  BRA    53BA
053B6:  BTFSS  1C.5
053B8:  BRA    5452
....................    {
....................       if(In2.B5 == 0 && AutoAck == 0x0F && Ack.B5 == 0)   //use auto acknowlegde
053BA:  BTFSC  x47.4
053BC:  BRA    53DA
053BE:  MOVLB  0
053C0:  MOVF   x6C,W
053C2:  SUBLW  0F
053C4:  BTFSC  FD8.2
053C6:  BRA    53CC
053C8:  MOVLB  7
053CA:  BRA    53DA
053CC:  MOVLB  7
053CE:  BTFSC  x45.4
053D0:  BRA    53DA
....................       {
....................             TimeBase1s = 100 ;            //reload again
053D2:  MOVLW  64
053D4:  MOVWF  1E
....................             AutoAckDelayTime = AutoAckTime ;
053D6:  MOVFF  6D,1F
....................       }
.................... 
....................       In2.B5 = 1;
053DA:  BSF    x47.4
....................       if(Ack.B5 == 0)
053DC:  BTFSC  x45.4
053DE:  BRA    540E
....................       {
....................          if(FlashingFlag == 0)
053E0:  BTFSC  1C.1
053E2:  BRA    53E8
....................             {
....................                Output.B5 = 0;           //Flash output1
053E4:  BCF    x3F.4
....................             }
053E6:  BRA    53EA
....................             else
....................             {
....................                Output.B5 = 1;
053E8:  BSF    x3F.4
....................             }
....................          if (~AutoTestFlag)
053EA:  BTFSC  1C.4
053EC:  BRA    540E
....................          {
....................             if(AlarmIndicator.B5 == 1){
053EE:  BTFSS  x44.4
053F0:  BRA    540E
....................                 if(OutputBoth.B5 == 0)        //Both output
053F2:  BTFSC  x43.4
053F4:  BRA    5400
....................                 {
....................                   output_bit(Pbuzzer,0);   //Buzzer
053F6:  BCF    F89.4
053F8:  BCF    F92.4
....................                   output_bit(Pbell,0);     //Bell
053FA:  BCF    F89.3
053FC:  BCF    F92.3
....................                 }
053FE:  BRA    540E
....................                 else
....................                 {
....................                   if(OutputType.B5 == 1) output_bit(Pbuzzer,0);     //Buzzer
05400:  BTFSS  x42.4
05402:  BRA    540A
05404:  BCF    F89.4
05406:  BCF    F92.4
05408:  BRA    540E
....................                   else output_bit(Pbell,0);                          //Bell
0540A:  BCF    F89.3
0540C:  BCF    F92.3
....................                 }
....................             }
....................          }
....................        }
....................       inputflag =1;
0540E:  MOVLW  01
05410:  MOVWF  xAD
....................       
....................       // SMS Sending   
....................       if((SendSMS.B5 ==0)&& (functointest_f ==0) && (Ack.B5 ==0))
05412:  BTFSC  x4C.4
05414:  BRA    5450
05416:  BTFSC  32.1
05418:  BRA    5450
0541A:  BTFSC  x45.4
0541C:  BRA    5450
....................       {
....................          SendSMS.B5 =1;
0541E:  BSF    x4C.4
....................          strcat(SMS_MassageSUM, SMS_Massage5);
05420:  MOVLW  06
05422:  MOVWF  xB1
05424:  MOVLW  9A
05426:  MOVWF  xB0
05428:  MOVLW  06
0542A:  MOVWF  xB3
0542C:  MOVLW  1A
0542E:  MOVWF  xB2
05430:  MOVLB  0
05432:  CALL   4256
....................          strcat(SMS_MassageSUM, spacestring);
05436:  MOVLW  06
05438:  MOVLB  7
0543A:  MOVWF  xB1
0543C:  MOVLW  9A
0543E:  MOVWF  xB0
05440:  MOVLW  07
05442:  MOVWF  xB3
05444:  MOVLW  3A
05446:  MOVWF  xB2
05448:  MOVLB  0
0544A:  CALL   4256
0544E:  MOVLB  7
....................          /*
....................          fprintf(CH2,"AT+CMGS=\"");
....................          fprintf(CH2,sms_phonenumber);
....................          
....................          fprintf(CH2,"\"");
....................          putc('\n',CH2);
....................          delay_ms(50);
....................         
....................         fprintf(CH2,SMS_Massage5); 
....................         putc('\n',CH2);
....................        putc(26,CH2);
....................         */
....................       }
....................    }
05450:  BRA    54CA
....................    else if(FaultType.B5 == 0)
05452:  BTFSC  x41.4
05454:  BRA    54CA
....................    {
....................       In2.B5 = 0x00;
05456:  BCF    x47.4
....................       Ack.B5 = 0;
05458:  BCF    x45.4
....................       Output.B5 = 1;      //Off LED
0545A:  BSF    x3F.4
....................       
....................       SendSMS.B5 =0;// Clear SMS
0545C:  BCF    x4C.4
.................... 
....................       if((OutputType.B5 == 1 || OutputBoth.B5 == 0)&& inputflag ==0)      //If Buzzer or Both
0545E:  BTFSC  x42.4
05460:  BRA    5466
05462:  BTFSC  x43.4
05464:  BRA    5480
05466:  MOVF   xAD,F
05468:  BNZ   5480
....................       {
....................          if(CheckAutoReset(0x01) == 1);   //Check other Inputt "Ack" or not if not,do nothing
0546A:  MOVLW  01
0546C:  MOVWF  xB0
0546E:  MOVLB  0
05470:  CALL   42C0
05474:  DECFSZ 01,W
05476:  BRA    547A
05478:  BRA    547E
....................          else
....................          {
....................             output_bit(Pbuzzer,1);   //Clear Buzzer
0547A:  BSF    F89.4
0547C:  BCF    F92.4
0547E:  MOVLB  7
....................          }
....................       }
.................... 
.................... 
....................       if((OutputType.B5 == 0 || OutputBoth.B5 == 0)&& inputflag ==0)  //If Bell or Both
05480:  BTFSS  x42.4
05482:  BRA    5488
05484:  BTFSC  x43.4
05486:  BRA    54A2
05488:  MOVF   xAD,F
0548A:  BNZ   54A2
....................       {
....................          if(CheckAutoReset(0x02) == 1);
0548C:  MOVLW  02
0548E:  MOVWF  xB0
05490:  MOVLB  0
05492:  CALL   42C0
05496:  DECFSZ 01,W
05498:  BRA    549C
0549A:  BRA    54A0
....................          else
....................          {
....................             output_bit(Pbell,1);      //Clear Bell
0549C:  BSF    F89.3
0549E:  BCF    F92.3
054A0:  MOVLB  7
....................          }
....................       }
....................       // jj modify
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0)
054A2:  BTFSC  x47.0
054A4:  BRA    54CA
054A6:  BTFSC  x47.1
054A8:  BRA    54CA
054AA:  BTFSC  x47.2
054AC:  BRA    54CA
054AE:  BTFSC  x47.3
054B0:  BRA    54CA
054B2:  BTFSC  x47.4
054B4:  BRA    54CA
054B6:  BTFSC  x47.5
054B8:  BRA    54CA
054BA:  BTFSC  x47.6
054BC:  BRA    54CA
054BE:  BTFSC  x47.7
054C0:  BRA    54CA
....................       {
....................          output_bit(Pbell,1);      //Clear Bell
054C2:  BSF    F89.3
054C4:  BCF    F92.3
....................          output_bit(Pbuzzer,1);   //Clear Buzzer
054C6:  BSF    F89.4
054C8:  BCF    F92.4
....................       }
....................    }
....................    ////////////////////////////////////////////////////////////////////////////////////////////////////
.................... //input6
....................    if((((Inputt.B6 ^ InputType.B6) == 1) && (FaultType.B6 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type"
054CA:  MOVLW  00
054CC:  BTFSC  x3E.5
054CE:  MOVLW  01
054D0:  MOVWF  xB1
054D2:  MOVLW  00
054D4:  BTFSC  x40.5
054D6:  MOVLW  01
054D8:  XORWF  xB1,W
054DA:  SUBLW  01
054DC:  BNZ   54E2
054DE:  BTFSS  x41.5
054E0:  BRA    54E6
054E2:  BTFSS  1C.5
054E4:  BRA    557E
....................    {
....................       if(In2.B6 == 0 && AutoAck == 0x0F && Ack.B6 == 0)   //use auto acknowlegde
054E6:  BTFSC  x47.5
054E8:  BRA    5506
054EA:  MOVLB  0
054EC:  MOVF   x6C,W
054EE:  SUBLW  0F
054F0:  BTFSC  FD8.2
054F2:  BRA    54F8
054F4:  MOVLB  7
054F6:  BRA    5506
054F8:  MOVLB  7
054FA:  BTFSC  x45.5
054FC:  BRA    5506
....................       {
....................             TimeBase1s = 100 ;            //reload again
054FE:  MOVLW  64
05500:  MOVWF  1E
....................             AutoAckDelayTime = AutoAckTime ;
05502:  MOVFF  6D,1F
....................       }
.................... 
....................       In2.B6 = 1;
05506:  BSF    x47.5
....................       if(Ack.B6 == 0)
05508:  BTFSC  x45.5
0550A:  BRA    553A
....................       {
....................          if(FlashingFlag == 0)
0550C:  BTFSC  1C.1
0550E:  BRA    5514
....................             {
....................                Output.B6 = 0;           //Flash output1
05510:  BCF    x3F.5
....................             }
05512:  BRA    5516
....................             else
....................             {
....................                Output.B6 = 1;
05514:  BSF    x3F.5
....................             }
....................          if (~AutoTestFlag)
05516:  BTFSC  1C.4
05518:  BRA    553A
....................          {
....................             if(AlarmIndicator.B6 == 1){
0551A:  BTFSS  x44.5
0551C:  BRA    553A
....................                 if(OutputBoth.B6 == 0)        //Both output
0551E:  BTFSC  x43.5
05520:  BRA    552C
....................                 {
....................                   output_bit(Pbuzzer,0);   //Buzzer
05522:  BCF    F89.4
05524:  BCF    F92.4
....................                   output_bit(Pbell,0);     //Bell
05526:  BCF    F89.3
05528:  BCF    F92.3
....................                 }
0552A:  BRA    553A
....................                 else
....................                 {
....................                   if(OutputType.B6 == 1) output_bit(Pbuzzer,0);     //Buzzer
0552C:  BTFSS  x42.5
0552E:  BRA    5536
05530:  BCF    F89.4
05532:  BCF    F92.4
05534:  BRA    553A
....................                   else output_bit(Pbell,0);                          //Bell
05536:  BCF    F89.3
05538:  BCF    F92.3
....................                 }
....................             }
....................          }
....................        }
....................       inputflag =1;
0553A:  MOVLW  01
0553C:  MOVWF  xAD
....................       
....................       // SMS Sending   
....................       if((SendSMS.B6 ==0)&& (functointest_f ==0) && (Ack.B6 ==0))
0553E:  BTFSC  x4C.5
05540:  BRA    557C
05542:  BTFSC  32.1
05544:  BRA    557C
05546:  BTFSC  x45.5
05548:  BRA    557C
....................       {
....................          SendSMS.B6 =1;
0554A:  BSF    x4C.5
....................          strcat(SMS_MassageSUM, SMS_Massage6);
0554C:  MOVLW  06
0554E:  MOVWF  xB1
05550:  MOVLW  9A
05552:  MOVWF  xB0
05554:  MOVLW  06
05556:  MOVWF  xB3
05558:  MOVLW  3A
0555A:  MOVWF  xB2
0555C:  MOVLB  0
0555E:  CALL   4256
....................          strcat(SMS_MassageSUM, spacestring);
05562:  MOVLW  06
05564:  MOVLB  7
05566:  MOVWF  xB1
05568:  MOVLW  9A
0556A:  MOVWF  xB0
0556C:  MOVLW  07
0556E:  MOVWF  xB3
05570:  MOVLW  3A
05572:  MOVWF  xB2
05574:  MOVLB  0
05576:  CALL   4256
0557A:  MOVLB  7
....................          /*
....................          fprintf(CH2,"AT+CMGS=\"");
....................          fprintf(CH2,sms_phonenumber);
....................          
....................          fprintf(CH2,"\"");
....................          putc('\n',CH2);
....................          delay_ms(50);
....................         
....................         fprintf(CH2,SMS_Massage6);  
....................         putc('\n',CH2);
....................        putc(26,CH2);
....................         */
....................       }
....................    }
0557C:  BRA    55F6
....................    else if(FaultType.B6 == 0)
0557E:  BTFSC  x41.5
05580:  BRA    55F6
....................    {
....................       In2.B6 = 0x00;
05582:  BCF    x47.5
....................       Ack.B6 = 0;
05584:  BCF    x45.5
....................       Output.B6 = 1;      //Off LED
05586:  BSF    x3F.5
....................       
....................       SendSMS.B6 =0;// Clear SMS
05588:  BCF    x4C.5
.................... 
....................       if((OutputType.B6 == 1 || OutputBoth.B6 == 0)&& inputflag ==0)      //If Buzzer or Both
0558A:  BTFSC  x42.5
0558C:  BRA    5592
0558E:  BTFSC  x43.5
05590:  BRA    55AC
05592:  MOVF   xAD,F
05594:  BNZ   55AC
....................       {
....................          if(CheckAutoReset(0x01) == 1);   //Check other Inputt "Ack" or not if not,do nothing
05596:  MOVLW  01
05598:  MOVWF  xB0
0559A:  MOVLB  0
0559C:  CALL   42C0
055A0:  DECFSZ 01,W
055A2:  BRA    55A6
055A4:  BRA    55AA
....................          else
....................          {
....................             output_bit(Pbuzzer,1);   //Clear Buzzer
055A6:  BSF    F89.4
055A8:  BCF    F92.4
055AA:  MOVLB  7
....................          }
....................       }
.................... 
.................... 
....................       if((OutputType.B6 == 0 || OutputBoth.B6 == 0)&& inputflag ==0)  //If Bell or Both
055AC:  BTFSS  x42.5
055AE:  BRA    55B4
055B0:  BTFSC  x43.5
055B2:  BRA    55CE
055B4:  MOVF   xAD,F
055B6:  BNZ   55CE
....................       {
....................          if(CheckAutoReset(0x02) == 1);
055B8:  MOVLW  02
055BA:  MOVWF  xB0
055BC:  MOVLB  0
055BE:  CALL   42C0
055C2:  DECFSZ 01,W
055C4:  BRA    55C8
055C6:  BRA    55CC
....................          else
....................          {
....................             output_bit(Pbell,1);      //Clear Bell
055C8:  BSF    F89.3
055CA:  BCF    F92.3
055CC:  MOVLB  7
....................          }
....................       }
....................       // jj modify
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0)
055CE:  BTFSC  x47.0
055D0:  BRA    55F6
055D2:  BTFSC  x47.1
055D4:  BRA    55F6
055D6:  BTFSC  x47.2
055D8:  BRA    55F6
055DA:  BTFSC  x47.3
055DC:  BRA    55F6
055DE:  BTFSC  x47.4
055E0:  BRA    55F6
055E2:  BTFSC  x47.5
055E4:  BRA    55F6
055E6:  BTFSC  x47.6
055E8:  BRA    55F6
055EA:  BTFSC  x47.7
055EC:  BRA    55F6
....................       {
....................          output_bit(Pbell,1);      //Clear Bell
055EE:  BSF    F89.3
055F0:  BCF    F92.3
....................          output_bit(Pbuzzer,1);   //Clear Buzzer
055F2:  BSF    F89.4
055F4:  BCF    F92.4
....................       }
....................    }
....................    ////////////////////////////////////////////////////////////////////////////////////////////////////
.................... //input7
....................    if((((Inputt.B7 ^ InputType.B7) == 1) && (FaultType.B7 == 0))||Test_fault==1)    // alarm1 occure and " Non Lock type"
055F6:  MOVLW  00
055F8:  BTFSC  x3E.6
055FA:  MOVLW  01
055FC:  MOVWF  xB1
055FE:  MOVLW  00
05600:  BTFSC  x40.6
05602:  MOVLW  01
05604:  XORWF  xB1,W
05606:  SUBLW  01
05608:  BNZ   560E
0560A:  BTFSS  x41.6
0560C:  BRA    5612
0560E:  BTFSS  1C.5
05610:  BRA    56AA
....................    {
....................       if(In2.B7 == 0 && AutoAck == 0x0F && Ack.B7 == 0)   //use auto acknowlegde
05612:  BTFSC  x47.6
05614:  BRA    5632
05616:  MOVLB  0
05618:  MOVF   x6C,W
0561A:  SUBLW  0F
0561C:  BTFSC  FD8.2
0561E:  BRA    5624
05620:  MOVLB  7
05622:  BRA    5632
05624:  MOVLB  7
05626:  BTFSC  x45.6
05628:  BRA    5632
....................       {
....................             TimeBase1s = 100 ;            //reload again
0562A:  MOVLW  64
0562C:  MOVWF  1E
....................             AutoAckDelayTime = AutoAckTime ;
0562E:  MOVFF  6D,1F
....................       }
.................... 
....................       In2.B7 = 1;
05632:  BSF    x47.6
....................       if(Ack.B7 == 0)
05634:  BTFSC  x45.6
05636:  BRA    5666
....................       {
....................          if(FlashingFlag == 0)
05638:  BTFSC  1C.1
0563A:  BRA    5640
....................             {
....................                Output.B7 = 0;           //Flash output1
0563C:  BCF    x3F.6
....................             }
0563E:  BRA    5642
....................             else
....................             {
....................                Output.B7 = 1;
05640:  BSF    x3F.6
....................             }
....................          if (~AutoTestFlag)
05642:  BTFSC  1C.4
05644:  BRA    5666
....................          {
....................             if(AlarmIndicator.B7 == 1){
05646:  BTFSS  x44.6
05648:  BRA    5666
....................                 if(OutputBoth.B7 == 0)        //Both output
0564A:  BTFSC  x43.6
0564C:  BRA    5658
....................                 {
....................                   output_bit(Pbuzzer,0);   //Buzzer
0564E:  BCF    F89.4
05650:  BCF    F92.4
....................                   output_bit(Pbell,0);     //Bell
05652:  BCF    F89.3
05654:  BCF    F92.3
....................                 }
05656:  BRA    5666
....................                 else
....................                 {
....................                   if(OutputType.B7 == 1) output_bit(Pbuzzer,0);     //Buzzer
05658:  BTFSS  x42.6
0565A:  BRA    5662
0565C:  BCF    F89.4
0565E:  BCF    F92.4
05660:  BRA    5666
....................                   else output_bit(Pbell,0);                          //Bell
05662:  BCF    F89.3
05664:  BCF    F92.3
....................                 }
....................             }
....................          }
....................        }
....................       inputflag =1;
05666:  MOVLW  01
05668:  MOVWF  xAD
....................       
....................       // SMS Sending   
....................       if((SendSMS.B7 ==0)&& (functointest_f ==0) && (Ack.B7 ==0))
0566A:  BTFSC  x4C.6
0566C:  BRA    56A8
0566E:  BTFSC  32.1
05670:  BRA    56A8
05672:  BTFSC  x45.6
05674:  BRA    56A8
....................       {
....................          SendSMS.B7 =1;
05676:  BSF    x4C.6
....................          strcat(SMS_MassageSUM, SMS_Massage7);
05678:  MOVLW  06
0567A:  MOVWF  xB1
0567C:  MOVLW  9A
0567E:  MOVWF  xB0
05680:  MOVLW  06
05682:  MOVWF  xB3
05684:  MOVLW  5A
05686:  MOVWF  xB2
05688:  MOVLB  0
0568A:  CALL   4256
....................          strcat(SMS_MassageSUM, spacestring);
0568E:  MOVLW  06
05690:  MOVLB  7
05692:  MOVWF  xB1
05694:  MOVLW  9A
05696:  MOVWF  xB0
05698:  MOVLW  07
0569A:  MOVWF  xB3
0569C:  MOVLW  3A
0569E:  MOVWF  xB2
056A0:  MOVLB  0
056A2:  CALL   4256
056A6:  MOVLB  7
....................          /*
....................          fprintf(CH2,"AT+CMGS=\"");
....................          fprintf(CH2,sms_phonenumber);
....................          
....................          fprintf(CH2,"\"");
....................          putc('\n',CH2);
....................          delay_ms(50);
....................         
....................         fprintf(CH2,SMS_Massage7);  
....................         putc('\n',CH2);
....................        putc(26,CH2);
....................         */
....................       }
....................    }
056A8:  BRA    5722
....................    else if(FaultType.B7 == 0)
056AA:  BTFSC  x41.6
056AC:  BRA    5722
....................    {
....................       In2.B7 = 0x00;
056AE:  BCF    x47.6
....................       Ack.B7 = 0;
056B0:  BCF    x45.6
....................       Output.B7 = 1;      //Off LED
056B2:  BSF    x3F.6
....................       
....................       SendSMS.B7 =0;// Clear SMS
056B4:  BCF    x4C.6
.................... 
....................       if((OutputType.B7 == 1 || OutputBoth.B7 == 0)&& inputflag ==0)      //If Buzzer or Both
056B6:  BTFSC  x42.6
056B8:  BRA    56BE
056BA:  BTFSC  x43.6
056BC:  BRA    56D8
056BE:  MOVF   xAD,F
056C0:  BNZ   56D8
....................       {
....................          if(CheckAutoReset(0x01) == 1);   //Check other Inputt "Ack" or not if not,do nothing
056C2:  MOVLW  01
056C4:  MOVWF  xB0
056C6:  MOVLB  0
056C8:  CALL   42C0
056CC:  DECFSZ 01,W
056CE:  BRA    56D2
056D0:  BRA    56D6
....................          else
....................          {
....................             output_bit(Pbuzzer,1);   //Clear Buzzer
056D2:  BSF    F89.4
056D4:  BCF    F92.4
056D6:  MOVLB  7
....................          }
....................       }
.................... 
.................... 
....................       if((OutputType.B7 == 0 || OutputBoth.B7 == 0)&& inputflag ==0)  //If Bell or Both
056D8:  BTFSS  x42.6
056DA:  BRA    56E0
056DC:  BTFSC  x43.6
056DE:  BRA    56FA
056E0:  MOVF   xAD,F
056E2:  BNZ   56FA
....................       {
....................          if(CheckAutoReset(0x02) == 1);
056E4:  MOVLW  02
056E6:  MOVWF  xB0
056E8:  MOVLB  0
056EA:  CALL   42C0
056EE:  DECFSZ 01,W
056F0:  BRA    56F4
056F2:  BRA    56F8
....................          else
....................          {
....................             output_bit(Pbell,1);      //Clear Bell
056F4:  BSF    F89.3
056F6:  BCF    F92.3
056F8:  MOVLB  7
....................          }
....................       }
....................       // jj modify
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0)
056FA:  BTFSC  x47.0
056FC:  BRA    5722
056FE:  BTFSC  x47.1
05700:  BRA    5722
05702:  BTFSC  x47.2
05704:  BRA    5722
05706:  BTFSC  x47.3
05708:  BRA    5722
0570A:  BTFSC  x47.4
0570C:  BRA    5722
0570E:  BTFSC  x47.5
05710:  BRA    5722
05712:  BTFSC  x47.6
05714:  BRA    5722
05716:  BTFSC  x47.7
05718:  BRA    5722
....................       {
....................          output_bit(Pbell,1);      //Clear Bell
0571A:  BSF    F89.3
0571C:  BCF    F92.3
....................          output_bit(Pbuzzer,1);   //Clear Buzzer
0571E:  BSF    F89.4
05720:  BCF    F92.4
....................       }
....................    }
....................    ////////////////////////////////////////////////////////////////////////////////////////////////////
.................... //input8
....................    if((((Inputt.B8 ^ InputType.B8) == 1) && (FaultType.B8 == 0)) ||Test_fault==1)   // alarm1 occure and " Non Lock type"
05722:  MOVLW  00
05724:  BTFSC  x3E.7
05726:  MOVLW  01
05728:  MOVWF  xB1
0572A:  MOVLW  00
0572C:  BTFSC  x40.7
0572E:  MOVLW  01
05730:  XORWF  xB1,W
05732:  SUBLW  01
05734:  BNZ   573A
05736:  BTFSS  x41.7
05738:  BRA    573E
0573A:  BTFSS  1C.5
0573C:  BRA    57D6
....................    {
....................       if(In2.B8 == 0 && AutoAck == 0x0F && Ack.B8 == 0)   //use auto acknowlegde
0573E:  BTFSC  x47.7
05740:  BRA    575E
05742:  MOVLB  0
05744:  MOVF   x6C,W
05746:  SUBLW  0F
05748:  BTFSC  FD8.2
0574A:  BRA    5750
0574C:  MOVLB  7
0574E:  BRA    575E
05750:  MOVLB  7
05752:  BTFSC  x45.7
05754:  BRA    575E
....................       {
....................             TimeBase1s = 100 ;            //reload again
05756:  MOVLW  64
05758:  MOVWF  1E
....................             AutoAckDelayTime = AutoAckTime ;
0575A:  MOVFF  6D,1F
....................       }
.................... 
....................       In2.B8 = 1;
0575E:  BSF    x47.7
....................       if(Ack.B8 == 0)
05760:  BTFSC  x45.7
05762:  BRA    5792
....................       {
....................          if(FlashingFlag == 0)
05764:  BTFSC  1C.1
05766:  BRA    576C
....................             {
....................                Output.B8 = 0;           //Flash output1
05768:  BCF    x3F.7
....................             }
0576A:  BRA    576E
....................             else
....................             {
....................                Output.B8 = 1;
0576C:  BSF    x3F.7
....................             }
....................          if (~AutoTestFlag)
0576E:  BTFSC  1C.4
05770:  BRA    5792
....................          {
....................             if(AlarmIndicator.B8 == 1){
05772:  BTFSS  x44.7
05774:  BRA    5792
....................                 if(OutputBoth.B8 == 0)        //Both output
05776:  BTFSC  x43.7
05778:  BRA    5784
....................                 {
....................                   output_bit(Pbuzzer,0);   //Buzzer
0577A:  BCF    F89.4
0577C:  BCF    F92.4
....................                   output_bit(Pbell,0);     //Bell
0577E:  BCF    F89.3
05780:  BCF    F92.3
....................                 }
05782:  BRA    5792
....................                 else
....................                 {
....................                   if(OutputType.B8 == 1) output_bit(Pbuzzer,0);     //Buzzer
05784:  BTFSS  x42.7
05786:  BRA    578E
05788:  BCF    F89.4
0578A:  BCF    F92.4
0578C:  BRA    5792
....................                   else output_bit(Pbell,0);                          //Bell
0578E:  BCF    F89.3
05790:  BCF    F92.3
....................                 }
....................             }
....................          }
....................        }
....................       inputflag =1;
05792:  MOVLW  01
05794:  MOVWF  xAD
....................       
....................       // SMS Sending   
....................       if((SendSMS.B8 ==0) && (functointest_f ==0) && (Ack.B8 ==0))
05796:  BTFSC  x4C.7
05798:  BRA    57D4
0579A:  BTFSC  32.1
0579C:  BRA    57D4
0579E:  BTFSC  x45.7
057A0:  BRA    57D4
....................       {
....................          SendSMS.B8 =1;
057A2:  BSF    x4C.7
....................          strcat(SMS_MassageSUM, SMS_Massage8);
057A4:  MOVLW  06
057A6:  MOVWF  xB1
057A8:  MOVLW  9A
057AA:  MOVWF  xB0
057AC:  MOVLW  06
057AE:  MOVWF  xB3
057B0:  MOVLW  7A
057B2:  MOVWF  xB2
057B4:  MOVLB  0
057B6:  CALL   4256
....................          strcat(SMS_MassageSUM, spacestring);
057BA:  MOVLW  06
057BC:  MOVLB  7
057BE:  MOVWF  xB1
057C0:  MOVLW  9A
057C2:  MOVWF  xB0
057C4:  MOVLW  07
057C6:  MOVWF  xB3
057C8:  MOVLW  3A
057CA:  MOVWF  xB2
057CC:  MOVLB  0
057CE:  CALL   4256
057D2:  MOVLB  7
....................          /*
....................          fprintf(CH2,"AT+CMGS=\"");
....................          fprintf(CH2,sms_phonenumber);
....................          
....................          fprintf(CH2,"\"");
....................          putc('\n',CH2);
....................          delay_ms(50);
....................         
....................         fprintf(CH2,SMS_Massage8);   
....................         putc('\n',CH2);
....................         putc(26,CH2);
....................         */
....................       }
....................    }
057D4:  BRA    584E
....................    else if(FaultType.B8 == 0)
057D6:  BTFSC  x41.7
057D8:  BRA    584E
....................    {
....................       In2.B8 = 0x00;
057DA:  BCF    x47.7
....................       Ack.B8 = 0;
057DC:  BCF    x45.7
....................       Output.B8 = 1;      //Off LED
057DE:  BSF    x3F.7
....................       
....................       SendSMS.B8 =0;// Clear SMS
057E0:  BCF    x4C.7
.................... 
....................       if((OutputType.B8 == 1 || OutputBoth.B8 == 0)&& inputflag ==0)      //If Buzzer or Both
057E2:  BTFSC  x42.7
057E4:  BRA    57EA
057E6:  BTFSC  x43.7
057E8:  BRA    5804
057EA:  MOVF   xAD,F
057EC:  BNZ   5804
....................       {
....................          if(CheckAutoReset(0x01) == 1);   //Check other Inputt "Ack" or not if not,do nothing
057EE:  MOVLW  01
057F0:  MOVWF  xB0
057F2:  MOVLB  0
057F4:  CALL   42C0
057F8:  DECFSZ 01,W
057FA:  BRA    57FE
057FC:  BRA    5802
....................          else
....................          {
....................             output_bit(Pbuzzer,1);   //Clear Buzzer
057FE:  BSF    F89.4
05800:  BCF    F92.4
05802:  MOVLB  7
....................          }
....................       }
.................... 
....................       if((OutputType.B8 == 0 || OutputBoth.B8 == 0)&& inputflag ==0)  //If Bell or Both
05804:  BTFSS  x42.7
05806:  BRA    580C
05808:  BTFSC  x43.7
0580A:  BRA    5826
0580C:  MOVF   xAD,F
0580E:  BNZ   5826
....................       {
....................          if(CheckAutoReset(0x02) == 1);
05810:  MOVLW  02
05812:  MOVWF  xB0
05814:  MOVLB  0
05816:  CALL   42C0
0581A:  DECFSZ 01,W
0581C:  BRA    5820
0581E:  BRA    5824
....................          else
....................          {
....................             output_bit(Pbell,1);      //Clear Bell
05820:  BSF    F89.3
05822:  BCF    F92.3
05824:  MOVLB  7
....................          }
....................       }
....................       // jj modify
....................       if(In2.B1 ==0 && In2.B2 ==0 && In2.B3 ==0 && In2.B4 ==0 && In2.B5 ==0 && In2.B6 ==0 && In2.B7 ==0 && In2.B8 ==0)
05826:  BTFSC  x47.0
05828:  BRA    584E
0582A:  BTFSC  x47.1
0582C:  BRA    584E
0582E:  BTFSC  x47.2
05830:  BRA    584E
05832:  BTFSC  x47.3
05834:  BRA    584E
05836:  BTFSC  x47.4
05838:  BRA    584E
0583A:  BTFSC  x47.5
0583C:  BRA    584E
0583E:  BTFSC  x47.6
05840:  BRA    584E
05842:  BTFSC  x47.7
05844:  BRA    584E
....................       {
....................          output_bit(Pbell,1);      //Clear Bell
05846:  BSF    F89.3
05848:  BCF    F92.3
....................          output_bit(Pbuzzer,1);   //Clear Buzzer
0584A:  BSF    F89.4
0584C:  BCF    F92.4
....................       }
....................    }
0584E:  MOVLB  0
05850:  GOTO   5EF6 (RETURN)
....................    ////////////////////////////////////////////////////////////////////////////////////////////////////   
....................    
.................... 
.................... }
.................... 
.................... //////////////////////////////////////////////////////////////////////////////////////////////////////////
.................... ////////////////////////////////////////////////////////////////////////////////
.................... void Send_Ouput(void)
.................... {
....................     Red1_7 = 0;
*
01B3E:  CLRF   50
....................     Red8_8 = 0;
01B40:  CLRF   51
....................     //Red9_15 = 0;
....................     //Red16_16 = 0;
.................... 
....................     Green1_7 = 0;
01B42:  CLRF   54
....................     Green8_8 = 0;
01B44:  CLRF   55
....................     //Green9_15 = 0;
....................     //Green16_16 = 0;
.................... 
....................    if(T_test == 0x00)
01B46:  MOVF   31,F
01B48:  BTFSS  FD8.2
01B4A:  BRA    1D14
....................    {
....................       //if(NoOfPoint >= 10)
....................       //{
....................       
....................      
....................            if(Output.B1)//++++++++++++B1+++++++++++++++++++++
01B4C:  MOVLB  7
01B4E:  BTFSS  x3F.0
01B50:  BRA    1B58
....................            {
....................              bit_clear(Red1_7,1); bit_clear(Green1_7,1);
01B52:  BCF    50.1
01B54:  BCF    54.1
....................            }
01B56:  BRA    1B80
....................            else
....................            {
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0);
....................              if((RED_Colour.B1 )&&(GREEN_Colour.B1 ==0 ))//Red
01B58:  BTFSS  x4A.0
01B5A:  BRA    1B66
01B5C:  BTFSC  x4B.0
01B5E:  BRA    1B66
....................              {
....................                bit_set(Red1_7,1); bit_clear(Green1_7,1);
01B60:  BSF    50.1
01B62:  BCF    54.1
....................              }
01B64:  BRA    1B80
....................              else if((RED_Colour.B1==0 )&&(GREEN_Colour.B1))//Green
01B66:  BTFSC  x4A.0
01B68:  BRA    1B74
01B6A:  BTFSS  x4B.0
01B6C:  BRA    1B74
....................              {
....................                bit_clear(Red1_7,1); bit_set(Green1_7,1); 
01B6E:  BCF    50.1
01B70:  BSF    54.1
....................              }
01B72:  BRA    1B80
....................              else if((RED_Colour.B1)&&(GREEN_Colour.B1))//Ambian
01B74:  BTFSS  x4A.0
01B76:  BRA    1B80
01B78:  BTFSS  x4B.0
01B7A:  BRA    1B80
....................              {
....................                bit_set(Red1_7,1); bit_set(Green1_7,1) ; 
01B7C:  BSF    50.1
01B7E:  BSF    54.1
....................              }  
....................            }
....................            ////////////////////////////////////////////////////////
....................            if(Output.B2)//++++++++++++B2+++++++++++++++++++++
01B80:  BTFSS  x3F.1
01B82:  BRA    1B8A
....................            {
....................              bit_clear(Red1_7,2); bit_clear(Green1_7,2);
01B84:  BCF    50.2
01B86:  BCF    54.2
....................            }
01B88:  BRA    1BB2
....................            else
....................            {
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0);
....................              if((RED_Colour.B2 )&&(GREEN_Colour.B2 ==0 ))//Red
01B8A:  BTFSS  x4A.1
01B8C:  BRA    1B98
01B8E:  BTFSC  x4B.1
01B90:  BRA    1B98
....................              {
....................                bit_set(Red1_7,2); bit_clear(Green1_7,2);
01B92:  BSF    50.2
01B94:  BCF    54.2
....................              }
01B96:  BRA    1BB2
....................              else if((RED_Colour.B2==0 )&&(GREEN_Colour.B2))//Green
01B98:  BTFSC  x4A.1
01B9A:  BRA    1BA6
01B9C:  BTFSS  x4B.1
01B9E:  BRA    1BA6
....................              {
....................                bit_clear(Red1_7,2); bit_set(Green1_7,2); 
01BA0:  BCF    50.2
01BA2:  BSF    54.2
....................              }
01BA4:  BRA    1BB2
....................              else if((RED_Colour.B2)&&(GREEN_Colour.B2))//Ambian
01BA6:  BTFSS  x4A.1
01BA8:  BRA    1BB2
01BAA:  BTFSS  x4B.1
01BAC:  BRA    1BB2
....................              {
....................                bit_set(Red1_7,2); bit_set(Green1_7,2) ; 
01BAE:  BSF    50.2
01BB0:  BSF    54.2
....................              }  
....................            }
....................            ////////////////////////////////////////////////////////
....................            if(Output.B3)//++++++++++++B3+++++++++++++++++++++
01BB2:  BTFSS  x3F.2
01BB4:  BRA    1BBC
....................            {
....................              bit_clear(Red1_7,3); bit_clear(Green1_7,3);
01BB6:  BCF    50.3
01BB8:  BCF    54.3
....................            }
01BBA:  BRA    1BE4
....................            else
....................            {
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0);
....................              if((RED_Colour.B3 )&&(GREEN_Colour.B3 ==0 ))//Red
01BBC:  BTFSS  x4A.2
01BBE:  BRA    1BCA
01BC0:  BTFSC  x4B.2
01BC2:  BRA    1BCA
....................              {
....................                bit_set(Red1_7,3); bit_clear(Green1_7,3);
01BC4:  BSF    50.3
01BC6:  BCF    54.3
....................              }
01BC8:  BRA    1BE4
....................              else if((RED_Colour.B3==0 )&&(GREEN_Colour.B3))//Green
01BCA:  BTFSC  x4A.2
01BCC:  BRA    1BD8
01BCE:  BTFSS  x4B.2
01BD0:  BRA    1BD8
....................              {
....................                bit_clear(Red1_7,3); bit_set(Green1_7,3); 
01BD2:  BCF    50.3
01BD4:  BSF    54.3
....................              }
01BD6:  BRA    1BE4
....................              else if((RED_Colour.B3)&&(GREEN_Colour.B3))//Ambian
01BD8:  BTFSS  x4A.2
01BDA:  BRA    1BE4
01BDC:  BTFSS  x4B.2
01BDE:  BRA    1BE4
....................              {
....................                bit_set(Red1_7,3); bit_set(Green1_7,3) ; 
01BE0:  BSF    50.3
01BE2:  BSF    54.3
....................              }  
....................            }
....................            ////////////////////////////////////////////////////////
....................            if(Output.B4)//++++++++++++B4+++++++++++++++++++++
01BE4:  BTFSS  x3F.3
01BE6:  BRA    1BEE
....................            {
....................              bit_clear(Red1_7,4); bit_clear(Green1_7,4);
01BE8:  BCF    50.4
01BEA:  BCF    54.4
....................            }
01BEC:  BRA    1C16
....................            else
....................            {
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0);
....................              if((RED_Colour.B4 )&&(GREEN_Colour.B4 ==0 ))//Red
01BEE:  BTFSS  x4A.3
01BF0:  BRA    1BFC
01BF2:  BTFSC  x4B.3
01BF4:  BRA    1BFC
....................              {
....................                bit_set(Red1_7,4); bit_clear(Green1_7,4);
01BF6:  BSF    50.4
01BF8:  BCF    54.4
....................              }
01BFA:  BRA    1C16
....................              else if((RED_Colour.B4==0 )&&(GREEN_Colour.B4))//Green
01BFC:  BTFSC  x4A.3
01BFE:  BRA    1C0A
01C00:  BTFSS  x4B.3
01C02:  BRA    1C0A
....................              {
....................                bit_clear(Red1_7,4); bit_set(Green1_7,4); 
01C04:  BCF    50.4
01C06:  BSF    54.4
....................              }
01C08:  BRA    1C16
....................              else if((RED_Colour.B4)&&(GREEN_Colour.B4))//Ambian
01C0A:  BTFSS  x4A.3
01C0C:  BRA    1C16
01C0E:  BTFSS  x4B.3
01C10:  BRA    1C16
....................              {
....................                bit_set(Red1_7,4); bit_set(Green1_7,4) ; 
01C12:  BSF    50.4
01C14:  BSF    54.4
....................              }  
....................            }
....................            ////////////////////////////////////////////////////////
....................            if(Output.B5)//++++++++++++B5+++++++++++++++++++++
01C16:  BTFSS  x3F.4
01C18:  BRA    1C20
....................            {
....................              bit_clear(Red1_7,5); bit_clear(Green1_7,5);
01C1A:  BCF    50.5
01C1C:  BCF    54.5
....................            }
01C1E:  BRA    1C48
....................            else
....................            {
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0);
....................              if((RED_Colour.B5 )&&(GREEN_Colour.B5 ==0 ))//Red
01C20:  BTFSS  x4A.4
01C22:  BRA    1C2E
01C24:  BTFSC  x4B.4
01C26:  BRA    1C2E
....................              {
....................                bit_set(Red1_7,5); bit_clear(Green1_7,5);
01C28:  BSF    50.5
01C2A:  BCF    54.5
....................              }
01C2C:  BRA    1C48
....................              else if((RED_Colour.B5==0 )&&(GREEN_Colour.B5))//Green
01C2E:  BTFSC  x4A.4
01C30:  BRA    1C3C
01C32:  BTFSS  x4B.4
01C34:  BRA    1C3C
....................              {
....................                bit_clear(Red1_7,5); bit_set(Green1_7,5); 
01C36:  BCF    50.5
01C38:  BSF    54.5
....................              }
01C3A:  BRA    1C48
....................              else if((RED_Colour.B5)&&(GREEN_Colour.B5))//Ambian
01C3C:  BTFSS  x4A.4
01C3E:  BRA    1C48
01C40:  BTFSS  x4B.4
01C42:  BRA    1C48
....................              {
....................                bit_set(Red1_7,5); bit_set(Green1_7,5) ; 
01C44:  BSF    50.5
01C46:  BSF    54.5
....................              }  
....................            }
....................            ////////////////////////////////////////////////////////
....................            if(Output.B6)//++++++++++++B6+++++++++++++++++++++
01C48:  BTFSS  x3F.5
01C4A:  BRA    1C52
....................            {
....................              bit_clear(Red1_7,6); bit_clear(Green1_7,6);
01C4C:  BCF    50.6
01C4E:  BCF    54.6
....................            }
01C50:  BRA    1C7A
....................            else
....................            {
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0);
....................              if((RED_Colour.B6 )&&(GREEN_Colour.B6 ==0 ))//Red
01C52:  BTFSS  x4A.5
01C54:  BRA    1C60
01C56:  BTFSC  x4B.5
01C58:  BRA    1C60
....................              {
....................                bit_set(Red1_7,6); bit_clear(Green1_7,6);
01C5A:  BSF    50.6
01C5C:  BCF    54.6
....................              }
01C5E:  BRA    1C7A
....................              else if((RED_Colour.B6==0 )&&(GREEN_Colour.B6))//Green
01C60:  BTFSC  x4A.5
01C62:  BRA    1C6E
01C64:  BTFSS  x4B.5
01C66:  BRA    1C6E
....................              {
....................                bit_clear(Red1_7,6); bit_set(Green1_7,6); 
01C68:  BCF    50.6
01C6A:  BSF    54.6
....................              }
01C6C:  BRA    1C7A
....................              else if((RED_Colour.B6)&&(GREEN_Colour.B6))//Ambian
01C6E:  BTFSS  x4A.5
01C70:  BRA    1C7A
01C72:  BTFSS  x4B.5
01C74:  BRA    1C7A
....................              {
....................                bit_set(Red1_7,6); bit_set(Green1_7,6) ; 
01C76:  BSF    50.6
01C78:  BSF    54.6
....................              }  
....................            }
....................            ////////////////////////////////////////////////////////
....................            if(Output.B7)//++++++++++++B7+++++++++++++++++++++
01C7A:  BTFSS  x3F.6
01C7C:  BRA    1C84
....................            {
....................              bit_clear(Red1_7,7); bit_clear(Green1_7,7);
01C7E:  BCF    50.7
01C80:  BCF    54.7
....................            }
01C82:  BRA    1CAC
....................            else
....................            {
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0);
....................              if((RED_Colour.B7 )&&(GREEN_Colour.B7 ==0 ))//Red
01C84:  BTFSS  x4A.6
01C86:  BRA    1C92
01C88:  BTFSC  x4B.6
01C8A:  BRA    1C92
....................              {
....................                bit_set(Red1_7,7); bit_clear(Green1_7,7);
01C8C:  BSF    50.7
01C8E:  BCF    54.7
....................              }
01C90:  BRA    1CAC
....................              else if((RED_Colour.B7==0 )&&(GREEN_Colour.B7))//Green
01C92:  BTFSC  x4A.6
01C94:  BRA    1CA0
01C96:  BTFSS  x4B.6
01C98:  BRA    1CA0
....................              {
....................                bit_clear(Red1_7,7); bit_set(Green1_7,7); 
01C9A:  BCF    50.7
01C9C:  BSF    54.7
....................              }
01C9E:  BRA    1CAC
....................              else if((RED_Colour.B7)&&(GREEN_Colour.B7))//Ambian
01CA0:  BTFSS  x4A.6
01CA2:  BRA    1CAC
01CA4:  BTFSS  x4B.6
01CA6:  BRA    1CAC
....................              {
....................                bit_set(Red1_7,7); bit_set(Green1_7,7) ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
01CA8:  BSF    50.7
01CAA:  BSF    54.7
....................              }  
....................            }
....................            ////////////////////////////////////////////////////////
....................            if(Output.B8)//++++++++++++B8+++++++++++++++++++++
01CAC:  BTFSS  x3F.7
01CAE:  BRA    1CB6
....................            {
....................              bit_clear(Red8_8,0); bit_clear(Green8_8,0);
01CB0:  BCF    51.0
01CB2:  BCF    55.0
....................            }
01CB4:  BRA    1CDE
....................            else
....................            {
....................              //bit_set(OUTRed1_8,0); bit_clear(OUTGreen1_8,0);
....................              if((RED_Colour.B8 )&&(GREEN_Colour.B8 ==0 ))//Red
01CB6:  BTFSS  x4A.7
01CB8:  BRA    1CC4
01CBA:  BTFSC  x4B.7
01CBC:  BRA    1CC4
....................              {
....................                bit_set(Red8_8,0); bit_clear(Green8_8,0);
01CBE:  BSF    51.0
01CC0:  BCF    55.0
....................              }
01CC2:  BRA    1CDE
....................              else if((RED_Colour.B8==0 )&&(GREEN_Colour.B8))//Green
01CC4:  BTFSC  x4A.7
01CC6:  BRA    1CD2
01CC8:  BTFSS  x4B.7
01CCA:  BRA    1CD2
....................              {
....................                bit_clear(Red8_8,0); bit_set(Green8_8,0); 
01CCC:  BCF    51.0
01CCE:  BSF    55.0
....................              }
01CD0:  BRA    1CDE
....................              else if((RED_Colour.B8)&&(GREEN_Colour.B8))//Ambian
01CD2:  BTFSS  x4A.7
01CD4:  BRA    1CDE
01CD6:  BTFSS  x4B.7
01CD8:  BRA    1CDE
....................              {
....................                bit_set(Red8_8,0); bit_set(Green8_8,0) ; 
01CDA:  BSF    51.0
01CDC:  BSF    55.0
....................              }  
....................            }
....................            ////////////////////////////////////////////////////////
.................... 
....................         
....................            IO_OUTPUT_A(IO_DEVICE_2, Red1_7);
01CDE:  MOVLW  04
01CE0:  MOVWF  xB8
01CE2:  MOVFF  50,7B9
01CE6:  MOVLB  0
01CE8:  RCALL  1B12
....................            IO_OUTPUT_B(IO_DEVICE_2, Red8_8);
01CEA:  MOVLW  04
01CEC:  MOVLB  7
01CEE:  MOVWF  xB8
01CF0:  MOVFF  51,7B9
01CF4:  MOVLB  0
01CF6:  RCALL  1B28
....................                       
....................            IO_OUTPUT_A(IO_DEVICE_3, Green1_7);
01CF8:  MOVLW  06
01CFA:  MOVLB  7
01CFC:  MOVWF  xB8
01CFE:  MOVFF  54,7B9
01D02:  MOVLB  0
01D04:  RCALL  1B12
....................            IO_OUTPUT_B(IO_DEVICE_3, Green8_8);
01D06:  MOVLW  06
01D08:  MOVLB  7
01D0A:  MOVWF  xB8
01D0C:  MOVFF  55,7B9
01D10:  MOVLB  0
01D12:  RCALL  1B28
....................            
.................... 
....................                                            
....................            
....................    }
01D14:  RETURN 0
.................... 
.................... }
.................... //////////////////////////////////////////////////////////////////
.................... void ForceAllAlarm(void)
.................... {
....................    In.B1 = 1;
*
0417E:  MOVLB  7
04180:  BSF    x46.0
....................    In.B2 = 1;
04182:  BSF    x46.1
....................    In.B3 = 1;
04184:  BSF    x46.2
....................    In.B4 = 1;
04186:  BSF    x46.3
....................    In.B5 = 1;
04188:  BSF    x46.4
....................    In.B6 = 1;
0418A:  BSF    x46.5
....................    In.B7 = 1;
0418C:  BSF    x46.6
....................    In.B8 = 1;
0418E:  BSF    x46.7
04190:  MOVLB  0
04192:  GOTO   4232 (RETURN)
....................       /*
....................       Inputt.B1 = ~InputType.B1;
....................       Inputt.B2 = ~InputType.B2;
....................       Inputt.B3 = ~InputType.B3;
....................       Inputt.B4 = ~InputType.B4;
....................       Inputt.B5 = ~InputType.B5;
....................       Inputt.B6 = ~InputType.B6;
....................       Inputt.B7 = ~InputType.B7;
....................       Inputt.B8 = ~InputType.B8;
....................       Ack.B1 = 0;
....................       Ack.B2 = 0;
....................       Ack.B3 = 0;
....................       Ack.B4 = 0;
....................       Ack.B5 = 0;
....................       Ack.B6 = 0;
....................       Ack.B7 = 0;
....................       Ack.B8 = 0;
....................       */
....................   
.................... }
.................... 
.................... 
....................  ////////////////////////////////////////////////////////////////////////////////////////////////////
....................  ////////////////////////////////////////////////////////////////////////////////////////////////////
.................... ///////////// Check Test ////////////////
.................... void check_test(void)
.................... {
....................    int8 output_temp[8];
....................    
....................    output_temp[0] = Output1_8;
04196:  MOVFF  34,7B0
....................    output_temp[1] = output9_16;
0419A:  MOVFF  35,7B1
.................... 
....................        if((input(Ptest) == 0 && Test == 0)|| AutoTestFlag == 1) delay_ms(50);
0419E:  BSF    F94.2
041A0:  BTFSC  F82.2
041A2:  BRA    41A8
041A4:  BTFSS  1C.6
041A6:  BRA    41AC
041A8:  BTFSS  1C.4
041AA:  BRA    41B8
041AC:  MOVLW  32
041AE:  MOVLB  7
041B0:  MOVWF  xB9
041B2:  MOVLB  0
041B4:  CALL   0662
....................        if((input(Ptest) == 0 && Test == 0)|| AutoTestFlag == 1)
041B8:  BSF    F94.2
041BA:  BTFSC  F82.2
041BC:  BRA    41C2
041BE:  BTFSS  1C.6
041C0:  BRA    41C6
041C2:  BTFSS  1C.4
041C4:  BRA    421A
....................        {
....................            if((input(Ptest) == 0 && Test == 0)|| AutoTestFlag ==1)
041C6:  BSF    F94.2
041C8:  BTFSC  F82.2
041CA:  BRA    41D0
041CC:  BTFSS  1C.6
041CE:  BRA    41D4
041D0:  BTFSS  1C.4
041D2:  BRA    4218
....................            {
....................              restart_wdt();
041D4:  CLRWDT
....................              if(T_test == 0) T_test = 0x06;    //3 second for time base 500 ms
041D6:  MOVF   31,F
041D8:  BNZ   41DE
041DA:  MOVLW  06
041DC:  MOVWF  31
....................               Test = 1;
041DE:  BSF    1C.6
....................         
....................           IO_OUTPUT_A(IO_DEVICE_2, 0xFF);
041E0:  MOVLW  04
041E2:  MOVLB  7
041E4:  MOVWF  xB8
041E6:  SETF   xB9
041E8:  MOVLB  0
041EA:  CALL   1B12
....................           IO_OUTPUT_B(IO_DEVICE_2, 0xFF);
041EE:  MOVLW  04
041F0:  MOVLB  7
041F2:  MOVWF  xB8
041F4:  SETF   xB9
041F6:  MOVLB  0
041F8:  CALL   1B28
....................                   
....................           IO_OUTPUT_A(IO_DEVICE_3, 0xFF);
041FC:  MOVLW  06
041FE:  MOVLB  7
04200:  MOVWF  xB8
04202:  SETF   xB9
04204:  MOVLB  0
04206:  CALL   1B12
....................           IO_OUTPUT_B(IO_DEVICE_3, 0xFF);
0420A:  MOVLW  06
0420C:  MOVLB  7
0420E:  MOVWF  xB8
04210:  SETF   xB9
04212:  MOVLB  0
04214:  CALL   1B28
....................              
....................            }
....................          
....................        }
04218:  BRA    422A
....................        else if(input(Ptest) == 1 && Test == 1)
0421A:  BSF    F94.2
0421C:  BTFSS  F82.2
0421E:  BRA    422A
04220:  BTFSS  1C.6
04222:  BRA    422A
....................        {
....................            T_test = 0x00;
04224:  CLRF   31
....................            Test = 0;
04226:  BCF    1C.6
....................            Test_fault = 0;
04228:  BCF    1C.5
....................        }
....................        if(Test_fault == 1)
0422A:  BTFSS  1C.5
0422C:  BRA    423C
....................        {
....................           functointest_f = 1;
0422E:  BSF    32.1
....................           ForceAllAlarm();
04230:  BRA    417E
....................           //Anal_Function();
....................           if(Input(Ptest) == 1)
04232:  BSF    F94.2
04234:  BTFSS  F82.2
04236:  BRA    423A
....................           {
....................             Test_fault = 0;
04238:  BCF    1C.5
....................           }
....................        }
0423A:  BRA    4252
....................        else if(input(Ptest) == 1 && Test == 1)
0423C:  BSF    F94.2
0423E:  BTFSS  F82.2
04240:  BRA    4252
04242:  BTFSS  1C.6
04244:  BRA    4252
....................        {
....................           if(NoOfPoint >= 16)
04246:  MOVF   x6F,W
04248:  SUBLW  0F
0424A:  BC    424C
....................           {
.................... 
....................           }
....................           
.................... 
....................           T_test = 0x00;
0424C:  CLRF   31
....................           Test = 0;
0424E:  BCF    1C.6
....................           Test_fault = 0;
04250:  BCF    1C.5
....................        }
04252:  GOTO   5EF0 (RETURN)
.................... }
.................... 
.................... 
.................... /////////////// Check acknowledge ////////////////////////////
.................... 
.................... void check_ack(void)
.................... {
.................... 
....................    if((input(Pack) == 0 && Ack_F == 0) || AutoAckFlag == 1) delay_ms(50); //Acknowledge function
*
01F46:  BSF    F94.0
01F48:  BTFSC  F82.0
01F4A:  BRA    1F50
01F4C:  BTFSS  1C.7
01F4E:  BRA    1F54
01F50:  BTFSS  1C.2
01F52:  BRA    1F60
01F54:  MOVLW  32
01F56:  MOVLB  7
01F58:  MOVWF  xB9
01F5A:  MOVLB  0
01F5C:  CALL   0662
....................    if((input(Pack) == 0 && Ack_F == 0) || AutoAckFlag == 1)
01F60:  BSF    F94.0
01F62:  BTFSC  F82.0
01F64:  BRA    1F6A
01F66:  BTFSS  1C.7
01F68:  BRA    1F6E
01F6A:  BTFSS  1C.2
01F6C:  BRA    2018
....................    {
....................             AutoAckFlag = 0;
01F6E:  BCF    1C.2
....................             AutoAckDelayTime = 0x00;
01F70:  CLRF   1F
.................... 
....................            if((In.B1 == 1 )||(In2.B1 == 1 ))
01F72:  MOVLB  7
01F74:  BTFSC  x46.0
01F76:  BRA    1F7C
01F78:  BTFSS  x47.0
01F7A:  BRA    1F86
....................            {
....................              Ack.B1 = 1;
01F7C:  BSF    x45.0
....................              In.B1 = 0;
01F7E:  BCF    x46.0
....................              In2.B1 = 0;      //for auto reset
01F80:  BCF    x47.0
....................              Output.B1 = 0;
01F82:  BCF    x3F.0
....................              SendSMS.B1 =0;
01F84:  BCF    x4C.0
....................            }
.................... 
....................            if((In.B2 == 1)||(In2.B2 == 1))
01F86:  BTFSC  x46.1
01F88:  BRA    1F8E
01F8A:  BTFSS  x47.1
01F8C:  BRA    1F98
....................            {
....................              Ack.B2 = 1;
01F8E:  BSF    x45.1
....................              In.B2 = 0;
01F90:  BCF    x46.1
....................              In2.B2 = 0;      //for auto reset
01F92:  BCF    x47.1
....................              Output.B2 = 0;
01F94:  BCF    x3F.1
....................              SendSMS.B2 =0;
01F96:  BCF    x4C.1
....................            }
.................... 
....................            if((In.B3 == 1)||(In2.B3 == 1))
01F98:  BTFSC  x46.2
01F9A:  BRA    1FA0
01F9C:  BTFSS  x47.2
01F9E:  BRA    1FAA
....................            {
....................              Ack.B3 = 1;
01FA0:  BSF    x45.2
....................              In.B3 = 0;
01FA2:  BCF    x46.2
....................              In2.B3 = 0;      //for auto reset
01FA4:  BCF    x47.2
....................              Output.B3 = 0;
01FA6:  BCF    x3F.2
....................              SendSMS.B3 =0;
01FA8:  BCF    x4C.2
....................            }
.................... 
....................            if((In.B4 == 1)||(In2.B4 == 1))
01FAA:  BTFSC  x46.3
01FAC:  BRA    1FB2
01FAE:  BTFSS  x47.3
01FB0:  BRA    1FBC
....................            {
....................              Ack.B4 = 1;
01FB2:  BSF    x45.3
....................              In.B4 = 0;
01FB4:  BCF    x46.3
....................              In2.B4 = 0;      //for auto reset
01FB6:  BCF    x47.3
....................              Output.B4 = 0;
01FB8:  BCF    x3F.3
....................              SendSMS.B4 =0;
01FBA:  BCF    x4C.3
....................            }
.................... 
....................            if((In.B5 == 1)||(In2.B5 == 1))
01FBC:  BTFSC  x46.4
01FBE:  BRA    1FC4
01FC0:  BTFSS  x47.4
01FC2:  BRA    1FCE
....................            {
....................              Ack.B5 = 1;
01FC4:  BSF    x45.4
....................              In.B5 = 0;
01FC6:  BCF    x46.4
....................              In2.B5 = 0;      //for auto reset
01FC8:  BCF    x47.4
....................              Output.B5 = 0;
01FCA:  BCF    x3F.4
....................              SendSMS.B5 =0;
01FCC:  BCF    x4C.4
....................            }
.................... 
....................            if((In.B6 == 1 )||(In2.B6 == 1 ))
01FCE:  BTFSC  x46.5
01FD0:  BRA    1FD6
01FD2:  BTFSS  x47.5
01FD4:  BRA    1FE0
....................            {
....................              Ack.B6 = 1;
01FD6:  BSF    x45.5
....................              In.B6 = 0;
01FD8:  BCF    x46.5
....................              In2.B6 = 0;      //for auto reset
01FDA:  BCF    x47.5
....................              Output.B6 = 0;
01FDC:  BCF    x3F.5
....................              SendSMS.B6 =0;
01FDE:  BCF    x4C.5
....................            }
.................... 
....................            if((In.B7 == 1 )||(In2.B7 == 1 ))
01FE0:  BTFSC  x46.6
01FE2:  BRA    1FE8
01FE4:  BTFSS  x47.6
01FE6:  BRA    1FF2
....................            {
....................              Ack.B7 = 1;
01FE8:  BSF    x45.6
....................              In.B7 = 0;
01FEA:  BCF    x46.6
....................              In2.B7 = 0;      //for auto reset
01FEC:  BCF    x47.6
....................              Output.B7 = 0;
01FEE:  BCF    x3F.6
....................              SendSMS.B7 =0;
01FF0:  BCF    x4C.6
....................            }
.................... 
....................            if((In.B8 == 1 )||(In2.B8 == 1 ))
01FF2:  BTFSC  x46.7
01FF4:  BRA    1FFA
01FF6:  BTFSS  x47.7
01FF8:  BRA    2004
....................            {
....................              Ack.B8 = 1;
01FFA:  BSF    x45.7
....................              In.B8 = 0;
01FFC:  BCF    x46.7
....................              In2.B8 = 0;      //for auto reset
01FFE:  BCF    x47.7
....................              Output.B8 = 0;
02000:  BCF    x3F.7
....................              SendSMS.B8 =0;
02002:  BCF    x4C.7
....................            }
....................       
....................             if(functointest_f){
02004:  BTFSS  32.1
02006:  BRA    200A
....................                functointest_f = 0;
02008:  BCF    32.1
....................             }
....................             Ack_F = 1;
0200A:  BSF    1C.7
....................             output_bit(Pbuzzer,1);   //Buzzer
0200C:  BSF    F89.4
0200E:  BCF    F92.4
....................             output_bit(Pbell,1);     //Bell
02010:  BSF    F89.3
02012:  BCF    F92.3
....................    }
02014:  BRA    2026
02016:  MOVLB  0
....................    else if(input(Pack) == 1 && Ack_F == 1)
02018:  BSF    F94.0
0201A:  BTFSS  F82.0
0201C:  BRA    2024
0201E:  BTFSS  1C.7
02020:  BRA    2024
....................    {
....................       Ack_F = 0;
02022:  BCF    1C.7
02024:  MOVLB  7
....................    }
02026:  MOVLB  0
02028:  RETURN 0
.................... 
.................... }
.................... 
.................... ///////////////////// Check Reset ///////////////////////////////////
.................... void check_reset(void)
.................... {
....................     if((input(Preset) == 0 && Reset_F == 0)|| AutoResetFlag ==1) delay_ms(50);
0202A:  BSF    F94.1
0202C:  BTFSC  F82.1
0202E:  BRA    2034
02030:  BTFSS  32.0
02032:  BRA    2038
02034:  BTFSS  1C.3
02036:  BRA    2044
02038:  MOVLW  32
0203A:  MOVLB  7
0203C:  MOVWF  xB9
0203E:  MOVLB  0
02040:  CALL   0662
....................     if((input(Preset) == 0 && Reset_F == 0)|| AutoResetFlag ==1)
02044:  BSF    F94.1
02046:  BTFSC  F82.1
02048:  BRA    204E
0204A:  BTFSS  32.0
0204C:  BRA    2052
0204E:  BTFSS  1C.3
02050:  BRA    211C
....................     {
....................        AutoResetFlag = 0;
02052:  BCF    1C.3
....................        
....................        if((Inputt.B1 ^ InputType.B1) == 0 && In.B1 == 0) Output.B1 = 1;
02054:  MOVLW  00
02056:  MOVLB  7
02058:  BTFSC  x3E.0
0205A:  MOVLW  01
0205C:  MOVWF  xBA
0205E:  MOVLW  00
02060:  BTFSC  x40.0
02062:  MOVLW  01
02064:  XORWF  xBA,W
02066:  BNZ   206E
02068:  BTFSC  x46.0
0206A:  BRA    206E
0206C:  BSF    x3F.0
....................        if((Inputt.B2 ^ InputType.B2) == 0 && In.B2 == 0) Output.B2 = 1;
0206E:  MOVLW  00
02070:  BTFSC  x3E.1
02072:  MOVLW  01
02074:  MOVWF  xBA
02076:  MOVLW  00
02078:  BTFSC  x40.1
0207A:  MOVLW  01
0207C:  XORWF  xBA,W
0207E:  BNZ   2086
02080:  BTFSC  x46.1
02082:  BRA    2086
02084:  BSF    x3F.1
....................        if((Inputt.B3 ^ InputType.B3) == 0 && In.B3 == 0) Output.B3 = 1;
02086:  MOVLW  00
02088:  BTFSC  x3E.2
0208A:  MOVLW  01
0208C:  MOVWF  xBA
0208E:  MOVLW  00
02090:  BTFSC  x40.2
02092:  MOVLW  01
02094:  XORWF  xBA,W
02096:  BNZ   209E
02098:  BTFSC  x46.2
0209A:  BRA    209E
0209C:  BSF    x3F.2
....................        if((Inputt.B4 ^ InputType.B4) == 0 && In.B4 == 0) Output.B4 = 1;
0209E:  MOVLW  00
020A0:  BTFSC  x3E.3
020A2:  MOVLW  01
020A4:  MOVWF  xBA
020A6:  MOVLW  00
020A8:  BTFSC  x40.3
020AA:  MOVLW  01
020AC:  XORWF  xBA,W
020AE:  BNZ   20B6
020B0:  BTFSC  x46.3
020B2:  BRA    20B6
020B4:  BSF    x3F.3
....................        if((Inputt.B5 ^ InputType.B5) == 0 && In.B5 == 0) Output.B5 = 1;
020B6:  MOVLW  00
020B8:  BTFSC  x3E.4
020BA:  MOVLW  01
020BC:  MOVWF  xBA
020BE:  MOVLW  00
020C0:  BTFSC  x40.4
020C2:  MOVLW  01
020C4:  XORWF  xBA,W
020C6:  BNZ   20CE
020C8:  BTFSC  x46.4
020CA:  BRA    20CE
020CC:  BSF    x3F.4
....................        if((Inputt.B6 ^ InputType.B6) == 0 && In.B6 == 0) Output.B6 = 1;
020CE:  MOVLW  00
020D0:  BTFSC  x3E.5
020D2:  MOVLW  01
020D4:  MOVWF  xBA
020D6:  MOVLW  00
020D8:  BTFSC  x40.5
020DA:  MOVLW  01
020DC:  XORWF  xBA,W
020DE:  BNZ   20E6
020E0:  BTFSC  x46.5
020E2:  BRA    20E6
020E4:  BSF    x3F.5
....................        if((Inputt.B7 ^ InputType.B7) == 0 && In.B7 == 0) Output.B7 = 1;
020E6:  MOVLW  00
020E8:  BTFSC  x3E.6
020EA:  MOVLW  01
020EC:  MOVWF  xBA
020EE:  MOVLW  00
020F0:  BTFSC  x40.6
020F2:  MOVLW  01
020F4:  XORWF  xBA,W
020F6:  BNZ   20FE
020F8:  BTFSC  x46.6
020FA:  BRA    20FE
020FC:  BSF    x3F.6
....................        if((Inputt.B8 ^ InputType.B8) == 0 && In.B8 == 0) Output.B8 = 1;
020FE:  MOVLW  00
02100:  BTFSC  x3E.7
02102:  MOVLW  01
02104:  MOVWF  xBA
02106:  MOVLW  00
02108:  BTFSC  x40.7
0210A:  MOVLW  01
0210C:  XORWF  xBA,W
0210E:  BNZ   2116
02110:  BTFSC  x46.7
02112:  BRA    2116
02114:  BSF    x3F.7
.................... 
.................... 
....................        Reset_F = 1;
02116:  BSF    32.0
....................        
....................        
.................... 
....................        
....................     }
02118:  BRA    212A
0211A:  MOVLB  0
....................     else if(input(Preset) == 1 && Reset_F == 1)
0211C:  BSF    F94.1
0211E:  BTFSS  F82.1
02120:  BRA    2128
02122:  BTFSS  32.0
02124:  BRA    2128
....................     {
....................        Reset_F = 0;
02126:  BCF    32.0
02128:  MOVLB  7
....................     }
0212A:  MOVLB  0
0212C:  RETURN 0
.................... }
.................... //////////////////////////////////////////////////////////////////////////////
.................... ////////////////////////////////////////////////////////////////////////////////
.................... /////////////////////// Check Auto Reset function ///////////////////////////////////
.................... ////////////////////////////////////////////////////////////////////////////////////
.................... int1 CheckAutoReset(unsigned char DatType)
.................... {
....................    int1 check;     /// "1" = true  //Other Alarm active or not "ACK"
.................... 
....................    if(DatType == 0x01) // Buzzer
*
042C0:  MOVLB  7
042C2:  DECFSZ xB0,W
042C4:  BRA    449E
....................    {
....................       check = (In.B1 | In2.B1) & ~Ack.B1 & (OutputType.B1 | OutputBoth.B1);
042C6:  MOVLW  00
042C8:  BTFSC  x46.0
042CA:  MOVLW  01
042CC:  MOVWF  xB3
042CE:  MOVLW  00
042D0:  BTFSC  x47.0
042D2:  MOVLW  01
042D4:  IORWF  xB3,W
042D6:  MOVWF  xB2
042D8:  MOVLW  00
042DA:  BTFSS  x45.0
042DC:  MOVLW  01
042DE:  ANDWF  xB2,F
042E0:  MOVLW  00
042E2:  BTFSC  x42.0
042E4:  MOVLW  01
042E6:  MOVWF  xB5
042E8:  MOVLW  00
042EA:  BTFSC  x43.0
042EC:  MOVLW  01
042EE:  IORWF  xB5,W
042F0:  ANDWF  xB2,W
042F2:  BCF    xB1.0
042F4:  BTFSC  FE8.0
042F6:  BSF    xB1.0
....................       check = check | ((In.B2 | In2.B2) & ~Ack.B2 & (OutputType.B2 | OutputBoth.B2));
042F8:  MOVLW  00
042FA:  BTFSC  xB1.0
042FC:  MOVLW  01
042FE:  MOVWF  xB2
04300:  MOVLW  00
04302:  BTFSC  x46.1
04304:  MOVLW  01
04306:  MOVWF  xB4
04308:  MOVLW  00
0430A:  BTFSC  x47.1
0430C:  MOVLW  01
0430E:  IORWF  xB4,W
04310:  MOVWF  xB3
04312:  MOVLW  00
04314:  BTFSS  x45.1
04316:  MOVLW  01
04318:  ANDWF  xB3,F
0431A:  MOVLW  00
0431C:  BTFSC  x42.1
0431E:  MOVLW  01
04320:  MOVWF  xB6
04322:  MOVLW  00
04324:  BTFSC  x43.1
04326:  MOVLW  01
04328:  IORWF  xB6,W
0432A:  ANDWF  xB3,W
0432C:  IORWF  xB2,W
0432E:  BCF    xB1.0
04330:  BTFSC  FE8.0
04332:  BSF    xB1.0
....................       check = check | ((In.B3 | In2.B3) & ~Ack.B3 & (OutputType.B3 | OutputBoth.B3));
04334:  MOVLW  00
04336:  BTFSC  xB1.0
04338:  MOVLW  01
0433A:  MOVWF  xB2
0433C:  MOVLW  00
0433E:  BTFSC  x46.2
04340:  MOVLW  01
04342:  MOVWF  xB4
04344:  MOVLW  00
04346:  BTFSC  x47.2
04348:  MOVLW  01
0434A:  IORWF  xB4,W
0434C:  MOVWF  xB3
0434E:  MOVLW  00
04350:  BTFSS  x45.2
04352:  MOVLW  01
04354:  ANDWF  xB3,F
04356:  MOVLW  00
04358:  BTFSC  x42.2
0435A:  MOVLW  01
0435C:  MOVWF  xB6
0435E:  MOVLW  00
04360:  BTFSC  x43.2
04362:  MOVLW  01
04364:  IORWF  xB6,W
04366:  ANDWF  xB3,W
04368:  IORWF  xB2,W
0436A:  BCF    xB1.0
0436C:  BTFSC  FE8.0
0436E:  BSF    xB1.0
....................       check = check | ((In.B4 | In2.B4) & ~Ack.B4 & (OutputType.B4 | OutputBoth.B4));
04370:  MOVLW  00
04372:  BTFSC  xB1.0
04374:  MOVLW  01
04376:  MOVWF  xB2
04378:  MOVLW  00
0437A:  BTFSC  x46.3
0437C:  MOVLW  01
0437E:  MOVWF  xB4
04380:  MOVLW  00
04382:  BTFSC  x47.3
04384:  MOVLW  01
04386:  IORWF  xB4,W
04388:  MOVWF  xB3
0438A:  MOVLW  00
0438C:  BTFSS  x45.3
0438E:  MOVLW  01
04390:  ANDWF  xB3,F
04392:  MOVLW  00
04394:  BTFSC  x42.3
04396:  MOVLW  01
04398:  MOVWF  xB6
0439A:  MOVLW  00
0439C:  BTFSC  x43.3
0439E:  MOVLW  01
043A0:  IORWF  xB6,W
043A2:  ANDWF  xB3,W
043A4:  IORWF  xB2,W
043A6:  BCF    xB1.0
043A8:  BTFSC  FE8.0
043AA:  BSF    xB1.0
....................       check = check | ((In.B5 | In2.B5) & ~Ack.B5 & (OutputType.B5 | OutputBoth.B5));
043AC:  MOVLW  00
043AE:  BTFSC  xB1.0
043B0:  MOVLW  01
043B2:  MOVWF  xB2
043B4:  MOVLW  00
043B6:  BTFSC  x46.4
043B8:  MOVLW  01
043BA:  MOVWF  xB4
043BC:  MOVLW  00
043BE:  BTFSC  x47.4
043C0:  MOVLW  01
043C2:  IORWF  xB4,W
043C4:  MOVWF  xB3
043C6:  MOVLW  00
043C8:  BTFSS  x45.4
043CA:  MOVLW  01
043CC:  ANDWF  xB3,F
043CE:  MOVLW  00
043D0:  BTFSC  x42.4
043D2:  MOVLW  01
043D4:  MOVWF  xB6
043D6:  MOVLW  00
043D8:  BTFSC  x43.4
043DA:  MOVLW  01
043DC:  IORWF  xB6,W
043DE:  ANDWF  xB3,W
043E0:  IORWF  xB2,W
043E2:  BCF    xB1.0
043E4:  BTFSC  FE8.0
043E6:  BSF    xB1.0
....................       check = check | ((In.B6 | In2.B6) & ~Ack.B6 & (OutputType.B6 | OutputBoth.B6));
043E8:  MOVLW  00
043EA:  BTFSC  xB1.0
043EC:  MOVLW  01
043EE:  MOVWF  xB2
043F0:  MOVLW  00
043F2:  BTFSC  x46.5
043F4:  MOVLW  01
043F6:  MOVWF  xB4
043F8:  MOVLW  00
043FA:  BTFSC  x47.5
043FC:  MOVLW  01
043FE:  IORWF  xB4,W
04400:  MOVWF  xB3
04402:  MOVLW  00
04404:  BTFSS  x45.5
04406:  MOVLW  01
04408:  ANDWF  xB3,F
0440A:  MOVLW  00
0440C:  BTFSC  x42.5
0440E:  MOVLW  01
04410:  MOVWF  xB6
04412:  MOVLW  00
04414:  BTFSC  x43.5
04416:  MOVLW  01
04418:  IORWF  xB6,W
0441A:  ANDWF  xB3,W
0441C:  IORWF  xB2,W
0441E:  BCF    xB1.0
04420:  BTFSC  FE8.0
04422:  BSF    xB1.0
....................       check = check | ((In.B7 | In2.B7) & ~Ack.B7 & (OutputType.B7 | OutputBoth.B7));
04424:  MOVLW  00
04426:  BTFSC  xB1.0
04428:  MOVLW  01
0442A:  MOVWF  xB2
0442C:  MOVLW  00
0442E:  BTFSC  x46.6
04430:  MOVLW  01
04432:  MOVWF  xB4
04434:  MOVLW  00
04436:  BTFSC  x47.6
04438:  MOVLW  01
0443A:  IORWF  xB4,W
0443C:  MOVWF  xB3
0443E:  MOVLW  00
04440:  BTFSS  x45.6
04442:  MOVLW  01
04444:  ANDWF  xB3,F
04446:  MOVLW  00
04448:  BTFSC  x42.6
0444A:  MOVLW  01
0444C:  MOVWF  xB6
0444E:  MOVLW  00
04450:  BTFSC  x43.6
04452:  MOVLW  01
04454:  IORWF  xB6,W
04456:  ANDWF  xB3,W
04458:  IORWF  xB2,W
0445A:  BCF    xB1.0
0445C:  BTFSC  FE8.0
0445E:  BSF    xB1.0
....................       check = check | ((In.B8 | In2.B8) & ~Ack.B8 & (OutputType.B8 | OutputBoth.B8));
04460:  MOVLW  00
04462:  BTFSC  xB1.0
04464:  MOVLW  01
04466:  MOVWF  xB2
04468:  MOVLW  00
0446A:  BTFSC  x46.7
0446C:  MOVLW  01
0446E:  MOVWF  xB4
04470:  MOVLW  00
04472:  BTFSC  x47.7
04474:  MOVLW  01
04476:  IORWF  xB4,W
04478:  MOVWF  xB3
0447A:  MOVLW  00
0447C:  BTFSS  x45.7
0447E:  MOVLW  01
04480:  ANDWF  xB3,F
04482:  MOVLW  00
04484:  BTFSC  x42.7
04486:  MOVLW  01
04488:  MOVWF  xB6
0448A:  MOVLW  00
0448C:  BTFSC  x43.7
0448E:  MOVLW  01
04490:  IORWF  xB6,W
04492:  ANDWF  xB3,W
04494:  IORWF  xB2,W
04496:  BCF    xB1.0
04498:  BTFSC  FE8.0
0449A:  BSF    xB1.0
.................... 
....................      
....................    }
0449C:  BRA    467C
....................    else if(DatType == 0x02)             //Bell
0449E:  MOVF   xB0,W
044A0:  SUBLW  02
044A2:  BTFSS  FD8.2
044A4:  BRA    467C
....................    {
....................       check = (In.B1 | In2.B1) & ~Ack.B1 & (~OutputType.B1 | OutputBoth.B1);
044A6:  MOVLW  00
044A8:  BTFSC  x46.0
044AA:  MOVLW  01
044AC:  MOVWF  xB3
044AE:  MOVLW  00
044B0:  BTFSC  x47.0
044B2:  MOVLW  01
044B4:  IORWF  xB3,W
044B6:  MOVWF  xB2
044B8:  MOVLW  00
044BA:  BTFSS  x45.0
044BC:  MOVLW  01
044BE:  ANDWF  xB2,F
044C0:  MOVLW  00
044C2:  BTFSS  x42.0
044C4:  MOVLW  01
044C6:  MOVWF  xB5
044C8:  MOVLW  00
044CA:  BTFSC  x43.0
044CC:  MOVLW  01
044CE:  IORWF  xB5,W
044D0:  ANDWF  xB2,W
044D2:  BCF    xB1.0
044D4:  BTFSC  FE8.0
044D6:  BSF    xB1.0
....................       check = check | ((In.B2 | In2.B2) & ~Ack.B2 & (~OutputType.B2 | OutputBoth.B2));
044D8:  MOVLW  00
044DA:  BTFSC  xB1.0
044DC:  MOVLW  01
044DE:  MOVWF  xB2
044E0:  MOVLW  00
044E2:  BTFSC  x46.1
044E4:  MOVLW  01
044E6:  MOVWF  xB4
044E8:  MOVLW  00
044EA:  BTFSC  x47.1
044EC:  MOVLW  01
044EE:  IORWF  xB4,W
044F0:  MOVWF  xB3
044F2:  MOVLW  00
044F4:  BTFSS  x45.1
044F6:  MOVLW  01
044F8:  ANDWF  xB3,F
044FA:  MOVLW  00
044FC:  BTFSS  x42.1
044FE:  MOVLW  01
04500:  MOVWF  xB6
04502:  MOVLW  00
04504:  BTFSC  x43.1
04506:  MOVLW  01
04508:  IORWF  xB6,W
0450A:  ANDWF  xB3,W
0450C:  IORWF  xB2,W
0450E:  BCF    xB1.0
04510:  BTFSC  FE8.0
04512:  BSF    xB1.0
....................       check = check | ((In.B3 | In2.B3) & ~Ack.B3 & (~OutputType.B3 | OutputBoth.B3));
04514:  MOVLW  00
04516:  BTFSC  xB1.0
04518:  MOVLW  01
0451A:  MOVWF  xB2
0451C:  MOVLW  00
0451E:  BTFSC  x46.2
04520:  MOVLW  01
04522:  MOVWF  xB4
04524:  MOVLW  00
04526:  BTFSC  x47.2
04528:  MOVLW  01
0452A:  IORWF  xB4,W
0452C:  MOVWF  xB3
0452E:  MOVLW  00
04530:  BTFSS  x45.2
04532:  MOVLW  01
04534:  ANDWF  xB3,F
04536:  MOVLW  00
04538:  BTFSS  x42.2
0453A:  MOVLW  01
0453C:  MOVWF  xB6
0453E:  MOVLW  00
04540:  BTFSC  x43.2
04542:  MOVLW  01
04544:  IORWF  xB6,W
04546:  ANDWF  xB3,W
04548:  IORWF  xB2,W
0454A:  BCF    xB1.0
0454C:  BTFSC  FE8.0
0454E:  BSF    xB1.0
....................       check = check | ((In.B4 | In2.B4) & ~Ack.B4 & (~OutputType.B4 | OutputBoth.B4));
04550:  MOVLW  00
04552:  BTFSC  xB1.0
04554:  MOVLW  01
04556:  MOVWF  xB2
04558:  MOVLW  00
0455A:  BTFSC  x46.3
0455C:  MOVLW  01
0455E:  MOVWF  xB4
04560:  MOVLW  00
04562:  BTFSC  x47.3
04564:  MOVLW  01
04566:  IORWF  xB4,W
04568:  MOVWF  xB3
0456A:  MOVLW  00
0456C:  BTFSS  x45.3
0456E:  MOVLW  01
04570:  ANDWF  xB3,F
04572:  MOVLW  00
04574:  BTFSS  x42.3
04576:  MOVLW  01
04578:  MOVWF  xB6
0457A:  MOVLW  00
0457C:  BTFSC  x43.3
0457E:  MOVLW  01
04580:  IORWF  xB6,W
04582:  ANDWF  xB3,W
04584:  IORWF  xB2,W
04586:  BCF    xB1.0
04588:  BTFSC  FE8.0
0458A:  BSF    xB1.0
....................       check = check | ((In.B5 | In2.B5) & ~Ack.B5 & (~OutputType.B5 | OutputBoth.B5));
0458C:  MOVLW  00
0458E:  BTFSC  xB1.0
04590:  MOVLW  01
04592:  MOVWF  xB2
04594:  MOVLW  00
04596:  BTFSC  x46.4
04598:  MOVLW  01
0459A:  MOVWF  xB4
0459C:  MOVLW  00
0459E:  BTFSC  x47.4
045A0:  MOVLW  01
045A2:  IORWF  xB4,W
045A4:  MOVWF  xB3
045A6:  MOVLW  00
045A8:  BTFSS  x45.4
045AA:  MOVLW  01
045AC:  ANDWF  xB3,F
045AE:  MOVLW  00
045B0:  BTFSS  x42.4
045B2:  MOVLW  01
045B4:  MOVWF  xB6
045B6:  MOVLW  00
045B8:  BTFSC  x43.4
045BA:  MOVLW  01
045BC:  IORWF  xB6,W
045BE:  ANDWF  xB3,W
045C0:  IORWF  xB2,W
045C2:  BCF    xB1.0
045C4:  BTFSC  FE8.0
045C6:  BSF    xB1.0
....................       check = check | ((In.B6 | In2.B6) & ~Ack.B6 & (~OutputType.B6 | OutputBoth.B6));
045C8:  MOVLW  00
045CA:  BTFSC  xB1.0
045CC:  MOVLW  01
045CE:  MOVWF  xB2
045D0:  MOVLW  00
045D2:  BTFSC  x46.5
045D4:  MOVLW  01
045D6:  MOVWF  xB4
045D8:  MOVLW  00
045DA:  BTFSC  x47.5
045DC:  MOVLW  01
045DE:  IORWF  xB4,W
045E0:  MOVWF  xB3
045E2:  MOVLW  00
045E4:  BTFSS  x45.5
045E6:  MOVLW  01
045E8:  ANDWF  xB3,F
045EA:  MOVLW  00
045EC:  BTFSS  x42.5
045EE:  MOVLW  01
045F0:  MOVWF  xB6
045F2:  MOVLW  00
045F4:  BTFSC  x43.5
045F6:  MOVLW  01
045F8:  IORWF  xB6,W
045FA:  ANDWF  xB3,W
045FC:  IORWF  xB2,W
045FE:  BCF    xB1.0
04600:  BTFSC  FE8.0
04602:  BSF    xB1.0
....................       check = check | ((In.B7 | In2.B7) & ~Ack.B7 & (~OutputType.B7 | OutputBoth.B7));
04604:  MOVLW  00
04606:  BTFSC  xB1.0
04608:  MOVLW  01
0460A:  MOVWF  xB2
0460C:  MOVLW  00
0460E:  BTFSC  x46.6
04610:  MOVLW  01
04612:  MOVWF  xB4
04614:  MOVLW  00
04616:  BTFSC  x47.6
04618:  MOVLW  01
0461A:  IORWF  xB4,W
0461C:  MOVWF  xB3
0461E:  MOVLW  00
04620:  BTFSS  x45.6
04622:  MOVLW  01
04624:  ANDWF  xB3,F
04626:  MOVLW  00
04628:  BTFSS  x42.6
0462A:  MOVLW  01
0462C:  MOVWF  xB6
0462E:  MOVLW  00
04630:  BTFSC  x43.6
04632:  MOVLW  01
04634:  IORWF  xB6,W
04636:  ANDWF  xB3,W
04638:  IORWF  xB2,W
0463A:  BCF    xB1.0
0463C:  BTFSC  FE8.0
0463E:  BSF    xB1.0
....................       check = check | ((In.B8 | In2.B8) & ~Ack.B8 & (~OutputType.B8 | OutputBoth.B8));
04640:  MOVLW  00
04642:  BTFSC  xB1.0
04644:  MOVLW  01
04646:  MOVWF  xB2
04648:  MOVLW  00
0464A:  BTFSC  x46.7
0464C:  MOVLW  01
0464E:  MOVWF  xB4
04650:  MOVLW  00
04652:  BTFSC  x47.7
04654:  MOVLW  01
04656:  IORWF  xB4,W
04658:  MOVWF  xB3
0465A:  MOVLW  00
0465C:  BTFSS  x45.7
0465E:  MOVLW  01
04660:  ANDWF  xB3,F
04662:  MOVLW  00
04664:  BTFSS  x42.7
04666:  MOVLW  01
04668:  MOVWF  xB6
0466A:  MOVLW  00
0466C:  BTFSC  x43.7
0466E:  MOVLW  01
04670:  IORWF  xB6,W
04672:  ANDWF  xB3,W
04674:  IORWF  xB2,W
04676:  BCF    xB1.0
04678:  BTFSC  FE8.0
0467A:  BSF    xB1.0
.................... 
.................... 
....................    }
....................    return(check);
0467C:  MOVLW  00
0467E:  BTFSC  xB1.0
04680:  MOVLW  01
04682:  MOVWF  01
04684:  MOVLB  0
04686:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////////////////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... void main()
*
059AA:  CLRF   FF8
059AC:  BCF    FD0.7
059AE:  BSF    07.7
059B0:  MOVLW  70
059B2:  MOVWF  FD3
059B4:  BCF    F9B.6
059B6:  BCF    F9B.7
059B8:  BSF    FB8.3
059BA:  MOVLW  A0
059BC:  MOVWF  FAF
059BE:  MOVLW  01
059C0:  MOVWF  FB0
059C2:  MOVLW  A6
059C4:  MOVWF  FAC
059C6:  MOVLW  90
059C8:  MOVWF  FAB
059CA:  BCF    F93.0
059CC:  BSF    F8A.0
059CE:  CLRF   1B
059D0:  BCF    1C.0
059D2:  MOVLW  19
059D4:  MOVWF  1D
059D6:  BCF    1C.1
059D8:  MOVLW  64
059DA:  MOVWF  1E
059DC:  CLRF   1F
059DE:  BCF    1C.2
059E0:  BCF    1C.3
059E2:  BCF    1C.4
059E4:  CLRF   30
059E6:  BCF    1C.5
059E8:  CLRF   31
059EA:  BCF    1C.6
059EC:  BCF    1C.7
059EE:  BCF    32.0
059F0:  BCF    32.1
059F2:  BCF    32.2
059F4:  BCF    32.3
059F6:  CLRF   33
059F8:  BCF    32.4
059FA:  MOVLW  11
059FC:  MOVWF  x71
059FE:  MOVLW  12
05A00:  MOVWF  x72
05A02:  MOVLW  13
05A04:  MOVWF  x73
05A06:  MOVLW  14
05A08:  MOVWF  x74
05A0A:  MOVLW  16
05A0C:  MOVWF  x75
05A0E:  MOVLW  17
05A10:  MOVWF  x76
05A12:  MOVLW  18
05A14:  MOVWF  x77
05A16:  MOVLW  19
05A18:  MOVWF  x78
05A1A:  MOVLW  20
05A1C:  MOVWF  x79
05A1E:  BCF    32.5
05A20:  CLRF   x7C
05A22:  MOVLW  01
05A24:  MOVLB  3
05A26:  MOVWF  x7F
05A28:  MOVLW  F4
05A2A:  MOVWF  x7E
05A2C:  CLRF   x81
05A2E:  CLRF   x80
05A30:  CLRF   x83
05A32:  CLRF   x82
05A34:  CLRF   x84
05A36:  MOVLB  5
05A38:  CLRF   x89
05A3A:  CLRF   x88
05A3C:  CLRF   x8A
05A3E:  MOVLB  7
05A40:  CLRF   xAB
05A42:  CLRF   xAA
05A44:  CLRF   xAC
05A46:  MOVLB  F
05A48:  CLRF   x38
05A4A:  CLRF   x39
05A4C:  CLRF   x3A
05A4E:  CLRF   F77
05A50:  CLRF   F78
05A52:  CLRF   F79
05A54:  CLRF   19
05A56:  CLRF   1A
05A58:  MOVLW  3E
05A5A:  MOVLB  6
05A5C:  MOVWF  x9A
05A5E:  MOVWF  x9B
05A60:  CLRF   x9C
05A62:  MOVLW  20
05A64:  MOVLB  7
05A66:  MOVWF  x3A
05A68:  CLRF   x3B
05A6A:  MOVLW  3E
05A6C:  MOVWF  xA7
05A6E:  MOVWF  xA8
05A70:  CLRF   xA9
05A72:  CLRF   xAD
.................... {
....................    
....................    
....................    delay_ms(50);
05A74:  MOVLW  32
05A76:  MOVWF  xB9
05A78:  MOVLB  0
05A7A:  CALL   0662
....................    output_bit(Pled,0);   //power on watchdog signal
05A7E:  BCF    F8A.5
05A80:  BCF    F93.5
.................... 
....................    setup_adc_ports(NO_ANALOGS|VSS_VDD);
05A82:  MOVF   FC1,W
05A84:  ANDLW  F0
05A86:  MOVWF  FC1
05A88:  MOVLW  00
05A8A:  MOVLB  F
05A8C:  MOVWF  x38
05A8E:  MOVWF  x39
05A90:  MOVWF  x3A
....................    setup_adc(ADC_OFF|ADC_TAD_MUL_0);
05A92:  BCF    FC2.0
....................    //setup_spi(FALSE);
....................    
....................    setup_timer_0(RTCC_INTERNAL);
05A94:  MOVLW  80
05A96:  MOVWF  FD5
....................    //setup_timer_1(T1_DISABLED);
....................    setup_timer_2(T2_DIV_BY_16,196,16);         //10ms
05A98:  MOVLW  78
05A9A:  IORLW  06
05A9C:  MOVWF  FBA
05A9E:  MOVLW  C4
05AA0:  MOVWF  FBB
....................    //setup_timer_3(T3_DISABLED|T3_DIV_BY_1);
....................    //setup_comparator(NC_NC_NC_NC);
....................    //setup_vref(FALSE);
....................    enable_interrupts(INT_TIMER2);
05AA2:  BSF    F9D.1
....................    enable_interrupts(INT_RDA);
05AA4:  BSF    F9D.5
....................      
....................    setup_spi(SPI_MASTER  | SPI_L_TO_H | SPI_XMIT_L_TO_H| SPI_CLK_DIV_4 ); //master1
05AA6:  BCF    FC6.5
05AA8:  BCF    F94.5
05AAA:  BSF    F94.4
05AAC:  BCF    F94.3
05AAE:  MOVLW  20
05AB0:  MOVWF  FC6
05AB2:  MOVLW  40
05AB4:  MOVWF  FC7
.................... 
....................    IO_INIT();   //initializes the MCP23S17 chip.//----------jj
05AB6:  MOVLB  0
05AB8:  GOTO   06C4
....................   
....................    IO_SET_TRIS_A(IO_DEVICE_0, 0xFF); //addr.0 Set PortA As Inputt
05ABC:  MOVLB  7
05ABE:  CLRF   xB0
05AC0:  SETF   xB1
05AC2:  MOVLB  0
05AC4:  CALL   075A
....................    IO_SET_TRIS_B(IO_DEVICE_0, 0xFF); //addr.0 Set PortB As Inputt
05AC8:  MOVLB  7
05ACA:  CLRF   xB0
05ACC:  SETF   xB1
05ACE:  MOVLB  0
05AD0:  CALL   076C
....................    IO_SET_TRIS_A(IO_DEVICE_1, 0xFF); //addr.1 Set PortA As Inputt 
05AD4:  MOVLW  02
05AD6:  MOVLB  7
05AD8:  MOVWF  xB0
05ADA:  SETF   xB1
05ADC:  MOVLB  0
05ADE:  CALL   075A
....................    IO_SET_TRIS_B(IO_DEVICE_1, 0xFF); //addr.1 Set PortB As Inputt 
05AE2:  MOVLW  02
05AE4:  MOVLB  7
05AE6:  MOVWF  xB0
05AE8:  SETF   xB1
05AEA:  MOVLB  0
05AEC:  CALL   076C
....................    
....................    //  jj
....................    IO_WRITE_REGISTER(IO_DEVICE_0, GPPUA, 0xFF); // Input Pullup
05AF0:  MOVLB  7
05AF2:  CLRF   xBA
05AF4:  MOVLW  06
05AF6:  MOVWF  xBB
05AF8:  SETF   xBC
05AFA:  MOVLB  0
05AFC:  CALL   0692
....................    IO_WRITE_REGISTER(IO_DEVICE_0, GPPUB, 0xFF); // Input Pullup
05B00:  MOVLB  7
05B02:  CLRF   xBA
05B04:  MOVLW  16
05B06:  MOVWF  xBB
05B08:  SETF   xBC
05B0A:  MOVLB  0
05B0C:  CALL   0692
....................    IO_WRITE_REGISTER(IO_DEVICE_1, GPPUA, 0xFF); // Input Pullup
05B10:  MOVLW  02
05B12:  MOVLB  7
05B14:  MOVWF  xBA
05B16:  MOVLW  06
05B18:  MOVWF  xBB
05B1A:  SETF   xBC
05B1C:  MOVLB  0
05B1E:  CALL   0692
....................    IO_WRITE_REGISTER(IO_DEVICE_1, GPPUB, 0xFF); // Input Pullup
05B22:  MOVLW  02
05B24:  MOVLB  7
05B26:  MOVWF  xBA
05B28:  MOVLW  16
05B2A:  MOVWF  xBB
05B2C:  SETF   xBC
05B2E:  MOVLB  0
05B30:  CALL   0692
....................    //  jj
....................    IO_SET_TRIS_A(IO_DEVICE_2, 0x00); //addr.2 Set PortA As Output 
05B34:  MOVLW  04
05B36:  MOVLB  7
05B38:  MOVWF  xB0
05B3A:  CLRF   xB1
05B3C:  MOVLB  0
05B3E:  CALL   075A
....................    IO_SET_TRIS_B(IO_DEVICE_2, 0x00); //addr.2 Set PortB As Output
05B42:  MOVLW  04
05B44:  MOVLB  7
05B46:  MOVWF  xB0
05B48:  CLRF   xB1
05B4A:  MOVLB  0
05B4C:  CALL   076C
....................    IO_SET_TRIS_A(IO_DEVICE_3, 0x00); //addr.3 Set PortA As Output 
05B50:  MOVLW  06
05B52:  MOVLB  7
05B54:  MOVWF  xB0
05B56:  CLRF   xB1
05B58:  MOVLB  0
05B5A:  CALL   075A
....................    IO_SET_TRIS_B(IO_DEVICE_3, 0x00); //addr.3 Set PortB As Output
05B5E:  MOVLW  06
05B60:  MOVLB  7
05B62:  MOVWF  xB0
05B64:  CLRF   xB1
05B66:  MOVLB  0
05B68:  CALL   076C
.................... 
....................    
....................    //FlashingFlag = 1;
....................    //output_bit(P485ctrl,0);
....................    sequence = end_sq;
05B6C:  MOVFF  71,7A
....................    //Address = 1;
....................    
....................    Output.B1 = 1;
05B70:  MOVLB  7
05B72:  BSF    x3F.0
....................    Output.B2 = 1;
05B74:  BSF    x3F.1
....................    Output.B3 = 1;
05B76:  BSF    x3F.2
....................    Output.B4 = 1;
05B78:  BSF    x3F.3
....................    Output.B5 = 1;
05B7A:  BSF    x3F.4
....................    Output.B6 = 1;
05B7C:  BSF    x3F.5
....................    Output.B7 = 1;
05B7E:  BSF    x3F.6
....................    Output.B8 = 1;
05B80:  BSF    x3F.7
....................    ////////////////////
....................    In.B1 = 0;
05B82:  BCF    x46.0
....................    In.B2 = 0;
05B84:  BCF    x46.1
....................    In.B3 = 0;
05B86:  BCF    x46.2
....................    In.B4 = 0;
05B88:  BCF    x46.3
....................    In.B5 = 0;
05B8A:  BCF    x46.4
....................    In.B6 = 0;
05B8C:  BCF    x46.5
....................    In.B7 = 0;
05B8E:  BCF    x46.6
....................    In.B8 = 0;  
05B90:  BCF    x46.7
....................    ////////////////////
....................    In2.B1 = 0;
05B92:  BCF    x47.0
....................    In2.B2 = 0;
05B94:  BCF    x47.1
....................    In2.B3 = 0;
05B96:  BCF    x47.2
....................    In2.B4 = 0;
05B98:  BCF    x47.3
....................    In2.B5 = 0;
05B9A:  BCF    x47.4
....................    In2.B6 = 0;
05B9C:  BCF    x47.5
....................    In2.B7 = 0;
05B9E:  BCF    x47.6
....................    In2.B8 = 0;  
05BA0:  BCF    x47.7
....................    ////////////////////////
....................    Ack.B1 = 0;
05BA2:  BCF    x45.0
....................    Ack.B2 = 0;
05BA4:  BCF    x45.1
....................    Ack.B3 = 0;
05BA6:  BCF    x45.2
....................    Ack.B4 = 0;
05BA8:  BCF    x45.3
....................    Ack.B5 = 0;
05BAA:  BCF    x45.4
....................    Ack.B6 = 0;
05BAC:  BCF    x45.5
....................    Ack.B7 = 0;
05BAE:  BCF    x45.6
....................    Ack.B8 = 0;
05BB0:  BCF    x45.7
....................    
....................     /////// read setting //////////
.................... 
....................    if(read_eeprom(0x00) == 0xF0)
05BB2:  MOVFF  FF2,7B0
05BB6:  BCF    FF2.7
05BB8:  CLRF   FAA
05BBA:  CLRF   FA9
05BBC:  BCF    FA6.6
05BBE:  BCF    FA6.7
05BC0:  BSF    FA6.0
05BC2:  MOVF   FA8,W
05BC4:  BTFSC  xB0.7
05BC6:  BSF    FF2.7
05BC8:  SUBLW  F0
05BCA:  BNZ   5BD6
....................    {
....................       Read_Config();
05BCC:  MOVLB  0
05BCE:  CALL   0780
....................    }
05BD2:  BRA    5D8C
05BD4:  MOVLB  7
....................    else
....................    {
....................       FlashingRateTime = 25;
05BD6:  MOVLW  19
05BD8:  MOVWF  1D
....................       FlashingRate = 25;
05BDA:  MOVLB  0
05BDC:  MOVWF  x6E
....................       AutoAck = 0xF0; //not use auto ack
05BDE:  MOVLW  F0
05BE0:  MOVWF  x6C
....................       Address = 0x01;
05BE2:  MOVLW  01
05BE4:  MOVWF  x7B
.................... 
....................       AutoAckTime = 5;
05BE6:  MOVLW  05
05BE8:  MOVWF  x6D
....................       
....................       NoOfPoint = 8;
05BEA:  MOVLW  08
05BEC:  MOVWF  x6F
....................       //FlashingRateTime = 0x00;
....................       char i;
....................       for(i =0; i<=NoOfPoint; i++)
05BEE:  MOVLB  7
05BF0:  CLRF   xAE
05BF2:  MOVF   xAE,W
05BF4:  MOVLB  0
05BF6:  SUBWF  x6F,W
05BF8:  BNC   5C18
....................       {
....................          FaultDelayTime[i] = 0;
05BFA:  BCF    FD8.0
05BFC:  MOVLB  7
05BFE:  RLCF   xAE,W
05C00:  CLRF   03
05C02:  ADDLW  7B
05C04:  MOVWF  FE9
05C06:  MOVLW  07
05C08:  ADDWFC 03,W
05C0A:  MOVWF  FEA
05C0C:  CLRF   FEC
05C0E:  MOVF   FED,F
05C10:  CLRF   FEF
05C12:  INCF   xAE,F
05C14:  BRA    5BF2
05C16:  MOVLB  0
....................       }
.................... 
....................       InputType.B1 = 1;
05C18:  MOVLB  7
05C1A:  BSF    x40.0
....................       InputType.B2 = 1;
05C1C:  BSF    x40.1
....................       InputType.B3 = 1;
05C1E:  BSF    x40.2
....................       InputType.B4 = 1;
05C20:  BSF    x40.3
....................       InputType.B5 = 1;
05C22:  BSF    x40.4
....................       InputType.B6 = 1;
05C24:  BSF    x40.5
....................       InputType.B7 = 1;
05C26:  BSF    x40.6
....................       InputType.B8 = 1;
05C28:  BSF    x40.7
....................       
....................       FaultNCNO[1] = 1;
05C2A:  BSF    xA4.1
....................       FaultNCNO[2] = 1;
05C2C:  BSF    xA4.2
....................       FaultNCNO[3] = 1;
05C2E:  BSF    xA4.3
....................       FaultNCNO[4] = 1;
05C30:  BSF    xA4.4
....................       FaultNCNO[5] = 1;
05C32:  BSF    xA4.5
....................       FaultNCNO[6] = 1;
05C34:  BSF    xA4.6
....................       FaultNCNO[7] = 1;
05C36:  BSF    xA4.7
....................       FaultNCNO[8] = 1;
05C38:  BSF    xA5.0
....................       
....................       /////////////////////////////
....................       FaultType.B1 = 1;
05C3A:  BSF    x41.0
....................       FaultType.B2= 1;
05C3C:  BSF    x41.1
....................       FaultType.B3 = 1;
05C3E:  BSF    x41.2
....................       FaultType.B4 = 1;
05C40:  BSF    x41.3
....................       FaultType.B5 = 1;
05C42:  BSF    x41.4
....................       FaultType.B6 = 1;
05C44:  BSF    x41.5
....................       FaultType.B7 = 1;
05C46:  BSF    x41.6
....................       FaultType.B8 = 1;
05C48:  BSF    x41.7
....................       
....................       ////////////////////////////
....................       OutputType.B1 = 1;
05C4A:  BSF    x42.0
....................       OutputType.B2 = 1;
05C4C:  BSF    x42.1
....................       OutputType.B3 = 1;
05C4E:  BSF    x42.2
....................       OutputType.B4 = 1;
05C50:  BSF    x42.3
....................       OutputType.B5 = 1;
05C52:  BSF    x42.4
....................       OutputType.B6 = 1;
05C54:  BSF    x42.5
....................       OutputType.B7 = 1;
05C56:  BSF    x42.6
....................       OutputType.B8 = 1;
05C58:  BSF    x42.7
.................... 
....................       /////////////////////////////
....................       OutputBoth.B1 = 1;
05C5A:  BSF    x43.0
....................       OutputBoth.B2 = 1;
05C5C:  BSF    x43.1
....................       OutputBoth.B3 = 1;
05C5E:  BSF    x43.2
....................       OutputBoth.B4 = 1;
05C60:  BSF    x43.3
....................       OutputBoth.B5 = 1;
05C62:  BSF    x43.4
....................       OutputBoth.B6 = 1;
05C64:  BSF    x43.5
....................       OutputBoth.B7 = 1;
05C66:  BSF    x43.6
....................       OutputBoth.B8 = 1;
05C68:  BSF    x43.7
.................... 
....................       
....................       //////////////////////////////////////////////
....................       AlarmIndicator.B1 = 1;
05C6A:  BSF    x44.0
....................       AlarmIndicator.B2 = 1;
05C6C:  BSF    x44.1
....................       AlarmIndicator.B3 = 1;
05C6E:  BSF    x44.2
....................       AlarmIndicator.B4 = 1;
05C70:  BSF    x44.3
....................       AlarmIndicator.B5 = 1;
05C72:  BSF    x44.4
....................       AlarmIndicator.B6 = 1;
05C74:  BSF    x44.5
....................       AlarmIndicator.B7 = 1;
05C76:  BSF    x44.6
....................       AlarmIndicator.B8 = 1;
05C78:  BSF    x44.7
.................... 
....................       ///////////// JACK///////////////////
....................       EEpDat = read_eeprom(0x10);
05C7A:  MOVFF  FF2,7B0
05C7E:  BCF    FF2.7
05C80:  CLRF   FAA
05C82:  MOVLW  10
05C84:  MOVWF  FA9
05C86:  BCF    FA6.6
05C88:  BCF    FA6.7
05C8A:  BSF    FA6.0
05C8C:  MOVF   FA8,W
05C8E:  BTFSC  xB0.7
05C90:  BSF    FF2.7
05C92:  MOVWF  3B
....................       //Red1_8 = EEpDat;
....................       RED_Colour.B1 = EEpDat;
05C94:  BCF    x4A.0
05C96:  BTFSC  3B.0
05C98:  BSF    x4A.0
....................       RED_Colour.B2 = EEpDat >> 1;
05C9A:  BCF    FD8.0
05C9C:  RRCF   3B,W
05C9E:  BCF    x4A.1
05CA0:  BTFSC  FE8.0
05CA2:  BSF    x4A.1
....................       RED_Colour.B3 = EEpDat >> 2;
05CA4:  RRCF   3B,W
05CA6:  MOVWF  00
05CA8:  RRCF   00,F
05CAA:  MOVLW  3F
05CAC:  ANDWF  00,F
05CAE:  BCF    x4A.2
05CB0:  BTFSC  00.0
05CB2:  BSF    x4A.2
....................       RED_Colour.B4 = EEpDat >> 3;
05CB4:  RRCF   3B,W
05CB6:  MOVWF  00
05CB8:  RRCF   00,F
05CBA:  RRCF   00,F
05CBC:  MOVLW  1F
05CBE:  ANDWF  00,F
05CC0:  BCF    x4A.3
05CC2:  BTFSC  00.0
05CC4:  BSF    x4A.3
....................       RED_Colour.B5 = EEpDat >> 4;
05CC6:  SWAPF  3B,W
05CC8:  MOVWF  00
05CCA:  MOVLW  0F
05CCC:  ANDWF  00,F
05CCE:  BCF    x4A.4
05CD0:  BTFSC  00.0
05CD2:  BSF    x4A.4
....................       RED_Colour.B6 = EEpDat >> 5;
05CD4:  SWAPF  3B,W
05CD6:  MOVWF  00
05CD8:  RRCF   00,F
05CDA:  MOVLW  07
05CDC:  ANDWF  00,F
05CDE:  BCF    x4A.5
05CE0:  BTFSC  00.0
05CE2:  BSF    x4A.5
....................       RED_Colour.B7 = EEpDat >> 6;
05CE4:  SWAPF  3B,W
05CE6:  MOVWF  00
05CE8:  RRCF   00,F
05CEA:  RRCF   00,F
05CEC:  MOVLW  03
05CEE:  ANDWF  00,F
05CF0:  BCF    x4A.6
05CF2:  BTFSC  00.0
05CF4:  BSF    x4A.6
....................       RED_Colour.B8 = EEpDat >> 7;
05CF6:  CLRF   00
05CF8:  BTFSC  3B.7
05CFA:  BSF    00.0
05CFC:  BCF    x4A.7
05CFE:  BTFSC  00.0
05D00:  BSF    x4A.7
....................         
....................       EEpDat = read_eeprom(0x14);
05D02:  MOVFF  FF2,7B0
05D06:  BCF    FF2.7
05D08:  CLRF   FAA
05D0A:  MOVLW  14
05D0C:  MOVWF  FA9
05D0E:  BCF    FA6.6
05D10:  BCF    FA6.7
05D12:  BSF    FA6.0
05D14:  MOVF   FA8,W
05D16:  BTFSC  xB0.7
05D18:  BSF    FF2.7
05D1A:  MOVWF  3B
....................       //Green1_8 = EEpDat;
....................       GREEN_Colour.B1 = EEpDat;
05D1C:  BCF    x4B.0
05D1E:  BTFSC  3B.0
05D20:  BSF    x4B.0
....................       GREEN_Colour.B2 = EEpDat >> 1;
05D22:  BCF    FD8.0
05D24:  RRCF   3B,W
05D26:  BCF    x4B.1
05D28:  BTFSC  FE8.0
05D2A:  BSF    x4B.1
....................       GREEN_Colour.B3 = EEpDat >> 2;
05D2C:  RRCF   3B,W
05D2E:  MOVWF  00
05D30:  RRCF   00,F
05D32:  MOVLW  3F
05D34:  ANDWF  00,F
05D36:  BCF    x4B.2
05D38:  BTFSC  00.0
05D3A:  BSF    x4B.2
....................       GREEN_Colour.B4 = EEpDat >> 3;
05D3C:  RRCF   3B,W
05D3E:  MOVWF  00
05D40:  RRCF   00,F
05D42:  RRCF   00,F
05D44:  MOVLW  1F
05D46:  ANDWF  00,F
05D48:  BCF    x4B.3
05D4A:  BTFSC  00.0
05D4C:  BSF    x4B.3
....................       GREEN_Colour.B5 = EEpDat >> 4;
05D4E:  SWAPF  3B,W
05D50:  MOVWF  00
05D52:  MOVLW  0F
05D54:  ANDWF  00,F
05D56:  BCF    x4B.4
05D58:  BTFSC  00.0
05D5A:  BSF    x4B.4
....................       GREEN_Colour.B6 = EEpDat >> 5;
05D5C:  SWAPF  3B,W
05D5E:  MOVWF  00
05D60:  RRCF   00,F
05D62:  MOVLW  07
05D64:  ANDWF  00,F
05D66:  BCF    x4B.5
05D68:  BTFSC  00.0
05D6A:  BSF    x4B.5
....................       GREEN_Colour.B7 = EEpDat >> 6;
05D6C:  SWAPF  3B,W
05D6E:  MOVWF  00
05D70:  RRCF   00,F
05D72:  RRCF   00,F
05D74:  MOVLW  03
05D76:  ANDWF  00,F
05D78:  BCF    x4B.6
05D7A:  BTFSC  00.0
05D7C:  BSF    x4B.6
....................       GREEN_Colour.B8 = EEpDat >> 7;
05D7E:  CLRF   00
05D80:  BTFSC  3B.7
05D82:  BSF    00.0
05D84:  BCF    x4B.7
05D86:  BTFSC  00.0
05D88:  BSF    x4B.7
05D8A:  MOVLB  0
....................    
....................    ///////////// JACK/////////////////////////////////////
....................       
....................    }
....................    
....................    set_tris_a (0b00000000); //PORTA SET TO OUTPUT
05D8C:  MOVLW  00
05D8E:  MOVWF  F92
....................    set_tris_b (0b00000000); //PORTA SET TO OUTPUT
05D90:  MOVWF  F93
....................    enable_interrupts(GLOBAL);
05D92:  MOVLW  C0
05D94:  IORWF  FF2,F
....................    setup_wdt(WDT_ON);
05D96:  BSF    FD1.0
....................    Read_input(); restart_wdt();
05D98:  CALL   146E
05D9C:  CLRWDT
....................    output_bit(Pbuzzer,1);  //Clear Buzzer
05D9E:  BSF    F89.4
05DA0:  BCF    F92.4
....................    output_bit(Pbell,1);   //Clear Bell
05DA2:  BSF    F89.3
05DA4:  BCF    F92.3
....................    output_bit(P485ctrl,0);
05DA6:  BCF    F8A.3
05DA8:  BCF    F93.3
....................    //output_bit(P485ctrl,0);
....................    output_bit(PIN_B4,0); //jj
05DAA:  BCF    F8A.4
05DAC:  BCF    F93.4
....................    Send_Ouput();
05DAE:  CALL   1B3E
....................    
....................    IO_OUTPUT_A(IO_DEVICE_2, 0xff);
05DB2:  MOVLW  04
05DB4:  MOVLB  7
05DB6:  MOVWF  xB8
05DB8:  SETF   xB9
05DBA:  MOVLB  0
05DBC:  CALL   1B12
....................    IO_OUTPUT_B(IO_DEVICE_2, 0xff);
05DC0:  MOVLW  04
05DC2:  MOVLB  7
05DC4:  MOVWF  xB8
05DC6:  SETF   xB9
05DC8:  MOVLB  0
05DCA:  CALL   1B28
....................             
....................    IO_OUTPUT_A(IO_DEVICE_3, 0xff);
05DCE:  MOVLW  06
05DD0:  MOVLB  7
05DD2:  MOVWF  xB8
05DD4:  SETF   xB9
05DD6:  MOVLB  0
05DD8:  CALL   1B12
....................    IO_OUTPUT_B(IO_DEVICE_3, 0xff);
05DDC:  MOVLW  06
05DDE:  MOVLB  7
05DE0:  MOVWF  xB8
05DE2:  SETF   xB9
05DE4:  MOVLB  0
05DE6:  CALL   1B28
....................    restart_wdt();
05DEA:  CLRWDT
....................    delay_ms(100);
05DEC:  MOVLW  64
05DEE:  MOVLB  7
05DF0:  MOVWF  xB9
05DF2:  MOVLB  0
05DF4:  CALL   0662
.................... 
....................    // jj
....................    /*
....................    char i;
....................    for(i=1;i<=8;i++)
....................    {
....................       FaultAgo[i] = 0;
....................       FaultNow[i] = 0;
....................       ReleaseTime[i] = 0;
....................       
....................       if(FaultNCNO[i] ==NO)
....................       {
....................          switch(i)
....................          {
....................             case 1:
....................                Inputt.B1 = 0; 
....................             break;
....................             case 2:
....................                Inputt.B2 = 0; 
....................             break;
....................             case 3:
....................                Inputt.B3 = 0; 
....................             break;
....................             case 4:
....................                Inputt.B4 = 0; 
....................             break;
....................             case 5:
....................                Inputt.B5 = 0; 
....................             break;
....................             case 6:
....................                Inputt.B6 = 0; 
....................             break;
....................             case 7:
....................                Inputt.B7 = 0; 
....................              break;
....................              case 8:
....................                Inputt.B8 = 0; 
....................             break;
....................             
....................          }                 
....................       }
....................       else
....................       {
....................          switch(i)
....................          {
....................             case 1:
....................                Inputt.B1 = 1; 
....................             break;
....................             case 2:
....................                Inputt.B2 = 1; 
....................             break;
....................             case 3:
....................                Inputt.B3 = 1; 
....................             break;
....................             case 4:
....................                Inputt.B4 = 1; 
....................             break;
....................             case 5:
....................                Inputt.B5 = 1; 
....................             break;
....................             case 6:
....................                Inputt.B6 = 1; 
....................             break;
....................             case 7:
....................                Inputt.B7 = 1; 
....................              break;
....................              case 8:
....................                Inputt.B8 = 1; 
....................             break;
....................            
....................          }                 
....................       }
....................       
....................    }
....................    */
....................    //GSM SIM900 Init
....................    delay_ms(1000);
05DF8:  MOVLW  04
05DFA:  MOVLB  7
05DFC:  MOVWF  xB0
05DFE:  MOVLW  FA
05E00:  MOVWF  xB9
05E02:  MOVLB  0
05E04:  CALL   0662
05E08:  MOVLB  7
05E0A:  DECFSZ xB0,F
05E0C:  BRA    5DFE
....................    fprintf(CH2,"AT+CMGF=1"); 
05E0E:  MOVLW  58
05E10:  MOVWF  FF6
05E12:  MOVLW  06
05E14:  MOVWF  FF7
05E16:  MOVLB  0
05E18:  CALL   1D5C
....................    putc('\n',CH2);
05E1C:  MOVLW  0A
05E1E:  MOVLB  7
05E20:  MOVWF  xB2
05E22:  MOVLB  0
05E24:  CALL   1D16
....................    delay_ms(50);
05E28:  MOVLW  32
05E2A:  MOVLB  7
05E2C:  MOVWF  xB9
05E2E:  MOVLB  0
05E30:  CALL   0662
....................    
....................    SendSMS.B1 =0;
05E34:  MOVLB  7
05E36:  BCF    x4C.0
....................    SendSMS.B2 =0;
05E38:  BCF    x4C.1
....................    SendSMS.B3 =0;
05E3A:  BCF    x4C.2
....................    SendSMS.B4 =0;
05E3C:  BCF    x4C.3
....................    SendSMS.B5 =0;
05E3E:  BCF    x4C.4
....................    SendSMS.B6 =0;
05E40:  BCF    x4C.5
....................    SendSMS.B7 =0;
05E42:  BCF    x4C.6
....................    SendSMS.B8 =0;
05E44:  BCF    x4C.7
....................    
....................    char m;
....................    for(m=0; m<10; m++)
05E46:  CLRF   xAF
05E48:  MOVF   xAF,W
05E4A:  SUBLW  09
05E4C:  BNC   5E80
....................    {
....................       sms_phonenumber[m] = read_eeprom(0x32 + m);
05E4E:  CLRF   03
05E50:  MOVF   xAF,W
05E52:  ADDLW  8B
05E54:  MOVWF  FE9
05E56:  MOVLW  05
05E58:  ADDWFC 03,W
05E5A:  MOVWF  FEA
05E5C:  MOVLW  32
05E5E:  ADDWF  xAF,W
05E60:  MOVWF  xB2
05E62:  MOVFF  FF2,7B3
05E66:  BCF    FF2.7
05E68:  CLRF   FAA
05E6A:  MOVFF  7B2,FA9
05E6E:  BCF    FA6.6
05E70:  BCF    FA6.7
05E72:  BSF    FA6.0
05E74:  MOVF   FA8,W
05E76:  BTFSC  xB3.7
05E78:  BSF    FF2.7
05E7A:  MOVWF  FEF
05E7C:  INCF   xAF,F
05E7E:  BRA    5E48
....................    }
....................    sms_phonenumber[m] = '\0' ; // end string
05E80:  CLRF   03
05E82:  MOVF   xAF,W
05E84:  ADDLW  8B
05E86:  MOVWF  FE9
05E88:  MOVLW  05
05E8A:  ADDWFC 03,W
05E8C:  MOVWF  FEA
05E8E:  CLRF   FEF
....................    delay_ms(500);
05E90:  MOVLW  02
05E92:  MOVWF  xB0
05E94:  MOVLW  FA
05E96:  MOVWF  xB9
05E98:  MOVLB  0
05E9A:  CALL   0662
05E9E:  MOVLB  7
05EA0:  DECFSZ xB0,F
05EA2:  BRA    5E94
....................    functointest_f =0;
05EA4:  BCF    32.1
....................    
....................    while(TRUE)
....................    {
.................... 
....................       IO_OUTPUT_A(IO_DEVICE_0, 0xFF); //jj 
05EA6:  CLRF   xB8
05EA8:  SETF   xB9
05EAA:  MOVLB  0
05EAC:  CALL   1B12
....................       IO_OUTPUT_B(IO_DEVICE_0, 0xFF); //jj 
05EB0:  MOVLB  7
05EB2:  CLRF   xB8
05EB4:  SETF   xB9
05EB6:  MOVLB  0
05EB8:  CALL   1B28
....................       IO_OUTPUT_A(IO_DEVICE_1, 0xFF); //jj 
05EBC:  MOVLW  02
05EBE:  MOVLB  7
05EC0:  MOVWF  xB8
05EC2:  SETF   xB9
05EC4:  MOVLB  0
05EC6:  CALL   1B12
....................       IO_OUTPUT_B(IO_DEVICE_1, 0xFF); //jj 
05ECA:  MOVLW  02
05ECC:  MOVLB  7
05ECE:  MOVWF  xB8
05ED0:  SETF   xB9
05ED2:  MOVLB  0
05ED4:  CALL   1B28
....................       
....................       restart_wdt();
05ED8:  CLRWDT
.................... 
....................       if(recieve_completed == 1)
05EDA:  BTFSS  32.5
05EDC:  BRA    5EE4
....................       {
....................          Modbus_Function();
05EDE:  GOTO   212E
....................          recieve_completed = 0 ;
05EE2:  BCF    32.5
....................       }
....................   
....................       check_ack();
05EE4:  CALL   1F46
....................       check_reset();
05EE8:  CALL   202A
....................       check_test();
05EEC:  GOTO   4196
....................       
....................       restart_wdt();
05EF0:  CLRWDT
.................... 
....................       
....................       Anal_Function(); 
05EF2:  GOTO   4688
....................       Send_Ouput(); 
05EF6:  CALL   1B3E
....................       Read_input();  //must be first
05EFA:  CALL   146E
....................       //Driver595(); restart_wdt();
....................       if(send_SMS_period){
05EFE:  MOVLB  7
05F00:  MOVF   x3C,F
05F02:  BZ    5F0C
....................          send_SMS_period =0;
05F04:  CLRF   x3C
....................          sendsum_sms();
05F06:  MOVLB  0
05F08:  BRA    58F4
05F0A:  MOVLB  7
....................       }
....................       
....................       output_toggle(PIN_A0);
05F0C:  BCF    F92.0
05F0E:  BTG    F89.0
....................       
....................       if(RefreshConfigData)
05F10:  BTFSS  32.4
05F12:  BRA    5FCE
....................       {
....................          RefreshConfigData =0;
05F14:  BCF    32.4
....................          Read_Config();
05F16:  MOVLB  0
05F18:  CALL   0780
....................          //IO_INIT();   //initializes the MCP23S17 chip.//----------jj
....................   
....................          IO_SET_TRIS_A(IO_DEVICE_0, 0xFF); //addr.0 Set PortA As Inputt
05F1C:  MOVLB  7
05F1E:  CLRF   xB0
05F20:  SETF   xB1
05F22:  MOVLB  0
05F24:  CALL   075A
....................          IO_SET_TRIS_B(IO_DEVICE_0, 0xFF); //addr.0 Set PortB As Inputt
05F28:  MOVLB  7
05F2A:  CLRF   xB0
05F2C:  SETF   xB1
05F2E:  MOVLB  0
05F30:  CALL   076C
....................          IO_SET_TRIS_A(IO_DEVICE_1, 0xFF); //addr.1 Set PortA As Inputt 
05F34:  MOVLW  02
05F36:  MOVLB  7
05F38:  MOVWF  xB0
05F3A:  SETF   xB1
05F3C:  MOVLB  0
05F3E:  CALL   075A
....................          IO_SET_TRIS_B(IO_DEVICE_1, 0xFF); //addr.1 Set PortB As Inputt 
05F42:  MOVLW  02
05F44:  MOVLB  7
05F46:  MOVWF  xB0
05F48:  SETF   xB1
05F4A:  MOVLB  0
05F4C:  CALL   076C
....................          //  jj
....................          IO_WRITE_REGISTER(IO_DEVICE_0, GPPUA, 0xFF); // Input Pullup
05F50:  MOVLB  7
05F52:  CLRF   xBA
05F54:  MOVLW  06
05F56:  MOVWF  xBB
05F58:  SETF   xBC
05F5A:  MOVLB  0
05F5C:  CALL   0692
....................          IO_WRITE_REGISTER(IO_DEVICE_0, GPPUB, 0xFF); // Input Pullup
05F60:  MOVLB  7
05F62:  CLRF   xBA
05F64:  MOVLW  16
05F66:  MOVWF  xBB
05F68:  SETF   xBC
05F6A:  MOVLB  0
05F6C:  CALL   0692
....................          IO_WRITE_REGISTER(IO_DEVICE_1, GPPUA, 0xFF); // Input Pullup
05F70:  MOVLW  02
05F72:  MOVLB  7
05F74:  MOVWF  xBA
05F76:  MOVLW  06
05F78:  MOVWF  xBB
05F7A:  SETF   xBC
05F7C:  MOVLB  0
05F7E:  CALL   0692
....................          IO_WRITE_REGISTER(IO_DEVICE_1, GPPUB, 0xFF); // Input Pullup
05F82:  MOVLW  02
05F84:  MOVLB  7
05F86:  MOVWF  xBA
05F88:  MOVLW  16
05F8A:  MOVWF  xBB
05F8C:  SETF   xBC
05F8E:  MOVLB  0
05F90:  CALL   0692
....................          //  jj
....................          IO_SET_TRIS_A(IO_DEVICE_2, 0x00); //addr.2 Set PortA As Output 
05F94:  MOVLW  04
05F96:  MOVLB  7
05F98:  MOVWF  xB0
05F9A:  CLRF   xB1
05F9C:  MOVLB  0
05F9E:  CALL   075A
....................          IO_SET_TRIS_B(IO_DEVICE_2, 0x00); //addr.2 Set PortB As Output
05FA2:  MOVLW  04
05FA4:  MOVLB  7
05FA6:  MOVWF  xB0
05FA8:  CLRF   xB1
05FAA:  MOVLB  0
05FAC:  CALL   076C
....................          IO_SET_TRIS_A(IO_DEVICE_3, 0x00); //addr.3 Set PortA As Output 
05FB0:  MOVLW  06
05FB2:  MOVLB  7
05FB4:  MOVWF  xB0
05FB6:  CLRF   xB1
05FB8:  MOVLB  0
05FBA:  CALL   075A
....................          IO_SET_TRIS_B(IO_DEVICE_3, 0x00); //addr.3 Set PortB As Output
05FBE:  MOVLW  06
05FC0:  MOVLB  7
05FC2:  MOVWF  xB0
05FC4:  CLRF   xB1
05FC6:  MOVLB  0
05FC8:  CALL   076C
05FCC:  MOVLB  7
.................... 
....................       }
05FCE:  BRA    5EA6
....................    }
....................    
.................... }
05FD0:  SLEEP 

Configuration Fuses:
   Word  1: E800   INTRC_IO NOPLLEN PRIMARY FCMEN IESO
   Word  2: 1B1F   NOPUT BROWNOUT BORV19 WDT WDT64
   Word  3: BF00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2B5 MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
